(window.webpackJsonp = window.webpackJsonp || []).push([[5], { "/Tr7": function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("jIYg"); function r(t) { Object(s.a)(1, arguments); var e = Object.prototype.toString.call(t); return t instanceof Date || "object" == typeof t && "[object Date]" === e ? new Date(t.getTime()) : "number" == typeof t || "[object Number]" === e ? new Date(t) : ("string" != typeof t && "[object String]" !== e || "undefined" == typeof console || (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"), console.warn((new Error).stack)), new Date(NaN)) } }, "/uUt": function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("7o/Q"); function r(t, e) { return n => n.lift(new i(t, e)) } class i { constructor(t, e) { this.compare = t, this.keySelector = e } call(t, e) { return e.subscribe(new o(t, this.compare, this.keySelector)) } } class o extends s.a { constructor(t, e, n) { super(t), this.keySelector = n, this.hasKey = !1, "function" == typeof e && (this.compare = e) } compare(t, e) { return t === e } _next(t) { let e; try { const { keySelector: n } = this; e = n ? n(t) : t } catch (s) { return this.destination.error(s) } let n = !1; if (this.hasKey) try { const { compare: t } = this; n = t(this.key, e) } catch (s) { return this.destination.error(s) } else this.hasKey = !0; n || (this.key = e, this.destination.next(t)) } } }, "1G5W": function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("zx2A"); function r(t) { return e => e.lift(new i(t)) } class i { constructor(t) { this.notifier = t } call(t, e) { const n = new o(t), r = Object(s.c)(this.notifier, new s.a(n)); return r && !n.seenValue ? (n.add(r), e.subscribe(n)) : n } } class o extends s.b { constructor(t) { super(t), this.seenValue = !1 } notifyNext() { this.seenValue = !0, this.complete() } notifyComplete() { } } }, "2QA8": function (t, e, n) { "use strict"; n.d(e, "a", function () { return s }); const s = (() => "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random())() }, "2Vo4": function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }); var s = n("XNiG"), r = n("9ppp"); class i extends s.a { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return e && !e.closed && t.next(this._value), e } getValue() { if (this.hasError) throw this.thrownError; if (this.closed) throw new r.a; return this._value } next(t) { super.next(this._value = t) } } }, "2fFW": function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); let s = !1; const r = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(t) { if (t) { const t = new Error; console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + t.stack) } else s && console.log("RxJS: Back to a better error behavior. Thank you. <3"); s = t }, get useDeprecatedSynchronousErrorHandling() { return s } } }, "3E0/": function (t, e, n) { "use strict"; n.d(e, "a", function () { return a }); var s = n("D0XW"), r = n("mlxB"), i = n("7o/Q"), o = n("WMd4"); function a(t, e = s.a) { const n = Object(r.a)(t) ? +t - e.now() : Math.abs(t); return t => t.lift(new c(n, e)) } class c { constructor(t, e) { this.delay = t, this.scheduler = e } call(t, e) { return e.subscribe(new l(t, this.delay, this.scheduler)) } } class l extends i.a { constructor(t, e, n) { super(t), this.delay = e, this.scheduler = n, this.queue = [], this.active = !1, this.errored = !1 } static dispatch(t) { const e = t.source, n = e.queue, s = t.scheduler, r = t.destination; for (; n.length > 0 && n[0].time - s.now() <= 0;)n.shift().notification.observe(r); if (n.length > 0) { const e = Math.max(0, n[0].time - s.now()); this.schedule(t, e) } else this.unsubscribe(), e.active = !1 } _schedule(t) { this.active = !0, this.destination.add(t.schedule(l.dispatch, this.delay, { source: this, destination: this.destination, scheduler: t })) } scheduleNotification(t) { if (!0 === this.errored) return; const e = this.scheduler, n = new u(e.now() + this.delay, t); this.queue.push(n), !1 === this.active && this._schedule(e) } _next(t) { this.scheduleNotification(o.a.createNext(t)) } _error(t) { this.errored = !0, this.queue = [], this.destination.error(t), this.unsubscribe() } _complete() { this.scheduleNotification(o.a.createComplete()), this.unsubscribe() } } class u { constructor(t, e) { this.time = t, this.notification = e } } }, "3N8a": function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }); var s = n("quSY"); class r extends s.a { constructor(t, e) { super() } schedule(t, e = 0) { return this } } class i extends r { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this; this.state = t; const n = this.id, s = this.scheduler; return null != n && (this.id = this.recycleAsyncId(s, n, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(s, this.id, e), this } requestAsyncId(t, e, n = 0) { return setInterval(t.flush.bind(t, this), n) } recycleAsyncId(t, e, n = 0) { if (null !== n && this.delay === n && !1 === this.pending) return e; clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const n = this._execute(t, e); if (n) return n; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let n, s = !1; try { this.work(t) } catch (r) { s = !0, n = !!r && r || new Error(r) } if (s) return this.unsubscribe(), n } _unsubscribe() { const t = this.id, e = this.scheduler, n = e.actions, s = n.indexOf(this); this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== s && n.splice(s, 1), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null } } }, "3Pt+": function (t, e, n) { "use strict"; n.d(e, "a", function () { return p }), n.d(e, "b", function () { return h }), n.d(e, "c", function () { return M }), n.d(e, "d", function () { return f }), n.d(e, "e", function () { return ot }), n.d(e, "f", function () { return Nt }), n.d(e, "g", function () { return rt }), n.d(e, "h", function () { return Ot }), n.d(e, "i", function () { return it }), n.d(e, "j", function () { return mt }), n.d(e, "k", function () { return _t }), n.d(e, "l", function () { return Dt }), n.d(e, "m", function () { return _ }), n.d(e, "n", function () { return b }), n.d(e, "o", function () { return l }), n.d(e, "p", function () { return F }), n.d(e, "q", function () { return B }), n.d(e, "r", function () { return U }), n.d(e, "s", function () { return ht }), n.d(e, "t", function () { return Tt }), n.d(e, "u", function () { return Mt }), n.d(e, "v", function () { return It }), n.d(e, "w", function () { return Et }), n.d(e, "x", function () { return y }), n.d(e, "y", function () { return dt }), n.d(e, "z", function () { return Rt }); var s = n("fXoL"), r = n("ofXK"), i = n("Cfvw"), o = n("cp0P"), a = n("lJxs"); class c { } const l = new s.r("NgValueAccessor"), u = { provide: l, useExisting: Object(s.V)(() => h), multi: !0 }; let h = (() => { class t extends c { constructor(t, e) { super(), this._renderer = t, this._elementRef = e, this.onChange = t => { }, this.onTouched = () => { } } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "checked", t) } registerOnChange(t) { this.onChange = t } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.F), s.Rb(s.l)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && s.ec("change", function (t) { return e.onChange(t.target.checked) })("blur", function () { return e.onTouched() }) }, features: [s.Bb([u]), s.zb] }), t })(); const d = { provide: l, useExisting: Object(s.V)(() => f), multi: !0 }, p = new s.r("CompositionEventMode"); let f = (() => { class t { constructor(t, e, n) { this._renderer = t, this._elementRef = e, this._compositionMode = n, this.onChange = t => { }, this.onTouched = () => { }, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function () { const t = Object(r.C)() ? Object(r.C)().getUserAgent() : ""; return /android (\d+)/.test(t.toLowerCase()) }()) } writeValue(t) { this._renderer.setProperty(this._elementRef.nativeElement, "value", null == t ? "" : t) } registerOnChange(t) { this.onChange = t } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _handleInput(t) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(t) } _compositionStart() { this._composing = !0 } _compositionEnd(t) { this._composing = !1, this._compositionMode && this.onChange(t) } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.F), s.Rb(s.l), s.Rb(p, 8)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (t, e) { 1 & t && s.ec("input", function (t) { return e._handleInput(t.target.value) })("blur", function () { return e.onTouched() })("compositionstart", function () { return e._compositionStart() })("compositionend", function (t) { return e._compositionEnd(t.target.value) }) }, features: [s.Bb([d])] }), t })(); function g(t) { return null == t || 0 === t.length } function m(t) { return null != t && "number" == typeof t.length } const b = new s.r("NgValidators"), _ = new s.r("NgAsyncValidators"), v = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/; class y { static min(t) { return function (t) { return e => { if (g(e.value) || g(t)) return null; const n = parseFloat(e.value); return !isNaN(n) && n < t ? { min: { min: t, actual: e.value } } : null } }(t) } static max(t) { return function (t) { return e => { if (g(e.value) || g(t)) return null; const n = parseFloat(e.value); return !isNaN(n) && n > t ? { max: { max: t, actual: e.value } } : null } }(t) } static required(t) { return w(t) } static requiredTrue(t) { return function (t) { return !0 === t.value ? null : { required: !0 } }(t) } static email(t) { return function (t) { return g(t.value) || v.test(t.value) ? null : { email: !0 } }(t) } static minLength(t) { return function (t) { return e => g(e.value) || !m(e.value) ? null : e.value.length < t ? { minlength: { requiredLength: t, actualLength: e.value.length } } : null }(t) } static maxLength(t) { return function (t) { return e => m(e.value) && e.value.length > t ? { maxlength: { requiredLength: t, actualLength: e.value.length } } : null }(t) } static pattern(t) { return function (t) { if (!t) return C; let e, n; return "string" == typeof t ? (n = "", "^" !== t.charAt(0) && (n += "^"), n += t, "$" !== t.charAt(t.length - 1) && (n += "$"), e = new RegExp(n)) : (n = t.toString(), e = t), t => { if (g(t.value)) return null; const s = t.value; return e.test(s) ? null : { pattern: { requiredPattern: n, actualValue: s } } } }(t) } static nullValidator(t) { return null } static compose(t) { return k(t) } static composeAsync(t) { return A(t) } } function w(t) { return g(t.value) ? { required: !0 } : null } function C(t) { return null } function O(t) { return null != t } function S(t) { const e = Object(s.tb)(t) ? Object(i.a)(t) : t; return Object(s.sb)(e), e } function x(t) { let e = {}; return t.forEach(t => { e = null != t ? Object.assign(Object.assign({}, e), t) : e }), 0 === Object.keys(e).length ? null : e } function E(t, e) { return e.map(e => e(t)) } function T(t) { return t.map(t => function (t) { return !t.validate }(t) ? t : e => t.validate(e)) } function k(t) { if (!t) return null; const e = t.filter(O); return 0 == e.length ? null : function (t) { return x(E(t, e)) } } function j(t) { return null != t ? k(T(t)) : null } function A(t) { if (!t) return null; const e = t.filter(O); return 0 == e.length ? null : function (t) { const n = E(t, e).map(S); return Object(o.a)(n).pipe(Object(a.a)(x)) } } function R(t) { return null != t ? A(T(t)) : null } function L(t, e) { return null === t ? [e] : Array.isArray(t) ? [...t, e] : [t, e] } function I(t) { return t._rawValidators } function P(t) { return t._rawAsyncValidators } let D = (() => { class t { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(t) { this._rawValidators = t || [], this._composedValidatorFn = j(this._rawValidators) } _setAsyncValidators(t) { this._rawAsyncValidators = t || [], this._composedAsyncValidatorFn = R(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(t) { this._onDestroyCallbacks.push(t) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(t => t()), this._onDestroyCallbacks = [] } reset(t) { this.control && this.control.reset(t) } hasError(t, e) { return !!this.control && this.control.hasError(t, e) } getError(t, e) { return this.control ? this.control.getError(t, e) : null } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = s.Mb({ type: t }), t })(), M = (() => { class t extends D { get formDirective() { return null } get path() { return null } } return t.\u0275fac = function (e) { return N(e || t) }, t.\u0275dir = s.Mb({ type: t, features: [s.zb] }), t })(); const N = s.Zb(M); class F extends D { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class V { constructor(t) { this._cd = t } is(t) { var e, n; return !!(null === (n = null === (e = this._cd) || void 0 === e ? void 0 : e.control) || void 0 === n ? void 0 : n[t]) } } let B = (() => { class t extends V { constructor(t) { super(t) } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(F, 2)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (t, e) { 2 & t && s.Jb("ng-untouched", e.is("untouched"))("ng-touched", e.is("touched"))("ng-pristine", e.is("pristine"))("ng-dirty", e.is("dirty"))("ng-valid", e.is("valid"))("ng-invalid", e.is("invalid"))("ng-pending", e.is("pending")) }, features: [s.zb] }), t })(), U = (() => { class t extends V { constructor(t) { super(t) } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(M, 10)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 14, hostBindings: function (t, e) { 2 & t && s.Jb("ng-untouched", e.is("untouched"))("ng-touched", e.is("touched"))("ng-pristine", e.is("pristine"))("ng-dirty", e.is("dirty"))("ng-valid", e.is("valid"))("ng-invalid", e.is("invalid"))("ng-pending", e.is("pending")) }, features: [s.zb] }), t })(); function H(t, e) { return [...e.path, t] } function z(t, e) { q(t, e, !0), e.valueAccessor.writeValue(t.value), function (t, e) { e.valueAccessor.registerOnChange(n => { t._pendingValue = n, t._pendingChange = !0, t._pendingDirty = !0, "change" === t.updateOn && X(t, e) }) }(t, e), function (t, e) { const n = (t, n) => { e.valueAccessor.writeValue(t), n && e.viewToModelUpdate(t) }; t.registerOnChange(n), e._registerOnDestroy(() => { t._unregisterOnChange(n) }) }(t, e), function (t, e) { e.valueAccessor.registerOnTouched(() => { t._pendingTouched = !0, "blur" === t.updateOn && t._pendingChange && X(t, e), "submit" !== t.updateOn && t.markAsTouched() }) }(t, e), function (t, e) { if (e.valueAccessor.setDisabledState) { const n = t => { e.valueAccessor.setDisabledState(t) }; t.registerOnDisabledChange(n), e._registerOnDestroy(() => { t._unregisterOnDisabledChange(n) }) } }(t, e) } function $(t, e, n = !0) { const s = () => { }; e.valueAccessor && (e.valueAccessor.registerOnChange(s), e.valueAccessor.registerOnTouched(s)), G(t, e, !0), t && (e._invokeOnDestroyCallbacks(), t._registerOnCollectionChange(() => { })) } function W(t, e) { t.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(e) }) } function q(t, e, n) { const s = I(t); null !== e.validator ? t.setValidators(L(s, e.validator)) : "function" == typeof s && t.setValidators([s]); const r = P(t); if (null !== e.asyncValidator ? t.setAsyncValidators(L(r, e.asyncValidator)) : "function" == typeof r && t.setAsyncValidators([r]), n) { const n = () => t.updateValueAndValidity(); W(e._rawValidators, n), W(e._rawAsyncValidators, n) } } function G(t, e, n) { let s = !1; if (null !== t) { if (null !== e.validator) { const n = I(t); if (Array.isArray(n) && n.length > 0) { const r = n.filter(t => t !== e.validator); r.length !== n.length && (s = !0, t.setValidators(r)) } } if (null !== e.asyncValidator) { const n = P(t); if (Array.isArray(n) && n.length > 0) { const r = n.filter(t => t !== e.asyncValidator); r.length !== n.length && (s = !0, t.setAsyncValidators(r)) } } } if (n) { const t = () => { }; W(e._rawValidators, t), W(e._rawAsyncValidators, t) } return s } function X(t, e) { t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, { emitModelToViewChange: !1 }), e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1 } function K(t, e) { if (!t.hasOwnProperty("model")) return !1; const n = t.model; return !!n.isFirstChange() || !Object.is(e, n.currentValue) } function Z(t, e) { if (!e) return null; let n, s, r; return Array.isArray(e), e.forEach(t => { t.constructor === f ? n = t : Object.getPrototypeOf(t.constructor) === c ? s = t : r = t }), r || s || n || null } function Y(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } function Q(t) { return (nt(t) ? t.validators : t) || null } function J(t) { return Array.isArray(t) ? j(t) : t || null } function tt(t, e) { return (nt(e) ? e.asyncValidators : t) || null } function et(t) { return Array.isArray(t) ? R(t) : t || null } function nt(t) { return null != t && !Array.isArray(t) && "object" == typeof t } class st { constructor(t, e) { this._hasOwnPendingAsyncValidator = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = t, this._rawAsyncValidators = e, this._composedValidatorFn = J(this._rawValidators), this._composedAsyncValidatorFn = et(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn } set validator(t) { this._rawValidators = this._composedValidatorFn = t } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(t) { this._rawAsyncValidators = this._composedAsyncValidatorFn = t } get parent() { return this._parent } get valid() { return "VALID" === this.status } get invalid() { return "INVALID" === this.status } get pending() { return "PENDING" == this.status } get disabled() { return "DISABLED" === this.status } get enabled() { return "DISABLED" !== this.status } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this._rawValidators = t, this._composedValidatorFn = J(t) } setAsyncValidators(t) { this._rawAsyncValidators = t, this._composedAsyncValidatorFn = et(t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(t => { t.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(t => { t.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = "PENDING", !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = "DISABLED", this.errors = null, this._forEachChild(e => { e.disable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!0)) } enable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = "VALID", this._forEachChild(e => { e.enable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), "VALID" !== this.status && "PENDING" !== this.status || this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(e => e._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? "DISABLED" : "VALID" } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = "PENDING", this._hasOwnPendingAsyncValidator = !0; const e = S(this.asyncValidator(this)); this._asyncValidationSubscription = e.subscribe(e => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(e, { emitEvent: t }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(t, e = {}) { this.errors = t, this._updateControlsErrors(!1 !== e.emitEvent) } get(t) { return function (t, e, n) { if (null == e) return null; if (Array.isArray(e) || (e = e.split(".")), Array.isArray(e) && 0 === e.length) return null; let s = t; return e.forEach(t => { s = s instanceof it ? s.controls.hasOwnProperty(t) ? s.controls[t] : null : s instanceof ot && s.at(t) || null }), s }(this, t) } getError(t, e) { const n = e ? this.get(e) : this; return n && n.errors ? n.errors[t] : null } hasError(t, e) { return !!this.getError(t, e) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new s.n, this.statusChanges = new s.n } _calculateStatus() { return this._allControlsDisabled() ? "DISABLED" : this.errors ? "INVALID" : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus("PENDING") ? "PENDING" : this._anyControlsHaveStatus("INVALID") ? "INVALID" : "VALID" } _anyControlsHaveStatus(t) { return this._anyControls(e => e.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _isBoxedValue(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { nt(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } } class rt extends st { constructor(t = null, e, n) { super(Q(e), tt(n, e)), this._onChange = [], this._applyFormState(t), this._setUpdateStrategy(e), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!n }) } setValue(t, e = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== e.emitModelToViewChange && this._onChange.forEach(t => t(this.value, !1 !== e.emitViewToModelChange)), this.updateValueAndValidity(e) } patchValue(t, e = {}) { this.setValue(t, e) } reset(t = null, e = {}) { this._applyFormState(t), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _unregisterOnChange(t) { Y(this._onChange, t) } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _unregisterOnDisabledChange(t) { Y(this._onDisabledChange, t) } _forEachChild(t) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { this._isBoxedValue(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } } class it extends st { constructor(t, e, n) { super(Q(e), tt(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!n }) } registerControl(t, e) { return this.controls[t] ? this.controls[t] : (this.controls[t] = e, e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e) } addControl(t, e) { this.registerControl(t, e), this.updateValueAndValidity(), this._onCollectionChange() } removeControl(t) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], this.updateValueAndValidity(), this._onCollectionChange() } setControl(t, e) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], e && this.registerControl(t, e), this.updateValueAndValidity(), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, e = {}) { this._checkAllValuesPresent(t), Object.keys(t).forEach(n => { this._throwIfControlMissing(n), this.controls[n].setValue(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { null != t && (Object.keys(t).forEach(n => { this.controls[n] && this.controls[n].patchValue(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(t = {}, e = {}) { this._forEachChild((n, s) => { n.reset(t[s], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this._reduceChildren({}, (t, e, n) => (t[n] = e instanceof rt ? e.value : e.getRawValue(), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (t, e) => !!e._syncPendingControls() || t); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!Object.keys(this.controls).length) throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.controls[t]) throw new Error(`Cannot find form control with name: ${t}.`) } _forEachChild(t) { Object.keys(this.controls).forEach(e => { const n = this.controls[e]; n && t(n, e) }) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { for (const e of Object.keys(this.controls)) { const n = this.controls[e]; if (this.contains(e) && t(n)) return !0 } return !1 } _reduceValue() { return this._reduceChildren({}, (t, e, n) => ((e.enabled || this.disabled) && (t[n] = e.value), t)) } _reduceChildren(t, e) { let n = t; return this._forEachChild((t, s) => { n = e(n, t, s) }), n } _allControlsDisabled() { for (const t of Object.keys(this.controls)) if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _checkAllValuesPresent(t) { this._forEachChild((e, n) => { if (void 0 === t[n]) throw new Error(`Must supply a value for form control with name: '${n}'.`) }) } } class ot extends st { constructor(t, e, n) { super(Q(e), tt(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!n }) } at(t) { return this.controls[t] } push(t) { this.controls.push(t), this._registerControl(t), this.updateValueAndValidity(), this._onCollectionChange() } insert(t, e) { this.controls.splice(t, 0, e), this._registerControl(e), this.updateValueAndValidity() } removeAt(t) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), this.updateValueAndValidity() } setControl(t, e) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), e && (this.controls.splice(t, 0, e), this._registerControl(e)), this.updateValueAndValidity(), this._onCollectionChange() } get length() { return this.controls.length } setValue(t, e = {}) { this._checkAllValuesPresent(t), t.forEach((t, n) => { this._throwIfControlMissing(n), this.at(n).setValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { null != t && (t.forEach((t, n) => { this.at(n) && this.at(n).patchValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(t = [], e = {}) { this._forEachChild((n, s) => { n.reset(t[s], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this.controls.map(t => t instanceof rt ? t.value : t.getRawValue()) } clear() { this.controls.length < 1 || (this._forEachChild(t => t._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity()) } _syncPendingControls() { let t = this.controls.reduce((t, e) => !!e._syncPendingControls() || t, !1); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!this.controls.length) throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.at(t)) throw new Error(`Cannot find form control at index ${t}`) } _forEachChild(t) { this.controls.forEach((e, n) => { t(e, n) }) } _updateValue() { this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value) } _anyControls(t) { return this.controls.some(e => e.enabled && t(e)) } _setUpControls() { this._forEachChild(t => this._registerControl(t)) } _checkAllValuesPresent(t) { this._forEachChild((e, n) => { if (void 0 === t[n]) throw new Error(`Must supply a value for form control at index: ${n}.`) }) } _allControlsDisabled() { for (const t of this.controls) if (t.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(t) { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) } } let at = (() => { class t extends M { ngOnInit() { this._checkParentType(), this.formDirective.addFormGroup(this) } ngOnDestroy() { this.formDirective && this.formDirective.removeFormGroup(this) } get control() { return this.formDirective.getFormGroup(this) } get path() { return H(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } _checkParentType() { } } return t.\u0275fac = function (e) { return ct(e || t) }, t.\u0275dir = s.Mb({ type: t, features: [s.zb] }), t })(); const ct = s.Zb(at), lt = { provide: F, useExisting: Object(s.V)(() => ht) }, ut = (() => Promise.resolve(null))(); let ht = (() => { class t extends F { constructor(t, e, n, r) { super(), this.control = new rt, this._registered = !1, this.update = new s.n, this._parent = t, this._setValidators(e), this._setAsyncValidators(n), this.valueAccessor = Z(0, r) } ngOnChanges(t) { this._checkForErrors(), this._registered || this._setUpControl(), "isDisabled" in t && this._updateDisabled(t), K(t, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._parent ? H(this.name, this._parent) : [this.name] } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { z(this.control, this), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(t) { ut.then(() => { this.control.setValue(t, { emitViewToModelChange: !1 }) }) } _updateDisabled(t) { const e = t.isDisabled.currentValue, n = "" === e || e && "false" !== e; ut.then(() => { n && !this.control.disabled ? this.control.disable() : !n && this.control.disabled && this.control.enable() }) } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(M, 9), s.Rb(b, 10), s.Rb(_, 10), s.Rb(l, 10)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [s.Bb([lt]), s.zb, s.Ab] }), t })(), dt = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = s.Mb({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), t })(), pt = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = s.Pb({ type: t }), t.\u0275inj = s.Ob({}), t })(); const ft = new s.r("NgModelWithFormControlWarning"), gt = { provide: M, useExisting: Object(s.V)(() => mt) }; let mt = (() => { class t extends M { constructor(t, e) { super(), this.validators = t, this.asyncValidators = e, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new s.n, this._setValidators(t), this._setAsyncValidators(e) } ngOnChanges(t) { this._checkFormPresent(), t.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (G(this.form, this, !1), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(t) { const e = this.form.get(t.path); return z(e, t), e.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(t), e } getControl(t) { return this.form.get(t.path) } removeControl(t) { $(t.control || null, t, !1), Y(this.directives, t) } addFormGroup(t) { this._setUpFormContainer(t) } removeFormGroup(t) { this._cleanUpFormContainer(t) } getFormGroup(t) { return this.form.get(t.path) } addFormArray(t) { this._setUpFormContainer(t) } removeFormArray(t) { this._cleanUpFormContainer(t) } getFormArray(t) { return this.form.get(t.path) } updateModel(t, e) { this.form.get(t.path).setValue(e) } onSubmit(t) { return this.submitted = !0, e = this.directives, this.form._syncPendingControls(), e.forEach(t => { const e = t.control; "submit" === e.updateOn && e._pendingChange && (t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1) }), this.ngSubmit.emit(t), !1; var e } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _updateDomValue() { this.directives.forEach(t => { const e = t.control, n = this.form.get(t.path); e !== n && ($(e || null, t), n instanceof rt && (z(n, t), t.control = n)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer(t) { const e = this.form.get(t.path); (function (t, e) { q(t, e, !1) })(e, t), e.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer(t) { if (this.form) { const e = this.form.get(t.path); e && function (t, e) { return G(t, e, !1) }(e, t) && e.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { q(this.form, this, !1), this._oldForm && G(this._oldForm, this, !1) } _checkFormPresent() { } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(b, 10), s.Rb(_, 10)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "formGroup", ""]], hostBindings: function (t, e) { 1 & t && s.ec("submit", function (t) { return e.onSubmit(t) })("reset", function () { return e.onReset() }) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [s.Bb([gt]), s.zb, s.Ab] }), t })(); const bt = { provide: M, useExisting: Object(s.V)(() => _t) }; let _t = (() => { class t extends at { constructor(t, e, n) { super(), this._parent = t, this._setValidators(e), this._setAsyncValidators(n) } _checkParentType() { wt(this._parent) } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(M, 13), s.Rb(b, 10), s.Rb(_, 10)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "formGroupName", ""]], inputs: { name: ["formGroupName", "name"] }, features: [s.Bb([bt]), s.zb] }), t })(); const vt = { provide: M, useExisting: Object(s.V)(() => yt) }; let yt = (() => { class t extends M { constructor(t, e, n) { super(), this._parent = t, this._setValidators(e), this._setAsyncValidators(n) } ngOnInit() { this._checkParentType(), this.formDirective.addFormArray(this) } ngOnDestroy() { this.formDirective && this.formDirective.removeFormArray(this) } get control() { return this.formDirective.getFormArray(this) } get formDirective() { return this._parent ? this._parent.formDirective : null } get path() { return H(null == this.name ? this.name : this.name.toString(), this._parent) } _checkParentType() { wt(this._parent) } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(M, 13), s.Rb(b, 10), s.Rb(_, 10)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "formArrayName", ""]], inputs: { name: ["formArrayName", "name"] }, features: [s.Bb([vt]), s.zb] }), t })(); function wt(t) { return !(t instanceof _t || t instanceof mt || t instanceof yt) } const Ct = { provide: F, useExisting: Object(s.V)(() => Ot) }; let Ot = (() => { class t extends F { constructor(t, e, n, r, i) { super(), this._ngModelWarningConfig = i, this._added = !1, this.update = new s.n, this._ngModelWarningSent = !1, this._parent = t, this._setValidators(e), this._setAsyncValidators(n), this.valueAccessor = Z(0, r) } set isDisabled(t) { } ngOnChanges(t) { this._added || this._setUpControl(), K(t, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } get path() { return H(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } _checkParentType() { } _setUpControl() { this._checkParentType(), this.control = this.formDirective.addControl(this), this.control.disabled && this.valueAccessor.setDisabledState && this.valueAccessor.setDisabledState(!0), this._added = !0 } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(M, 13), s.Rb(b, 10), s.Rb(_, 10), s.Rb(l, 10), s.Rb(ft, 8)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "formControlName", ""]], inputs: { isDisabled: ["disabled", "isDisabled"], name: ["formControlName", "name"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, features: [s.Bb([Ct]), s.zb, s.Ab] }), t._ngModelWarningSentOnce = !1, t })(); const St = { provide: l, useExisting: Object(s.V)(() => Et), multi: !0 }; function xt(t, e) { return null == t ? `${e}` : (e && "object" == typeof e && (e = "Object"), `${t}: ${e}`.slice(0, 50)) } let Et = (() => { class t extends c { constructor(t, e) { super(), this._renderer = t, this._elementRef = e, this._optionMap = new Map, this._idCounter = 0, this.onChange = t => { }, this.onTouched = () => { }, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { this.value = t; const e = this._getOptionId(t); null == e && this._renderer.setProperty(this._elementRef.nativeElement, "selectedIndex", -1); const n = xt(e, t); this._renderer.setProperty(this._elementRef.nativeElement, "value", n) } registerOnChange(t) { this.onChange = e => { this.value = this._getOptionValue(e), t(this.value) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _registerOption() { return (this._idCounter++).toString() } _getOptionId(t) { for (const e of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(e), t)) return e; return null } _getOptionValue(t) { const e = function (t) { return t.split(":")[0] }(t); return this._optionMap.has(e) ? this._optionMap.get(e) : t } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.F), s.Rb(s.l)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]], hostBindings: function (t, e) { 1 & t && s.ec("change", function (t) { return e.onChange(t.target.value) })("blur", function () { return e.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [s.Bb([St]), s.zb] }), t })(), Tt = (() => { class t { constructor(t, e, n) { this._element = t, this._renderer = e, this._select = n, this._select && (this.id = this._select._registerOption()) } set ngValue(t) { null != this._select && (this._select._optionMap.set(this.id, t), this._setElementValue(xt(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._setElementValue(t), this._select && this._select.writeValue(this._select.value) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.l), s.Rb(s.F), s.Rb(Et, 9)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }), t })(); const kt = { provide: l, useExisting: Object(s.V)(() => At), multi: !0 }; function jt(t, e) { return null == t ? `${e}` : ("string" == typeof e && (e = `'${e}'`), e && "object" == typeof e && (e = "Object"), `${t}: ${e}`.slice(0, 50)) } let At = (() => { class t extends c { constructor(t, e) { super(), this._renderer = t, this._elementRef = e, this._optionMap = new Map, this._idCounter = 0, this.onChange = t => { }, this.onTouched = () => { }, this._compareWith = Object.is } set compareWith(t) { this._compareWith = t } writeValue(t) { let e; if (this.value = t, Array.isArray(t)) { const n = t.map(t => this._getOptionId(t)); e = (t, e) => { t._setSelected(n.indexOf(e.toString()) > -1) } } else e = (t, e) => { t._setSelected(!1) }; this._optionMap.forEach(e) } registerOnChange(t) { this.onChange = e => { const n = []; if (void 0 !== e.selectedOptions) { const t = e.selectedOptions; for (let e = 0; e < t.length; e++) { const s = t.item(e), r = this._getOptionValue(s.value); n.push(r) } } else { const t = e.options; for (let e = 0; e < t.length; e++) { const s = t.item(e); if (s.selected) { const t = this._getOptionValue(s.value); n.push(t) } } } this.value = n, t(n) } } registerOnTouched(t) { this.onTouched = t } setDisabledState(t) { this._renderer.setProperty(this._elementRef.nativeElement, "disabled", t) } _registerOption(t) { const e = (this._idCounter++).toString(); return this._optionMap.set(e, t), e } _getOptionId(t) { for (const e of Array.from(this._optionMap.keys())) if (this._compareWith(this._optionMap.get(e)._value, t)) return e; return null } _getOptionValue(t) { const e = function (t) { return t.split(":")[0] }(t); return this._optionMap.has(e) ? this._optionMap.get(e)._value : t } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.F), s.Rb(s.l)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]], hostBindings: function (t, e) { 1 & t && s.ec("change", function (t) { return e.onChange(t.target) })("blur", function () { return e.onTouched() }) }, inputs: { compareWith: "compareWith" }, features: [s.Bb([kt]), s.zb] }), t })(), Rt = (() => { class t { constructor(t, e, n) { this._element = t, this._renderer = e, this._select = n, this._select && (this.id = this._select._registerOption(this)) } set ngValue(t) { null != this._select && (this._value = t, this._setElementValue(jt(this.id, t)), this._select.writeValue(this._select.value)) } set value(t) { this._select ? (this._value = t, this._setElementValue(jt(this.id, t)), this._select.writeValue(this._select.value)) : this._setElementValue(t) } _setElementValue(t) { this._renderer.setProperty(this._element.nativeElement, "value", t) } _setSelected(t) { this._renderer.setProperty(this._element.nativeElement, "selected", t) } ngOnDestroy() { this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value)) } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.l), s.Rb(s.F), s.Rb(At, 9)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["option"]], inputs: { ngValue: "ngValue", value: "value" } }), t })(); const Lt = { provide: b, useExisting: Object(s.V)(() => It), multi: !0 }; let It = (() => { class t { constructor() { this._required = !1 } get required() { return this._required } set required(t) { this._required = null != t && !1 !== t && "false" != `${t}`, this._onChange && this._onChange() } validate(t) { return this.required ? w(t) : null } registerOnValidatorChange(t) { this._onChange = t } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]], hostVars: 1, hostBindings: function (t, e) { 2 & t && s.Db("required", e.required ? "" : null) }, inputs: { required: "required" }, features: [s.Bb([Lt])] }), t })(), Pt = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = s.Pb({ type: t }), t.\u0275inj = s.Ob({ imports: [[pt]] }), t })(), Dt = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = s.Pb({ type: t }), t.\u0275inj = s.Ob({ imports: [Pt] }), t })(), Mt = (() => { class t { static withConfig(e) { return { ngModule: t, providers: [{ provide: ft, useValue: e.warnOnNgModelWithFormControl }] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = s.Pb({ type: t }), t.\u0275inj = s.Ob({ imports: [Pt] }), t })(), Nt = (() => { class t { group(t, e = null) { const n = this._reduceControls(t); let s, r = null, i = null; return null != e && (function (t) { return void 0 !== t.asyncValidators || void 0 !== t.validators || void 0 !== t.updateOn }(e) ? (r = null != e.validators ? e.validators : null, i = null != e.asyncValidators ? e.asyncValidators : null, s = null != e.updateOn ? e.updateOn : void 0) : (r = null != e.validator ? e.validator : null, i = null != e.asyncValidator ? e.asyncValidator : null)), new it(n, { asyncValidators: i, updateOn: s, validators: r }) } control(t, e, n) { return new rt(t, e, n) } array(t, e, n) { const s = t.map(t => this._createControl(t)); return new ot(s, e, n) } _reduceControls(t) { const e = {}; return Object.keys(t).forEach(n => { e[n] = this._createControl(t[n]) }), e } _createControl(t) { return t instanceof rt || t instanceof it || t instanceof ot ? t : Array.isArray(t) ? this.control(t[0], t.length > 1 ? t[1] : null, t.length > 2 ? t[2] : null) : this.control(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = Object(s.Nb)({ factory: function () { return new t }, token: t, providedIn: Mt }), t })() }, "4I5i": function (t, e, n) { "use strict"; n.d(e, "a", function () { return s }); const s = (() => { function t() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } return t.prototype = Object.create(Error.prototype), t })() }, "5+tZ": function (t, e, n) { "use strict"; n.d(e, "a", function () { return o }); var s = n("lJxs"), r = n("Cfvw"), i = n("zx2A"); function o(t, e, n = Number.POSITIVE_INFINITY) { return "function" == typeof e ? i => i.pipe(o((n, i) => Object(r.a)(t(n, i)).pipe(Object(s.a)((t, s) => e(n, t, i, s))), n)) : ("number" == typeof e && (n = e), e => e.lift(new a(t, n))) } class a { constructor(t, e = Number.POSITIVE_INFINITY) { this.project = t, this.concurrent = e } call(t, e) { return e.subscribe(new c(t, this.project, this.concurrent)) } } class c extends i.b { constructor(t, e, n = Number.POSITIVE_INFINITY) { super(t), this.project = e, this.concurrent = n, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0 } _next(t) { this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t) } _tryNext(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (s) { return void this.destination.error(s) } this.active++, this._innerSub(e) } _innerSub(t) { const e = new i.a(this), n = this.destination; n.add(e); const s = Object(i.c)(t, e); s !== e && n.add(s) } _complete() { this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe() } notifyNext(t) { this.destination.next(t) } notifyComplete() { const t = this.buffer; this.active--, t.length > 0 ? this._next(t.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete() } } }, "7+OI": function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("HDdC"); function r(t) { return !!t && (t instanceof s.a || "function" == typeof t.lift && "function" == typeof t.subscribe) } }, "7o/Q": function (t, e, n) { "use strict"; n.d(e, "a", function () { return l }); var s = n("n6bG"), r = n("gRHU"), i = n("quSY"), o = n("2QA8"), a = n("2fFW"), c = n("NJ4a"); class l extends i.a { constructor(t, e, n) { switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) { case 0: this.destination = r.a; break; case 1: if (!t) { this.destination = r.a; break } if ("object" == typeof t) { t instanceof l ? (this.syncErrorThrowable = t.syncErrorThrowable, this.destination = t, t.add(this)) : (this.syncErrorThrowable = !0, this.destination = new u(this, t)); break } default: this.syncErrorThrowable = !0, this.destination = new u(this, t, e, n) } } [o.a]() { return this } static create(t, e, n) { const s = new l(t, e, n); return s.syncErrorThrowable = !1, s } next(t) { this.isStopped || this._next(t) } error(t) { this.isStopped || (this.isStopped = !0, this._error(t)) } complete() { this.isStopped || (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe()) } _next(t) { this.destination.next(t) } _error(t) { this.destination.error(t), this.unsubscribe() } _complete() { this.destination.complete(), this.unsubscribe() } _unsubscribeAndRecycle() { const { _parentOrParents: t } = this; return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = t, this } } class u extends l { constructor(t, e, n, i) { let o; super(), this._parentSubscriber = t; let a = this; Object(s.a)(e) ? o = e : e && (o = e.next, n = e.error, i = e.complete, e !== r.a && (a = Object.create(e), Object(s.a)(a.unsubscribe) && this.add(a.unsubscribe.bind(a)), a.unsubscribe = this.unsubscribe.bind(this))), this._context = a, this._next = o, this._error = n, this._complete = i } next(t) { if (!this.isStopped && this._next) { const { _parentSubscriber: e } = this; a.a.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t) } } error(t) { if (!this.isStopped) { const { _parentSubscriber: e } = this, { useDeprecatedSynchronousErrorHandling: n } = a.a; if (this._error) n && e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe()) : (this.__tryOrUnsub(this._error, t), this.unsubscribe()); else if (e.syncErrorThrowable) n ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : Object(c.a)(t), this.unsubscribe(); else { if (this.unsubscribe(), n) throw t; Object(c.a)(t) } } } complete() { if (!this.isStopped) { const { _parentSubscriber: t } = this; if (this._complete) { const e = () => this._complete.call(this._context); a.a.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? (this.__tryOrSetError(t, e), this.unsubscribe()) : (this.__tryOrUnsub(e), this.unsubscribe()) } else this.unsubscribe() } } __tryOrUnsub(t, e) { try { t.call(this._context, e) } catch (n) { if (this.unsubscribe(), a.a.useDeprecatedSynchronousErrorHandling) throw n; Object(c.a)(n) } } __tryOrSetError(t, e, n) { if (!a.a.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { e.call(this._context, n) } catch (s) { return a.a.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = s, t.syncErrorThrown = !0, !0) : (Object(c.a)(s), !0) } return !1 } _unsubscribe() { const { _parentSubscriber: t } = this; this._context = null, this._parentSubscriber = null, t.unsubscribe() } } }, "99NH": function (t, e, n) { "use strict"; n.d(e, "a", function () { return b }), n.d(e, "b", function () { return v }), n.d(e, "c", function () { return c }); var s = n("l7P3"), r = n("fXoL"), i = n("tyNb"), o = n("zp1y"); Object(s.o)("@ngrx/router-store/request", Object(s.u)()), Object(s.o)("@ngrx/router-store/navigation", Object(s.u)()), Object(s.o)("@ngrx/router-store/cancel", Object(s.u)()); const a = "@ngrx/router-store/error"; function c(t, e) { const n = e; switch (n.type) { case "@ngrx/router-store/navigation": case a: case "@ngrx/router-store/cancel": return { state: n.payload.routerState, navigationId: n.payload.event.id }; default: return t } } Object(s.o)(a, Object(s.u)()), Object(s.o)("@ngrx/router-store/navigated", Object(s.u)()); class l { } class u { serialize(t) { return { root: this.serializeRoute(t.root), url: t.url } } serializeRoute(t) { const e = t.children.map(t => this.serializeRoute(t)); return { params: t.params, paramMap: t.paramMap, data: t.data, url: t.url, outlet: t.outlet, routeConfig: t.routeConfig ? { component: t.routeConfig.component, path: t.routeConfig.path, pathMatch: t.routeConfig.pathMatch, redirectTo: t.routeConfig.redirectTo, outlet: t.routeConfig.outlet } : null, queryParams: t.queryParams, queryParamMap: t.queryParamMap, fragment: t.fragment, component: t.routeConfig ? t.routeConfig.component : void 0, root: void 0, parent: void 0, firstChild: e[0], pathFromRoot: void 0, children: e } } } class h { serialize(t) { return { root: this.serializeRoute(t.root), url: t.url } } serializeRoute(t) { const e = t.children.map(t => this.serializeRoute(t)); return { params: t.params, data: t.data, url: t.url, outlet: t.outlet, routeConfig: t.routeConfig ? { path: t.routeConfig.path, pathMatch: t.routeConfig.pathMatch, redirectTo: t.routeConfig.redirectTo, outlet: t.routeConfig.outlet } : null, queryParams: t.queryParams, fragment: t.fragment, firstChild: e[0], children: e } } } var d = function (t) { return t[t.PreActivation = 1] = "PreActivation", t[t.PostActivation = 2] = "PostActivation", t }({}); const p = new r.r("@ngrx/router-store Internal Configuration"), f = new r.r("@ngrx/router-store Configuration"); function g(t) { return Object.assign({ stateKey: "router", serializer: h, navigationActionTiming: d.PreActivation }, t) } var m = function (t) { return t[t.NONE = 1] = "NONE", t[t.ROUTER = 2] = "ROUTER", t[t.STORE = 3] = "STORE", t }({}); let b = (() => { class t { constructor(t, e, n, i, o, a) { this.store = t, this.router = e, this.serializer = n, this.errorHandler = i, this.config = o, this.activeRuntimeChecks = a, this.lastEvent = null, this.routerState = null, this.trigger = m.NONE, this.stateKey = this.config.stateKey, !Object(s.s)() && Object(r.X)() && ((null == a ? void 0 : a.strictActionSerializability) || (null == a ? void 0 : a.strictStateSerializability)) && this.serializer instanceof u && console.warn("@ngrx/router-store: The serializability runtime checks cannot be enabled with the DefaultRouterStateSerializer. The default serializer has an unserializable router state and actions that are not serializable. To use the serializability runtime checks either use the MinimalRouterStateSerializer or implement a custom router state serializer. This also applies to Ivy with immutability runtime checks."), this.setUpStoreStateListener(), this.setUpRouterEventsListener() } static forRoot(e = {}) { return { ngModule: t, providers: [{ provide: p, useValue: e }, { provide: f, useFactory: g, deps: [p] }, { provide: l, useClass: e.serializer ? e.serializer : 0 === e.routerState ? u : h }] } } setUpStoreStateListener() { this.store.pipe(Object(s.v)(this.stateKey), Object(o.a)(this.store)).subscribe(([t, e]) => { this.navigateIfNeeded(t, e) }) } navigateIfNeeded(t, e) { if (!t || !t.state) return; if (this.trigger === m.ROUTER) return; if (this.lastEvent instanceof i.g) return; const n = t.state.url; var s; s = n, _(this.router.url) !== _(s) && (this.storeState = e, this.trigger = m.STORE, this.router.navigateByUrl(n).catch(t => { this.errorHandler.handleError(t) })) } setUpRouterEventsListener() { const t = this.config.navigationActionTiming === d.PostActivation; let e; this.router.events.pipe(Object(o.a)(this.store)).subscribe(([n, s]) => { this.lastEvent = n, n instanceof i.g ? (this.routerState = this.serializer.serialize(this.router.routerState.snapshot), this.trigger !== m.STORE && (this.storeState = s, this.dispatchRouterRequest(n))) : n instanceof i.n ? (e = n, t || this.trigger === m.STORE || this.dispatchRouterNavigation(n)) : n instanceof i.d ? (this.dispatchRouterCancel(n), this.reset()) : n instanceof i.f ? (this.dispatchRouterError(n), this.reset()) : n instanceof i.e && (this.trigger !== m.STORE && (t && this.dispatchRouterNavigation(e), this.dispatchRouterNavigated(n)), this.reset()) }) } dispatchRouterRequest(t) { this.dispatchRouterAction("@ngrx/router-store/request", { event: t }) } dispatchRouterNavigation(t) { const e = this.serializer.serialize(t.state); this.dispatchRouterAction("@ngrx/router-store/navigation", { routerState: e, event: new i.n(t.id, t.url, t.urlAfterRedirects, e) }) } dispatchRouterCancel(t) { this.dispatchRouterAction("@ngrx/router-store/cancel", { storeState: this.storeState, event: t }) } dispatchRouterError(t) { this.dispatchRouterAction(a, { storeState: this.storeState, event: new i.f(t.id, t.url, `${t}`) }) } dispatchRouterNavigated(t) { const e = this.serializer.serialize(this.router.routerState.snapshot); this.dispatchRouterAction("@ngrx/router-store/navigated", { event: t, routerState: e }) } dispatchRouterAction(t, e) { this.trigger = m.ROUTER; try { this.store.dispatch({ type: t, payload: Object.assign(Object.assign({ routerState: this.routerState }, e), { event: 0 === this.config.routerState ? e.event : { id: e.event.id, url: e.event.url, urlAfterRedirects: e.event.urlAfterRedirects } }) }) } finally { this.trigger = m.NONE } } reset() { this.trigger = m.NONE, this.storeState = null, this.routerState = null } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(s.i), r.bc(i.i), r.bc(l), r.bc(r.m), r.bc(f), r.bc(s.a)) }, t.\u0275mod = r.Pb({ type: t }), t.\u0275inj = r.Ob({}), t })(); function _(t) { return t.length > 0 && "/" === t[t.length - 1] ? t.substring(0, t.length - 1) : t } function v(t) { const e = Object(s.r)(t, t => t && t.state), n = Object(s.r)(e, t => t && t.root), r = Object(s.r)(n, t => { if (!t) return; let e = t; for (; e.firstChild;)e = e.firstChild; return e }), i = Object(s.r)(n, t => t && t.fragment), o = Object(s.r)(n, t => t && t.queryParams), a = Object(s.r)(r, t => t && t.params), c = Object(s.r)(r, t => t && t.data), l = Object(s.r)(e, t => t && t.url); return { selectCurrentRoute: r, selectFragment: i, selectQueryParams: o, selectQueryParam: t => Object(s.r)(o, e => e && e[t]), selectRouteParams: a, selectRouteParam: t => Object(s.r)(a, e => e && e[t]), selectRouteData: c, selectUrl: l } } }, "9jGm": function (t, e, n) { "use strict"; n.d(e, "a", function () { return B }), n.d(e, "b", function () { return et }), n.d(e, "c", function () { return nt }), n.d(e, "d", function () { return P }), n.d(e, "e", function () { return U }); var s = n("l7P3"), r = n("VRyK"), i = n("HDdC"), o = n("XNiG"), a = (n("NXyV"), n("WMd4")), c = (n("mCNh"), n("LRne"), n("7o/Q")); class l { call(t, e) { return e.subscribe(new u(t)) } } class u extends c.a { _next(t) { } } class h { call(t, e) { return e.subscribe(new d(t)) } } class d extends c.a { constructor(t) { super(t) } _next(t) { this.destination.next(a.a.createNext(t)) } _error(t) { const e = this.destination; e.next(a.a.createError(t)), e.complete() } _complete() { const t = this.destination; t.next(a.a.createComplete()), t.complete() } } var p = n("lJxs"), f = n("JIr8"), g = n("pLZG"), m = n("quSY"); function b(t, e, n, s) { return r => r.lift(new _(t, e, n, s)) } class _ { constructor(t, e, n, s) { this.keySelector = t, this.elementSelector = e, this.durationSelector = n, this.subjectSelector = s } call(t, e) { return e.subscribe(new v(t, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector)) } } class v extends c.a { constructor(t, e, n, s, r) { super(t), this.keySelector = e, this.elementSelector = n, this.durationSelector = s, this.subjectSelector = r, this.groups = null, this.attemptedToUnsubscribe = !1, this.count = 0 } _next(t) { let e; try { e = this.keySelector(t) } catch (n) { return void this.error(n) } this._group(t, e) } _group(t, e) { let n = this.groups; n || (n = this.groups = new Map); let s, r = n.get(e); if (this.elementSelector) try { s = this.elementSelector(t) } catch (i) { this.error(i) } else s = t; if (!r) { r = this.subjectSelector ? this.subjectSelector() : new o.a, n.set(e, r); const t = new w(e, r, this); if (this.destination.next(t), this.durationSelector) { let t; try { t = this.durationSelector(new w(e, r)) } catch (i) { return void this.error(i) } this.add(t.subscribe(new y(e, r, this))) } } r.closed || r.next(s) } _error(t) { const e = this.groups; e && (e.forEach((e, n) => { e.error(t) }), e.clear()), this.destination.error(t) } _complete() { const t = this.groups; t && (t.forEach((t, e) => { t.complete() }), t.clear()), this.destination.complete() } removeGroup(t) { this.groups.delete(t) } unsubscribe() { this.closed || (this.attemptedToUnsubscribe = !0, 0 === this.count && super.unsubscribe()) } } class y extends c.a { constructor(t, e, n) { super(e), this.key = t, this.group = e, this.parent = n } _next(t) { this.complete() } _unsubscribe() { const { parent: t, key: e } = this; this.key = this.parent = null, t && t.removeGroup(e) } } class w extends i.a { constructor(t, e, n) { super(), this.key = t, this.groupSubject = e, this.refCountSubscription = n } _subscribe(t) { const e = new m.a, { refCountSubscription: n, groupSubject: s } = this; return n && !n.closed && e.add(new C(n)), e.add(s.subscribe(t)), e } } class C extends m.a { constructor(t) { super(), this.parent = t, t.count++ } unsubscribe() { const t = this.parent; t.closed || this.closed || (super.unsubscribe(), t.count -= 1, 0 === t.count && t.attemptedToUnsubscribe && t.unsubscribe()) } } var O = n("5+tZ"), S = n("Cfvw"), x = n("zx2A"); function E(t, e) { return e ? n => n.pipe(E((n, s) => Object(S.a)(t(n, s)).pipe(Object(p.a)((t, r) => e(n, t, s, r))))) : e => e.lift(new T(t)) } class T { constructor(t) { this.project = t } call(t, e) { return e.subscribe(new k(t, this.project)) } } class k extends x.b { constructor(t, e) { super(t), this.project = e, this.hasSubscription = !1, this.hasCompleted = !1, this.index = 0 } _next(t) { this.hasSubscription || this.tryNext(t) } tryNext(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (s) { return void this.destination.error(s) } this.hasSubscription = !0, this._innerSub(e) } _innerSub(t) { const e = new x.a(this), n = this.destination; n.add(e); const s = Object(x.c)(t, e); s !== e && n.add(s) } _complete() { this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe() } notifyNext(t) { this.destination.next(t) } notifyError(t) { this.destination.error(t) } notifyComplete() { this.hasSubscription = !1, this.hasCompleted && this.destination.complete() } } class j { call(t, e) { return e.subscribe(new A(t)) } } class A extends c.a { constructor(t) { super(t) } _next(t) { t.observe(this.destination) } } var R = n("IzEk"), L = (n("bOdf"), n("nYR2"), n("zp1y"), n("fXoL")); const I = { dispatch: !0, useEffectsErrorHandler: !0 }; function P(t, e) { const n = t(), s = Object.assign(Object.assign({}, I), e); return Object.defineProperty(n, "__@ngrx/effects_create__", { value: s }), n } function D(t) { return Object.getOwnPropertyNames(t).filter(e => !(!t[e] || !t[e].hasOwnProperty("__@ngrx/effects_create__")) && t[e]["__@ngrx/effects_create__"].hasOwnProperty("dispatch")).map(e => Object.assign({ propertyName: e }, t[e]["__@ngrx/effects_create__"])) } function M(t) { return Object.getPrototypeOf(t) } function N(t) { return Object(s.n)(F, M)(t) } function F(t) { return function (t) { return t.constructor.hasOwnProperty("__@ngrx/effects__") }(t) ? t.constructor["__@ngrx/effects__"] : [] } function V(t, e, n = 10) { return t.pipe(Object(f.a)(s => (e && e.handleError(s), n <= 1 ? t : V(t, e, n - 1)))) } let B = (() => { class t extends i.a { constructor(t) { super(), t && (this.source = t) } lift(e) { const n = new t; return n.source = this, n.operator = e, n } } return t.\u0275fac = function (e) { return new (e || t)(L.bc(s.g)) }, t.\u0275prov = L.Nb({ token: t, factory: t.\u0275fac }), t })(); function U(...t) { return Object(g.a)(e => t.some(t => "string" == typeof t ? t === e.type : t.type === e.type)) } function H(t) { return z(t, "ngrxOnInitEffects") } function z(t, e) { return t && e in t && "function" == typeof t[e] } const $ = new L.r("@ngrx/effects Internal Root Guard"), W = new L.r("@ngrx/effects User Provided Effects"), q = new L.r("@ngrx/effects Internal Root Effects"), G = new L.r("@ngrx/effects Root Effects"), X = new L.r("@ngrx/effects Internal Feature Effects"), K = new L.r("@ngrx/effects Feature Effects"), Z = new L.r("@ngrx/effects Effects Error Handler"); let Y = (() => { class t extends o.a { constructor(t, e) { super(), this.errorHandler = t, this.effectsErrorHandler = e } addEffects(t) { this.next(t) } toActions() { return this.pipe(b(M), Object(O.a)(t => t.pipe(b(Q))), Object(O.a)(t => { const e = t.pipe(E(t => { return (e = this.errorHandler, n = this.effectsErrorHandler, t => { const s = function (t, e, n) { const s = M(t).constructor.name, i = function (t) { return [N, D].reduce((e, n) => e.concat(n(t)), []) }(t).map(({ propertyName: r, dispatch: i, useEffectsErrorHandler: o }) => { const a = "function" == typeof t[r] ? t[r]() : t[r], c = o ? n(a, e) : a; return !1 === i ? c.pipe(function (t) { return t.lift(new l) }) : c.pipe(function (t) { return t.lift(new h) }).pipe(Object(p.a)(e => ({ effect: t[r], notification: e, propertyName: r, sourceName: s, sourceInstance: t }))) }); return Object(r.a)(...i) }(t, e, n); return function (t) { return z(t, "ngrxOnRunEffects") }(t) ? t.ngrxOnRunEffects(s) : s })(t); var e, n }), Object(p.a)(t => (function (t, e) { if ("N" === t.notification.kind) { const n = t.notification.value; !function (t) { return "function" != typeof t && t && t.type && "string" == typeof t.type }(n) && e.handleError(new Error(`Effect ${function ({ propertyName: t, sourceInstance: e, sourceName: n }) { const s = "function" == typeof e[t]; return `"${n}.${String(t)}${s ? "()" : ""}"` }(t)} dispatched an invalid action: ${function (t) { try { return JSON.stringify(t) } catch (e) { return t } }(n)}`)) } }(t, this.errorHandler), t.notification)), Object(g.a)(t => "N" === t.kind && null != t.value), function (t) { return t.lift(new j) }), n = t.pipe(Object(R.a)(1), Object(g.a)(H), Object(p.a)(t => t.ngrxOnInitEffects())); return Object(r.a)(e, n) })) } } return t.\u0275fac = function (e) { return new (e || t)(L.bc(L.m), L.bc(Z)) }, t.\u0275prov = L.Nb({ token: t, factory: t.\u0275fac }), t })(); function Q(t) { return function (t) { return z(t, "ngrxOnIdentifyEffects") }(t) ? t.ngrxOnIdentifyEffects() : "" } let J = (() => { class t { constructor(t, e) { this.effectSources = t, this.store = e, this.effectsSubscription = null } start() { this.effectsSubscription || (this.effectsSubscription = this.effectSources.toActions().subscribe(this.store)) } ngOnDestroy() { this.effectsSubscription && (this.effectsSubscription.unsubscribe(), this.effectsSubscription = null) } } return t.\u0275fac = function (e) { return new (e || t)(L.bc(Y), L.bc(s.i)) }, t.\u0275prov = L.Nb({ token: t, factory: t.\u0275fac }), t })(); Object(s.o)("@ngrx/effects/init"); let tt = (() => { class t { constructor(t, e, n, s, r, i, o) { this.sources = t, e.start(), s.forEach(e => t.addEffects(e)), n.dispatch({ type: "@ngrx/effects/init" }) } addEffects(t) { this.sources.addEffects(t) } } return t.\u0275fac = function (e) { return new (e || t)(L.bc(Y), L.bc(J), L.bc(s.i), L.bc(G), L.bc(s.l, 8), L.bc(s.j, 8), L.bc($, 8)) }, t.\u0275mod = L.Pb({ type: t }), t.\u0275inj = L.Ob({}), t })(), et = (() => { class t { constructor(t, e, n, s) { e.forEach(e => e.forEach(e => t.addEffects(e))) } } return t.\u0275fac = function (e) { return new (e || t)(L.bc(tt), L.bc(K), L.bc(s.l, 8), L.bc(s.j, 8)) }, t.\u0275mod = L.Pb({ type: t }), t.\u0275inj = L.Ob({}), t })(), nt = (() => { class t { static forFeature(t = []) { return { ngModule: et, providers: [t, { provide: X, multi: !0, useValue: t }, { provide: W, multi: !0, useValue: [] }, { provide: K, multi: !0, useFactory: st, deps: [L.s, X, W] }] } } static forRoot(t = []) { return { ngModule: tt, providers: [{ provide: Z, useValue: V }, J, Y, B, t, { provide: q, useValue: [t] }, { provide: $, useFactory: rt, deps: [[J, new L.B, new L.L], [q, new L.K]] }, { provide: W, multi: !0, useValue: [] }, { provide: G, useFactory: st, deps: [L.s, q, W] }] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = L.Pb({ type: t }), t.\u0275inj = L.Ob({}), t })(); function st(t, e, n) { const s = []; for (let r of e) s.push(...r); for (let r of n) s.push(...r); return function (t, e) { return e.map(e => t.get(e)) }(t, s) } function rt(t, e) { if ((1 !== e.length || 0 !== e[0].length) && t) throw new TypeError("EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead."); return "guarded" } }, "9ppp": function (t, e, n) { "use strict"; n.d(e, "a", function () { return s }); const s = (() => { function t() { return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this } return t.prototype = Object.create(Error.prototype), t })() }, Cfvw: function (t, e, n) { "use strict"; n.d(e, "a", function () { return h }); var s = n("HDdC"), r = n("SeVD"), i = n("quSY"), o = n("kJWO"), a = n("jZKg"), c = n("Lhse"), l = n("c2HN"), u = n("I55L"); function h(t, e) { return e ? function (t, e) { if (null != t) { if (function (t) { return t && "function" == typeof t[o.a] }(t)) return function (t, e) { return new s.a(n => { const s = new i.a; return s.add(e.schedule(() => { const r = t[o.a](); s.add(r.subscribe({ next(t) { s.add(e.schedule(() => n.next(t))) }, error(t) { s.add(e.schedule(() => n.error(t))) }, complete() { s.add(e.schedule(() => n.complete())) } })) })), s }) }(t, e); if (Object(l.a)(t)) return function (t, e) { return new s.a(n => { const s = new i.a; return s.add(e.schedule(() => t.then(t => { s.add(e.schedule(() => { n.next(t), s.add(e.schedule(() => n.complete())) })) }, t => { s.add(e.schedule(() => n.error(t))) }))), s }) }(t, e); if (Object(u.a)(t)) return Object(a.a)(t, e); if (function (t) { return t && "function" == typeof t[c.a] }(t) || "string" == typeof t) return function (t, e) { if (!t) throw new Error("Iterable cannot be null"); return new s.a(n => { const s = new i.a; let r; return s.add(() => { r && "function" == typeof r.return && r.return() }), s.add(e.schedule(() => { r = t[c.a](), s.add(e.schedule(function () { if (n.closed) return; let t, e; try { const n = r.next(); t = n.value, e = n.done } catch (s) { return void n.error(s) } e ? n.complete() : (n.next(t), this.schedule()) })) })), s }) }(t, e) } throw new TypeError((null !== t && typeof t || t) + " is not observable") }(t, e) : t instanceof s.a ? t : new s.a(Object(r.a)(t)) } }, D0XW: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("3N8a"); const r = new (n("IjjT").a)(s.a) }, DH7j: function (t, e, n) { "use strict"; n.d(e, "a", function () { return s }); const s = (() => Array.isArray || (t => t && "number" == typeof t.length))() }, EQ5u: function (t, e, n) { "use strict"; n.d(e, "a", function () { return a }), n.d(e, "b", function () { return c }); var s = n("XNiG"), r = n("HDdC"), i = (n("7o/Q"), n("quSY")), o = n("x+ZX"); class a extends r.a { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._refCount = 0, this._isComplete = !1 } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return t && !t.isStopped || (this._subject = this.subjectFactory()), this._subject } connect() { let t = this._connection; return t || (this._isComplete = !1, t = this._connection = new i.a, t.add(this.source.subscribe(new l(this.getSubject(), this))), t.closed && (this._connection = null, t = i.a.EMPTY)), t } refCount() { return Object(o.a)()(this) } } const c = (() => { const t = a.prototype; return { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: t._subscribe }, _isComplete: { value: t._isComplete, writable: !0 }, getSubject: { value: t.getSubject }, connect: { value: t.connect }, refCount: { value: t.refCount } } })(); class l extends s.b { constructor(t, e) { super(t), this.connectable = e } _error(t) { this._unsubscribe(), super._error(t) } _complete() { this.connectable._isComplete = !0, this._unsubscribe(), super._complete() } _unsubscribe() { const t = this.connectable; if (t) { this.connectable = null; const e = t._connection; t._refCount = 0, t._subject = null, t._connection = null, e && e.unsubscribe() } } } }, EY2u: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }), n.d(e, "b", function () { return i }); var s = n("HDdC"); const r = new s.a(t => t.complete()); function i(t) { return t ? function (t) { return new s.a(e => t.schedule(() => e.complete())) }(t) : r } }, GyhO: function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }); var s = n("LRne"), r = n("bHdf"); function i(...t) { return Object(r.a)(1)(Object(s.a)(...t)) } }, HDdC: function (t, e, n) { "use strict"; n.d(e, "a", function () { return l }); var s = n("7o/Q"), r = n("2QA8"), i = n("gRHU"), o = n("kJWO"), a = n("mCNh"), c = n("2fFW"); let l = (() => { class t { constructor(t) { this._isScalar = !1, t && (this._subscribe = t) } lift(e) { const n = new t; return n.source = this, n.operator = e, n } subscribe(t, e, n) { const { operator: o } = this, a = function (t, e, n) { if (t) { if (t instanceof s.a) return t; if (t[r.a]) return t[r.a]() } return t || e || n ? new s.a(t, e, n) : new s.a(i.a) }(t, e, n); if (a.add(o ? o.call(a, this.source) : this.source || c.a.useDeprecatedSynchronousErrorHandling && !a.syncErrorThrowable ? this._subscribe(a) : this._trySubscribe(a)), c.a.useDeprecatedSynchronousErrorHandling && a.syncErrorThrowable && (a.syncErrorThrowable = !1, a.syncErrorThrown)) throw a.syncErrorValue; return a } _trySubscribe(t) { try { return this._subscribe(t) } catch (e) { c.a.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = e), function (t) { for (; t;) { const { closed: e, destination: n, isStopped: r } = t; if (e || r) return !1; t = n && n instanceof s.a ? n : null } return !0 }(t) ? t.error(e) : console.warn(e) } } forEach(t, e) { return new (e = u(e))((e, n) => { let s; s = this.subscribe(e => { try { t(e) } catch (r) { n(r), s && s.unsubscribe() } }, n, e) }) } _subscribe(t) { const { source: e } = this; return e && e.subscribe(t) } [o.a]() { return this } pipe(...t) { return 0 === t.length ? this : Object(a.b)(t)(this) } toPromise(t) { return new (t = u(t))((t, e) => { let n; this.subscribe(t => n = t, t => e(t), () => t(n)) }) } } return t.create = e => new t(e), t })(); function u(t) { if (t || (t = c.a.Promise || Promise), !t) throw new Error("no Promise impl found"); return t } }, HWId: function (t, e, n) { "use strict"; n.d(e, "a", function () { return K }), n.d(e, "b", function () { return ht }), n.d(e, "c", function () { return vt }), n.d(e, "d", function () { return k }), n.d(e, "e", function () { return D }), n.d(e, "f", function () { return I }), n.d(e, "g", function () { return L }), n.d(e, "h", function () { return M }), n.d(e, "i", function () { return j }), n.d(e, "j", function () { return ut }), n.d(e, "k", function () { return Y }), n.d(e, "l", function () { return tt }), n.d(e, "m", function () { return at }), n.d(e, "n", function () { return ot }), n.d(e, "o", function () { return it }), n.d(e, "p", function () { return nt }), n.d(e, "q", function () { return st }), n.d(e, "r", function () { return rt }), n.d(e, "s", function () { return Q }), n.d(e, "t", function () { return lt }), n.d(e, "u", function () { return J }); var s = n("fXoL"), r = n("l7P3"), i = n("lJxs"), o = n("pLZG"), a = n("JIr8"), c = n("vkgz"), l = n("eIep"), u = n("/uUt"), h = n("5+tZ"), d = n("IzEk"), p = (n("3E0/"), n("Q35M")), f = n("gnMq"), g = n("tk/3"), m = n("tyNb"), b = n("HDdC"), _ = n("KqfI"); const v = new b.a(_.a); var y = n("z6cu"), w = n("LRne"), C = n("VRyK"), O = n("EY2u"), S = (n("7+OI"), n("itXk")), x = n("mrSG"), E = n("9jGm"), T = n("sYmb"), k = function (t) { return t.INITIAL = "INITIAL", t.LOADING = "LOADING", t.SUCCESS = "SUCCESS", t.FAILURE = "FAILURE", t.UNAUTHORIZED = "UNAUTHORIZED", t }({}), j = function (t) { return t[t.Immediate = 0] = "Immediate", t[t.SuccessOnly = 1] = "SuccessOnly", t[t.SuccessOrFailure = 2] = "SuccessOrFailure", t }({}); const A = new s.r("app.core-store.config"), R = "[Core] Load Current User", L = "[Core] Load Current User Success", I = "[Core] Load Current User Failure", P = "[Core] Load Configuration", D = "[Core] Load Configuration Failure"; class M { constructor(t, e) { this.title = t, this.message = e } } class N { constructor() { this.type = R } } class F { constructor(t) { this.payload = t, this.type = L } } class V { constructor(t) { this.statusCode = t, this.type = "[Core] Load Current User Unauthorized" } } class B extends M { constructor(t, e) { super("error loading user", t), this.message = t, this.statusCode = e, this.type = I } } class U { constructor(t) { this.payload = t, this.type = "[Core] Redirect to Log In" } } class H { constructor(t) { this.payload = t, this.type = "[Core] Initial Configuration" } } class z { constructor() { this.type = P } } class $ { constructor(t) { this.payload = t, this.type = "[Core] Load Configuration Success" } } class W extends M { constructor(t) { super("error loading configuration", t), this.message = t, this.type = D } } class q { constructor(t) { this.payload = t, this.type = "[Core] Network Status Change" } } class G { constructor(t) { this.payload = t, this.type = "[Core] Update Locale" } } class X { constructor(t) { this.payload = t, this.type = "[Core] Translations" } } class K { constructor(t) { this.languageSymbol = t, this.type = "[Core] Language Selected" } } class Z { constructor(t) { this.language = t, this.type = "[Core] Language Changed" } } const Y = Object(r.p)("core"), Q = (Object(r.r)(Y, t => t.processing), Object(r.r)(Y, t => t.user.value)), J = Object(r.r)(Y, t => t.user.loadStatus), tt = (Object(r.r)(Y, t => t.configuration.value), Object(r.r)(Y, t => { var e; return (null === (e = t.configuration.value) || void 0 === e ? void 0 : e.homeUrl) || "#" })), et = Object(r.r)(Y, t => t.configuration.loadStatus), nt = Object(r.r)(Y, t => t.toast), st = Object(r.r)(Y, t => t.toastSequence), rt = Object(r.r)(Y, t => t.translationMap), it = Object(r.r)(Y, t => t.networkStatus), ot = Object(r.r)(Y, t => t.locale), at = Object(r.r)(Y, t => t.language), ct = (Object(r.r)(ot, (t, e) => new f.l(t, e)), Object(r.r)(Q, t => ut(t, p.c.email)), Object(r.r)(Q, t => t.roles || [])), lt = Object(r.r)(ct, (t, e) => null != e && null != e.name && t.indexOf(e.name) > -1); function ut(t, e) { if (null == t || null == t.claims || 0 === t.claims.length) return null; const n = t.claims.find(t => t.type === e); return null != (null == n ? void 0 : n.value) ? n.value : null } let ht = (() => { class t { constructor(t) { this.store = t } canActivate(t, e) { return !!t.data.allowAnonymous || this.store.pipe(Object(r.v)(J), Object(i.a)(n => n === k.INITIAL ? (this.store.dispatch(new N), !1) : n !== k.LOADING && (n === k.SUCCESS || (this.loginUser(t, e), !1))), Object(o.a)(t => t)) } canActivateChild(t, e) { return this.canActivate(t, e) } loginUser(t, e) { this.store.dispatch(new U) } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(r.i)) }, t.\u0275prov = Object(s.Nb)({ factory: function () { return new t(Object(s.bc)(r.i)) }, token: t, providedIn: "root" }), t })(), dt = (() => { class t { constructor(t, e) { this.store = t, this.route = e } intercept(t, e) { return e.handle(t).pipe(Object(a.a)((t, e) => { if (t instanceof g.e && 401 === t.status && this.shouldRedirect(this.route.snapshot)) { const e = t.headers.get("Location") || void 0; return this.store.dispatch(new U({ loginUri: e })), v } return Object(y.a)(t) })) } shouldRedirect(t) { return null != t.firstChild ? this.shouldRedirect(t.firstChild) : null != t.routeConfig && !t.data.allowAnonymous } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(r.i), s.bc(m.a)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(), pt = (() => { class t { constructor(t, e, n, s, r, d, p, f, g, m) { this.actions$ = t, this.http = e, this.router = n, this.activatedRoute = s, this.culture = r, this.languageService = d, this.window = p, this.login = f, this.config = g, this.translate = m, this.updateQueryParams$ = Object(E.d)(() => this.actions$.pipe(Object(o.a)(t => t.updateQueryParams), Object(c.a)(t => { if (null == t.params || t.params.length < 1) return; const e = t.params.reduce((t, e) => { const [n, s] = e; return t[n] !== s && (t[n] = s), t }, Object.assign({}, this.activatedRoute.snapshot.queryParams)); this.router.navigate([], { queryParams: e }) })), { dispatch: !1 }), this.navigateToUrl$ = Object(E.d)(() => this.actions$.pipe(Object(o.a)(t => null != t.navigationRequest), Object(c.a)(t => Object(x.a)(this, void 0, void 0, function* () { try { yield this.router.navigate(t.navigationRequest.commands, t.navigationRequest.navigationExtras) } catch (e) { console.error(e) } }))), { dispatch: !1 }), this.loadUser$ = Object(E.d)(() => this.actions$.pipe(Object(E.e)(R), Object(l.a)(() => this.http.get("whoami").pipe(Object(i.a)(t => new F(t)), Object(a.a)(t => 401 === t.status || 403 === t.status ? Object(w.a)(new V(t.status)) : Object(w.a)(new B(t.message, t.status))))))), this.loadConfig$ = Object(E.d)(() => this.actions$.pipe(Object(E.e)(P), Object(l.a)(() => this.http.get("configuration").pipe(Object(c.a)(t => { for (const e of Object.keys(t)) this.config[e] = t[e] }), Object(i.a)(t => new $(t)), Object(a.a)(t => Object(w.a)(new W(t.message))))))), this.loginUser$ = Object(E.d)(() => this.actions$.pipe(Object(E.e)("[Core] Redirect to Log In"), Object(c.a)(t => { var e, n; this.window.navigate(this.login.makeLoginAndReturnUri(null === (e = t.payload) || void 0 === e ? void 0 : e.loginUri, null === (n = t.payload) || void 0 === n ? void 0 : n.loginHint)) })), { dispatch: !1 }), this.onLanguageSelected$ = Object(E.d)(() => this.actions$.pipe(Object(E.e)("[Core] Language Selected"), Object(c.a)(t => { this.languageService.setLanguage(t.languageSymbol, !0) })), { dispatch: !1 }), this.onLanguageChanged$ = Object(E.d)(() => Object(C.a)(null == this.translate ? O.a : this.translate.onLangChange, null == this.translate ? O.a : this.translate.onDefaultLangChange).pipe(Object(i.a)(t => [t.lang, t.translations]), Object(u.a)((t, e) => t[0] === e[0]), Object(h.a)(([t, e]) => { const n = this.languageService.getLanguageData(t); return null == n ? (console.warn("onLanguageSelected$: no data exists for language [${lang}]"), [new X({ language: t, translations: e })]) : [new Z(n), new X({ language: t, translations: e })] }))), this.updateLocale$ = Object(E.d)(() => this.culture.locale$.pipe(Object(i.a)(t => new G(t)))), this.networkStatusChanged$ = Object(E.d)(() => new b.a(t => { this.window.listenNetworkStatus(e => t.next(new q(e))) })) } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(E.a), s.bc(g.c), s.bc(m.i), s.bc(m.a), s.bc(f.k), s.bc(f.u), s.bc(p.g), s.bc(p.d), s.bc(p.b), s.bc(T.d, 8)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); const ft = { processing: !1, user: { loadStatus: k.INITIAL }, configuration: { loadStatus: k.INITIAL }, toastSequence: -1, translationMap: {}, locale: "en-US", language: { symbol: "en" } }; function gt(t = ft, e) { switch (e.type) { case R: return Object.assign(Object.assign({}, t), { user: Object.assign(Object.assign({}, t.user), { loadStatus: k.LOADING }) }); case L: return Object.assign(Object.assign({}, t), { user: { value: e.payload, loadStatus: k.SUCCESS } }); case "[Core] Load Current User Unauthorized": return Object.assign(Object.assign({}, t), { user: Object.assign(Object.assign({}, t.user), { loadStatus: k.UNAUTHORIZED }) }); case I: return Object.assign(Object.assign({}, t), { user: Object.assign(Object.assign({}, t.user), { loadStatus: k.FAILURE }) }); case "[Core] Initial Configuration": return Object.assign(Object.assign({}, t), { configuration: Object.assign(Object.assign({}, t.configuration), { value: e.payload }) }); case P: return Object.assign(Object.assign({}, t), { configuration: Object.assign(Object.assign({}, t.configuration), { loadStatus: k.LOADING }) }); case "[Core] Load Configuration Success": return Object.assign(Object.assign({}, t), { configuration: { value: Object.assign(Object.assign({}, t.configuration.value), e.payload), loadStatus: k.SUCCESS } }); case D: return Object.assign(Object.assign({}, t), { configuration: Object.assign(Object.assign({}, t.configuration), { loadStatus: k.FAILURE }) }); case "[Core] Network Status Change": return Object.assign(Object.assign({}, t), { networkStatus: e.payload }); case "[Core] Update Locale": return Object.assign(Object.assign({}, t), { locale: e.payload }); case "[Core] Toast": return Object.assign(Object.assign({}, t), { toast: e.payload, toastSequence: t.toastSequence + 1 }); case "[Core] Translations": if (Array.isArray(e.payload)) { const n = e.payload.translations; return Object.assign(Object.assign({}, t), { translationMap: Object.assign(Object.assign({}, "en" === e.payload.language ? p.a : t.translationMap), n.reduce((t, e) => (t[e.value] = e.translation, t), {})) }) } return Object.assign(Object.assign({}, t), { translationMap: Object.assign(Object.assign({}, "en" === e.payload.language ? p.a : t.translationMap), e.payload.translations) }); case "[Core] Language Changed": return Object.assign(Object.assign({}, t), { language: e.language }); default: if (e instanceof class { }) return Object.assign(Object.assign({}, t), { processing: !0 }); if (e instanceof class { constructor(t, e) { this.title = t, this.message = e } }) { const n = e, s = Object.assign(Object.assign({}, t), { processing: !1 }); return null != n.title || null != n.message ? Object.assign(Object.assign({}, s), { toast: { type: "success", title: n.title, body: n.message }, toastSequence: t.toastSequence + 1 }) : s } if (e instanceof M) { const n = e, s = Object.assign(Object.assign({}, t), { processing: !1 }); return null != n.title || null != n.message ? Object.assign(Object.assign({}, s), { toast: { type: "error", title: n.title || "error", body: n.message || "an error has occurred" }, toastSequence: t.toastSequence + 1 }) : s } return t } } let mt = (() => { class t { constructor(t, e) { this.toaster = t, this.translationService = e } intercept(t, e) { return e.handle(t).pipe(Object(a.a)((t, e) => t instanceof g.e && 429 === t.status && "Rate limit enforced." === t.error ? Object(S.a)([this.translationService.get("Common_HdgActionNotAvailable"), this.translationService.get("Common_TxtTryAgain")]).pipe(Object(l.a)(([e, n]) => (this.toaster.pop("error", e, n), Object(y.a)(t)))) : Object(y.a)(t))) } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(f.O), s.bc(f.W)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); function bt(t) { return () => t.init() } let _t = (() => { class t { constructor(t, e, n) { this.config = t, this.storeConfig = e, this.store = n } init() { return this.store.dispatch(new H(Object.assign({}, this.config))), null != this.storeConfig.requestUser && this.store.dispatch(new N), null != this.storeConfig.requestConfiguration && this.store.dispatch(new z), Object(S.a)([this.store.pipe(Object(r.v)(J)), this.store.pipe(Object(r.v)(et))]).pipe(Object(o.a)(([t, e]) => this.storeConfig.requestUser !== j.SuccessOnly && this.storeConfig.requestUser !== j.SuccessOrFailure || e !== k.SUCCESS || t !== k.UNAUTHORIZED ? (null == this.storeConfig.requestUser || this.storeConfig.requestUser === j.Immediate || t === k.SUCCESS || t === k.FAILURE && this.storeConfig.requestUser === j.SuccessOrFailure) && (null == this.storeConfig.requestConfiguration || this.storeConfig.requestConfiguration === j.Immediate || e === k.SUCCESS || e === k.FAILURE && this.storeConfig.requestConfiguration === j.SuccessOrFailure) : (this.store.dispatch(new U), !1)), Object(i.a)(() => !0), Object(d.a)(1)).toPromise() } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(p.b), s.bc(A), s.bc(r.i, 8)) }, t.\u0275prov = Object(s.Nb)({ factory: function () { return new t(Object(s.bc)(p.b), Object(s.bc)(A), Object(s.bc)(r.i, 8)) }, token: t, providedIn: "root" }), t })(), vt = (() => { class t { static forRoot(e) { return { ngModule: t, providers: [ht, { provide: A, useValue: e || {} }, { provide: s.d, useFactory: bt, deps: [_t], multi: !0 }, { provide: g.a, useClass: dt, multi: !0 }, { provide: g.a, useClass: mt, multi: !0 }, { provide: m.q, useClass: m.c }] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = s.Pb({ type: t }), t.\u0275inj = s.Ob({ imports: [[r.k.forFeature("core", gt), E.c.forFeature([pt])]] }), t })() }, I55L: function (t, e, n) { "use strict"; n.d(e, "a", function () { return s }); const s = t => t && "number" == typeof t.length && "function" != typeof t }, IjjT: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); let s = (() => { class t { constructor(e, n = t.now) { this.SchedulerAction = e, this.now = n } schedule(t, e = 0, n) { return new this.SchedulerAction(this, t).schedule(n, e) } } return t.now = () => Date.now(), t })(); class r extends s { constructor(t, e = s.now) { super(t, () => r.delegate && r.delegate !== this ? r.delegate.now() : e()), this.actions = [], this.active = !1, this.scheduled = void 0 } schedule(t, e = 0, n) { return r.delegate && r.delegate !== this ? r.delegate.schedule(t, e, n) : super.schedule(t, e, n) } flush(t) { const { actions: e } = this; if (this.active) return void e.push(t); let n; this.active = !0; do { if (n = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this.active = !1, n) { for (; t = e.shift();)t.unsubscribe(); throw n } } } }, IzEk: function (t, e, n) { "use strict"; n.d(e, "a", function () { return o }); var s = n("7o/Q"), r = n("4I5i"), i = n("EY2u"); function o(t) { return e => 0 === t ? Object(i.b)() : e.lift(new a(t)) } class a { constructor(t) { if (this.total = t, this.total < 0) throw new r.a } call(t, e) { return e.subscribe(new c(t, this.total)) } } class c extends s.a { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { const e = this.total, n = ++this.count; n <= e && (this.destination.next(t), n === e && (this.destination.complete(), this.unsubscribe())) } } }, JIr8: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("zx2A"); function r(t) { return function (e) { const n = new i(t), s = e.lift(n); return n.caught = s } } class i { constructor(t) { this.selector = t } call(t, e) { return e.subscribe(new o(t, this.selector, this.caught)) } } class o extends s.b { constructor(t, e, n) { super(t), this.selector = e, this.caught = n } error(t) { if (!this.isStopped) { let n; try { n = this.selector(t, this.caught) } catch (e) { return void super.error(e) } this._unsubscribeAndRecycle(); const r = new s.a(this); this.add(r); const i = Object(s.c)(n, r); i !== r && this.add(i) } } } }, JX91: function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }); var s = n("GyhO"), r = n("z+Ro"); function i(...t) { const e = t[t.length - 1]; return Object(r.a)(e) ? (t.pop(), n => Object(s.a)(t, n, e)) : e => Object(s.a)(t, e) } }, Kj3r: function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }); var s = n("7o/Q"), r = n("D0XW"); function i(t, e = r.a) { return n => n.lift(new o(t, e)) } class o { constructor(t, e) { this.dueTime = t, this.scheduler = e } call(t, e) { return e.subscribe(new a(t, this.dueTime, this.scheduler)) } } class a extends s.a { constructor(t, e, n) { super(t), this.dueTime = e, this.scheduler = n, this.debouncedSubscription = null, this.lastValue = null, this.hasValue = !1 } _next(t) { this.clearDebounce(), this.lastValue = t, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(c, this.dueTime, this)) } _complete() { this.debouncedNext(), this.destination.complete() } debouncedNext() { if (this.clearDebounce(), this.hasValue) { const { lastValue: t } = this; this.lastValue = null, this.hasValue = !1, this.destination.next(t) } } clearDebounce() { const t = this.debouncedSubscription; null !== t && (this.remove(t), t.unsubscribe(), this.debouncedSubscription = null) } } function c(t) { t.debouncedNext() } }, Kqap: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("7o/Q"); function r(t, e) { let n = !1; return arguments.length >= 2 && (n = !0), function (s) { return s.lift(new i(t, e, n)) } } class i { constructor(t, e, n = !1) { this.accumulator = t, this.seed = e, this.hasSeed = n } call(t, e) { return e.subscribe(new o(t, this.accumulator, this.seed, this.hasSeed)) } } class o extends s.a { constructor(t, e, n, s) { super(t), this.accumulator = e, this._seed = n, this.hasSeed = s, this.index = 0 } get seed() { return this._seed } set seed(t) { this.hasSeed = !0, this._seed = t } _next(t) { if (this.hasSeed) return this._tryNext(t); this.seed = t, this.destination.next(t) } _tryNext(t) { const e = this.index++; let n; try { n = this.accumulator(this.seed, t, e) } catch (s) { this.destination.error(s) } this.seed = n, this.destination.next(n) } } }, KqfI: function (t, e, n) { "use strict"; function s() { } n.d(e, "a", function () { return s }) }, LRne: function (t, e, n) { "use strict"; n.d(e, "a", function () { return o }); var s = n("z+Ro"), r = n("yCtX"), i = n("jZKg"); function o(...t) { let e = t[t.length - 1]; return Object(s.a)(e) ? (t.pop(), Object(i.a)(t, e)) : Object(r.a)(t) } }, Lhse: function (t, e, n) { "use strict"; function s() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" } n.d(e, "a", function () { return r }); const r = s() }, NJ4a: function (t, e, n) { "use strict"; function s(t) { setTimeout(() => { throw t }, 0) } n.d(e, "a", function () { return s }) }, NXyV: function (t, e, n) { "use strict"; n.d(e, "a", function () { return o }); var s = n("HDdC"), r = n("Cfvw"), i = n("EY2u"); function o(t) { return new s.a(e => { let n; try { n = t() } catch (s) { return void e.error(s) } return (n ? Object(r.a)(n) : Object(i.b)()).subscribe(e) }) } }, Q35M: function (t, e, n) { "use strict"; n.d(e, "a", function () { return a }), n.d(e, "b", function () { return l }), n.d(e, "c", function () { return c }), n.d(e, "d", function () { return g }), n.d(e, "e", function () { return h }), n.d(e, "f", function () { return d }), n.d(e, "g", function () { return f }), n.d(e, "h", function () { return u }); var s = n("fXoL"), r = n("ofXK"), i = n("tyNb"), o = n("gnMq"); const a = { Common_LblIfApplicable: "(If applicable)", Common_LblOptional: "(Optional)", Common_TxtXofY: "{{1}} of {{2}}", Common_TxtLabelColonValue: "{{1}}: {{2}}", Ptrn_TextBox_CharCounter: "{{1}}&nbsp;/&nbsp;{{2}}", Common_TxtValueParenthesis: "({{1}})", Common_HdgActionNotAvailable: "Action Not Available", Ptrn_Filter_ActiveFiltersColon: "Active Filters:", Ptrn_Filter_ActiveFiltersColonNumberListed: "Active Filters: {{1}}", Common_BtnAdd: "Add", Ptrn_Address_HdgAddAddress: "Add Address", Common_MsgAddedSuccess: "Added Successfully", Ptrn_Address_LblAddress: "Address", Ptrn_Address_TxtAddressStandardizedByThirdParty: "Address will be standardized by a third-party service.", Common_LblAge: "Age", Common_MsgAgeColon: "Age: {{1}}", Common_LblAmount: "Amount", Ptrn_Filter_BtnApply: "Apply", Ptrn_Address_HdgAsEntered: "As Entered", Common_BtnBack: "Back", Common_LblBaptismDateYears: "Baptism Date (Years)", Common_LblBaptismDate: "Baptism Date", Common_LblBirthDateAge: "Birth Date (Age)", Common_LblBirthDate: "Birth Date", Common_BtnCancel: "Cancel", Common_HdgCheckWarnings: "Check the Warnings Shown Below Before Continuing", Ptrn_Filter_BtnClear: "Clear", Ptrn_Filter_BtnClearAll: "Clear All", Common_BtnClose: "Close", Common_BtnCollapse: "Collapse", Common_BtnCollapseAll: "Collapse All", Common_LblComments: "Comments", Common_LblConfirm: "Confirm", Common_HdgConfirmDeletion: "Confirm Deletion", Common_LblCongregation: "Congregation", Common_TxtCongregationServiceCommittee: "Congregation Service Committee", Common_TxtContactUs: "Contact Us", Common_BtnContinue: "Continue", Common_MsgCopiedToClipboard: "Copied to clipboard.", Common_BtnCopy: "Copy", Common_TxtCopyToClipboard: "Copy to Clipboard", Ptrn_Address_LblCountry: "Country", Ptrn_Phone_LblCountryCode: "Country Code", Common_LblDate: "Date", Common_MsgDateCannotBeFuture: "Date cannot be in the future.", Common_MsgDateCannotBePast: "Date cannot be in the past.", Common_LblDates: "Dates", Common_BtnDelete: "Delete", Common_MsgDeletedSuccess: "Deleted Successfully", Common_BtnDiscardDraft: "Discard Draft", Common_HdgDeleteThis: "Do you want to delete this?", Common_HgdDone: "Done", Ptrn_File_BtnDownload: "Download", Ptrn_File_TxtDragFileHere: "Drag File Here", Ptrn_File_TxtDragFilesHere: "Drag Files Here", Common_LblEmailAddress: "E-mail Address", Common_BtnEdit: "Edit", Common_TxtElder: "Elder", Common_LblEndDate: "End Date", Common_TxtEnrollment: "Enrollment", Common_HdgEnter: "Enter", Ptrn_Address_TxtEnterCompleteAddress: "Enter the complete address.", Common_MsgWholeNumbersOnly: "Enter whole numbers only. Punctuation and spaces are not allowed.", Common_MsgEntryOnlyContainNumbers: "Entry can only contain numbers.", Common_MsgEntryCannotBeNegative: "Entry cannot be a negative value.", Common_MsgEntryCannotBeLessInt: "Entry cannot be less than {{1}}.", Common_MsgEntryCannotBeMoreInt: "Entry cannot be more than {{1}}.", Common_MsgEntryCannotContainNumbers: "Entry cannot contain numbers.", Common_MsgEntryContainsTooManyCharacters: "Entry contains too many characters.", Ptrn_ImgAltTxtError: "Error", Common_MsgEstimatedDowntime: "Estimated Downtime: {{1}}", Common_BtnExpand: "Expand", Common_BtnExpandAll: "Expand All", Common_OptFemale: "Female", Common_MsgRequired: "Field is required.", Ptrn_File_FileUploadFailed: "File could not be uploaded.", Ptrn_File_FileTypesAccepted: "File could not be uploaded. Acceptable file types are: {{1}}", Ptrn_File_FileCannotExceedSize: "File could not be uploaded. File size cannot exceed {{1}}.", Ptrn_Filter_HdgFilters: "Filters", Ptrn_Filter_BtnFilters: "Filters&nbsp;\u2026", Common_LblFirstName: "First Name", Common_HdgFixErrors: "Fix the Errors Shown Below", Ptrn_Phone_TxtFormatColon: "Format:", Common_LblGender: "Gender", Common_HdgGoTo: "Go To", Common_HdgHelp: "Help", Common_LnkHelp: "Help", Common_HdgHelpTopic: "Help Topic", Common_HdgHelpTopics: "Help Topics", Common_LnkHome: "Home", Ptrn_ImgAltTxtInformation: "Information", Common_MsgInvalidFormat: "Invalid format.", Common_HdgJehovahsWitnesses: "Jehovah\u2019s Witnesses", Common_LblLanguage: "Language", Common_LblLastName: "Last Name", Common_BtnLoadXMore: "Load {{1}} More", Common_LblLocation_Geographic: "Location", Common_LnkLogOut: "Log Out", Common_OptMale: "Male", Common_LblMiddleName: "Middle Name", Ptrn_File_TxtHeightMinimumPixels: "Minimum Height: {{1}}px", Ptrn_File_TxtWidthMinimumPixels: "Minimum Width: {{1}}px", Common_TxtMinisterialServant: "Ministerial Servant", Common_HdgMoreOptions: "More Options", Ptrn_Typeahead_TxtMoreResults: "More results exist. Type more text to narrow your search results.", Common_LblName: "Name", Common_BtnNext: "Next", Common_OptNo: "No", Ptrn_Filter_TxtNoActiveFilters: "No active filters.", Common_MsgNoItemsFound: "No items found.", Common_MsgNoResults: "No results found.", Common_TxtNone: "None", Common_TxtNotAvailable: "Not available", Common_TxtNotEntered: "Not entered", Common_MsgOneHour: "One Hour", Common_MsgOneOrMoreDays: "One or More Days", Ptrn_File_TxtOr: "or", Common_HdgOverview: "Overview", Common_LnkOverview: "Overview", Common_HdgPageNotFound: "Page Not Found", Common_LblPhoneNumber: "Phone Number", Common_BtnPleaseWait: "Please wait\u2026", Common_BtnPrevious: "Previous", Common_BtnPrint: "Print", Common_TxtPrivacyPolicy: "Privacy Policy", Common_TxtPublisher: "Publisher", Ptrn_Address_HdgRecommendedStandardizedAddress: "Recommended Standardized Address", Common_TxtRegularPioneer: "Regular Pioneer", Ptrn_ImgAltTxtReminder: "Reminder", Common_BtnRemove: "Remove", Common_MsgRequired_Short: "Required", Common_HdgResultsNumber: "Results: {{1}}", Common_BtnRetry: "Retry", Common_BtnSave: "Save", Common_BtnSaveAndNext: "Save and Next", Common_MsgSavedSuccess: "Saved Successfully", Common_BtnSearch: "Search", Ptrn_File_BtnSelectFile: "Select a File", Ptrn_Language_HdgSelectLanguage: "Select a Language", Common_MsgSelectAtLeastOneOption: "Select at least one option.", Ptrn_File_BtnSelectFiles: "Select Files", Common_MsgSeveralHours: "Several Hours", Ptrn_Filter_LnkShowLess: "Show Less", Ptrn_Filter_LnkShowMore: "Show More", Ptrn_File_LblSizeColon: "Size: {{1}} maximum", Common_MsgSomethingWentWrong: "Something went wrong. Please try again later.", Common_TxtSpecialFullTimeServant: "Special Full-Time Servant", Common_TxtSpiritualStatus: "Spiritual Status", Common_BtnStart: "Start", Common_LblStartDate: "Start Date", Common_BtnStartOver: "Start Over", Common_BtnSubmit: "Submit", Ptrn_ImgAltTxtSuccess: "Success", Ptrn_File_HdgTechnicalRequirements: "Technical Requirements", Common_TxtTermsOfUse: "Terms of Use", Common_MsgFeatureTemporarilyUnavailable: "This feature is temporarily unavailable. Please try again later.", Common_LblTime: "Time", Common_MsgTooManyCharacters: "Too many characters.", Common_TxtTryAgain: "Try again in a few minutes.", Common_TxtTypeNamePlaceholder: "Type a name", Common_TxtTypeNameOrNumberPlaceholder: "Type a name or number", Ptrn_Language_TxtLanguagePlaceholder: "Type or select a language", Ptrn_Typeahead_TxtTypeaheadInstructions: "Type search text above to find results.", Ptrn_File_LblTypesColon: "Types: {{1}}", Common_BtnUndo: "Undo", Common_MsgUnknown: "Unknown", Common_LblUpdatedBy: "Updated By", Common_LblUpdatedOn: "Updated On", Common_MsgUpdatedSuccess: "Updated Successfully", Ptrn_File_HdgUploadedSuccessfully: "Uploaded Successfully", Ptrn_Address_HdgVerifyAddress: "Verify Address", Common_BtnView: "View", Common_LblViewBy: "View By", Ptrn_ImgAltTxtWarning: "Warning", Ptrn_Address_TxtWeTriedToStandardizeAddress: "We tried to standardize the address. Select the version of the address you want to use.", Ptrn_Address_TxtAddressStandardizationFailed: "We were not able to standardize the address. Please verify that what you entered is correct before saving.", Common_MsgYearsColon: "Years: {{1}}", Common_OptYes: "Yes", Common_TxtPageNotFound: "You may have mistyped the address, or the page may have been deleted." }; var c = function (t) { return t.accountSuspended = "suspended", t.authenticationMethodReferences = "http://schemas.microsoft.com/claims/authnmethodsreferences", t.congregationGuid = "congregation-guid", t.congregationName = "congregation-name", t.branchOfRecord = "branch-of-record", t.displayName = "displayname", t.email = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn", t.fullTypePrefix = "http://schemas.jw.org/claims/", t.group = "http://schemas.xmlsoap.org/claims/Group", t.isBranchOwned = "is-branch-owned", t.personGuid = "person-guid", t.personBranchCode = "person-branch-code", t.personBranchGuid = "person-branch-guid", t.spiritualStatus = "spiritual-status", t.transformationStatus = "transformation-status", t }({}); const l = new s.r("app.core.config"), u = { requestedWithHeader: "cdh-application", loginHintStorageKey: "storedUsername" }; var h = function (t) { return t.online = "online", t.offline = "offline", t }({}), d = function (t) { return t.succeeded = "Succeeded", t.failed = "Failed", t.partial = "Partial", t }({}); function p() { return null != window ? window : (console.warn("[Core/Common]: window not available in this context"), { addEventListener: (t, e) => { console.warn("[Core/Common]: window.addEventListener not available in this context") }, location: {}, scrollTo: (t, e) => { console.warn("[Core/Common]: window.scrollTo not available in this context") }, localStorage: {}, navigator: { online: !0 } }) } let f = (() => { class t { navigate(t, e = !1) { const n = p(); null != n && null != n.location && (e ? n.location.replace(t) : n.location.assign(t)) } scrollToTop() { p().scrollTo(0, 0) } getLocation() { return p().location } removeStorageValue(t, e = "localStorage") { const n = p(); return !!this.storageAvailable(n, e) && (n[e].removeItem(t), !0) } setStorageValue(t, e, n = "localStorage") { const s = p(); return !!this.storageAvailable(s, n) && (s[n].setItem(t, e), !0) } getStorageValue(t, e = "localStorage") { const n = p(); return this.storageAvailable(n, e) ? n[e].getItem(t) : null } listenNetworkStatus(t) { const e = p(); e.addEventListener("online", () => this.notifyNetworkStatus(t)), e.addEventListener("offline", () => this.notifyNetworkStatus(t)), this.notifyNetworkStatus(t) } notifyNetworkStatus(t) { const e = p(); "function" == typeof t && t(e.navigator.onLine ? h.online : h.offline) } storageAvailable(t, e = "localStorage") { if (null == t) return !1; const n = t[e], s = "__storage_test__"; try { return n.setItem(s, s), n.removeItem(s), !0 } catch (r) { return r instanceof DOMException && (22 === r.code || 1014 === r.code || "QuotaExceededError" === r.name || "NS_ERROR_DOM_QUOTA_REACHED" === r.name) && 0 !== n.length } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = Object(s.Nb)({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(), g = (() => { class t { constructor(t, e, n, s, r, i) { this.config = t, this.window = e, this.browserStorage = n, this.languageService = s, this.locationStrategy = r, this.urlSerializer = i } makeLoginAndReturnUri(t, e) { const n = []; if (null == (t = t || this.config.loginUri) || "" === t) throw new Error("loginUri is empty"); const s = this.postLoginUrl(); null != s && n.push(`postLoginUri=${encodeURIComponent(s)}`); const r = null != e ? e : this.loginHint(); null != r && (n.push("prompt=none"), n.push(`login_hint=${encodeURIComponent(r)}`)); let i = n.join("&"); return i = t.indexOf("?") > -1 ? "&" + i : "?" + i, t + i } postLoginUrl() { var t; if (null != this.config.postLoginUrl) return this.config.postLoginUrl; const e = this.window.getLocation(); if (this.config.isDevMode) return e.href; const n = this.locationStrategy.path(!0).substring(this.locationStrategy.getBaseHref().length), s = this.urlSerializer.parse(n); if (!this.config.preserveLanguageInPostLoginUri && s.root.hasChildren()) { const e = null === (t = s.root.children[i.h]) || void 0 === t ? void 0 : t.segments; if ((null == e ? void 0 : e.length) > 0) { const t = e[0].path.toLowerCase(); null != this.languageService.getLanguageMap()[t] && e.splice(0, 1) } } return this.urlSerializer.serialize(s) } loginHint() { var t; const e = this.window.getLocation(), n = this.urlSerializer.parse(e.pathname + e.search); if (null != n && null != n.queryParams && null != n.queryParams.login_hint) return n.queryParams.login_hint; const s = null !== (t = this.config.loginHintStorageKey) && void 0 !== t ? t : null == u ? void 0 : u.loginHintStorageKey; if (null == s) return null; const r = this.browserStorage.getStorageValue(s, "localStorage"); return null != r ? r : null } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(l), s.bc(f), s.bc(o.g), s.bc(o.u), s.bc(r.k), s.bc(i.q)) }, t.\u0275prov = Object(s.Nb)({ factory: function () { return new t(Object(s.bc)(l), Object(s.bc)(f), Object(s.bc)(o.g), Object(s.bc)(o.u), Object(s.bc)(r.k), Object(s.bc)(i.q)) }, token: t, providedIn: "root" }), t })() }, R0Ic: function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }), n.d(e, "b", function () { return s }), n.d(e, "c", function () { return r }), n.d(e, "d", function () { return p }), n.d(e, "e", function () { return a }), n.d(e, "f", function () { return c }), n.d(e, "g", function () { return u }), n.d(e, "h", function () { return l }), n.d(e, "i", function () { return h }), n.d(e, "j", function () { return o }), n.d(e, "k", function () { return f }), n.d(e, "l", function () { return g }); class s { } class r { } const i = "*"; function o(t, e) { return { type: 7, name: t, definitions: e, options: {} } } function a(t, e = null) { return { type: 4, styles: e, timings: t } } function c(t, e = null) { return { type: 2, steps: t, options: e } } function l(t) { return { type: 6, styles: t, offset: null } } function u(t, e, n) { return { type: 0, name: t, styles: e, options: n } } function h(t, e, n = null) { return { type: 1, expr: t, animation: e, options: n } } function d(t) { Promise.resolve(null).then(t) } class p { constructor(t = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = t + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { d(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { } setPosition(t) { this._position = this.totalTime ? t * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class f { constructor(t) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t; let e = 0, n = 0, s = 0; const r = this.players.length; 0 == r ? d(() => this._onFinish()) : this.players.forEach(t => { t.onDone(() => { ++e == r && this._onFinish() }), t.onDestroy(() => { ++n == r && this._onDestroy() }), t.onStart(() => { ++s == r && this._onStart() }) }), this.totalTime = this.players.reduce((t, e) => Math.max(t, e.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this.players.forEach(t => t.init()) } onStart(t) { this._onStartFns.push(t) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = []) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play()) } pause() { this.players.forEach(t => t.pause()) } restart() { this.players.forEach(t => t.restart()) } finish() { this._onFinish(), this.players.forEach(t => t.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(t) { const e = t * this.totalTime; this.players.forEach(t => { const n = t.totalTime ? Math.min(1, e / t.totalTime) : 1; t.setPosition(n) }) } getPosition() { const t = this.players.reduce((t, e) => null === t || e.totalTime > t.totalTime ? e : t, null); return null != t ? t.getPosition() : 0 } beforeDestroy() { this.players.forEach(t => { t.beforeDestroy && t.beforeDestroy() }) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } const g = "!" }, R1ws: function (t, e, n) { "use strict"; n.d(e, "a", function () { return be }); var s = n("fXoL"), r = n("jhN1"), i = n("R0Ic"); function o() { return "undefined" != typeof process && "[object process]" === {}.toString.call(process) } function a(t) { switch (t.length) { case 0: return new i.d; case 1: return t[0]; default: return new i.k(t) } } function c(t, e, n, s, r = {}, o = {}) { const a = [], c = []; let l = -1, u = null; if (s.forEach(t => { const n = t.offset, s = n == l, h = s && u || {}; Object.keys(t).forEach(n => { let s = n, c = t[n]; if ("offset" !== n) switch (s = e.normalizePropertyName(s, a), c) { case i.l: c = r[n]; break; case i.a: c = o[n]; break; default: c = e.normalizeStyleValue(n, s, c, a) }h[s] = c }), s || c.push(h), u = h, l = n }), a.length) { const t = "\n - "; throw new Error(`Unable to animate due to the following errors:${t}${a.join(t)}`) } return c } function l(t, e, n, s) { switch (e) { case "start": t.onStart(() => s(n && u(n, "start", t))); break; case "done": t.onDone(() => s(n && u(n, "done", t))); break; case "destroy": t.onDestroy(() => s(n && u(n, "destroy", t))) } } function u(t, e, n) { const s = n.totalTime, r = h(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, null == s ? t.totalTime : s, !!n.disabled), i = t._data; return null != i && (r._data = i), r } function h(t, e, n, s, r = "", i = 0, o) { return { element: t, triggerName: e, fromState: n, toState: s, phaseName: r, totalTime: i, disabled: !!o } } function d(t, e, n) { let s; return t instanceof Map ? (s = t.get(e), s || t.set(e, s = n)) : (s = t[e], s || (s = t[e] = n)), s } function p(t) { const e = t.indexOf(":"); return [t.substring(1, e), t.substr(e + 1)] } let f = (t, e) => !1, g = (t, e) => !1, m = (t, e, n) => []; const b = o(); (b || "undefined" != typeof Element) && (f = (t, e) => t.contains(e), g = (() => { if (b || Element.prototype.matches) return (t, e) => t.matches(e); { const t = Element.prototype, e = t.matchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector || t.webkitMatchesSelector; return e ? (t, n) => e.apply(t, [n]) : g } })(), m = (t, e, n) => { let s = []; if (n) { const n = t.querySelectorAll(e); for (let t = 0; t < n.length; t++)s.push(n[t]) } else { const n = t.querySelector(e); n && s.push(n) } return s }); let _ = null, v = !1; function y(t) { _ || (_ = ("undefined" != typeof document ? document.body : null) || {}, v = !!_.style && "WebkitAppearance" in _.style); let e = !0; return _.style && !function (t) { return "ebkit" == t.substring(1, 6) }(t) && (e = t in _.style, !e && v) && (e = "Webkit" + t.charAt(0).toUpperCase() + t.substr(1) in _.style), e } const w = g, C = f, O = m; function S(t) { const e = {}; return Object.keys(t).forEach(n => { const s = n.replace(/([a-z])([A-Z])/g, "$1-$2"); e[s] = t[n] }), e } let x = (() => { class t { validateStyleProperty(t) { return y(t) } matchesElement(t, e) { return w(t, e) } containsElement(t, e) { return C(t, e) } query(t, e, n) { return O(t, e, n) } computeStyle(t, e, n) { return n || "" } animate(t, e, n, s, r, o = [], a) { return new i.d(n, s) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(), E = (() => { class t { } return t.NOOP = new x, t })(); function T(t) { if ("number" == typeof t) return t; const e = t.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : k(parseFloat(e[1]), e[2]) } function k(t, e) { switch (e) { case "s": return 1e3 * t; default: return t } } function j(t, e, n) { return t.hasOwnProperty("duration") ? t : function (t, e, n) { let s, r = 0, i = ""; if ("string" == typeof t) { const n = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === n) return e.push(`The provided timing value "${t}" is invalid.`), { duration: 0, delay: 0, easing: "" }; s = k(parseFloat(n[1]), n[2]); const o = n[3]; null != o && (r = k(parseFloat(o), n[4])); const a = n[5]; a && (i = a) } else s = t; if (!n) { let n = !1, i = e.length; s < 0 && (e.push("Duration values below 0 are not allowed for this animation step."), n = !0), r < 0 && (e.push("Delay values below 0 are not allowed for this animation step."), n = !0), n && e.splice(i, 0, `The provided timing value "${t}" is invalid.`) } return { duration: s, delay: r, easing: i } }(t, e, n) } function A(t, e = {}) { return Object.keys(t).forEach(n => { e[n] = t[n] }), e } function R(t, e, n = {}) { if (e) for (let s in t) n[s] = t[s]; else A(t, n); return n } function L(t, e, n) { return n ? e + ":" + n + ";" : "" } function I(t) { let e = ""; for (let n = 0; n < t.style.length; n++) { const s = t.style.item(n); e += L(0, s, t.style.getPropertyValue(s)) } for (const n in t.style) t.style.hasOwnProperty(n) && !n.startsWith("_") && (e += L(0, n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), t.style[n])); t.setAttribute("style", e) } function P(t, e, n) { t.style && (Object.keys(e).forEach(s => { const r = H(s); n && !n.hasOwnProperty(s) && (n[s] = t.style[r]), t.style[r] = e[s] }), o() && I(t)) } function D(t, e) { t.style && (Object.keys(e).forEach(e => { const n = H(e); t.style[n] = "" }), o() && I(t)) } function M(t) { return Array.isArray(t) ? 1 == t.length ? t[0] : Object(i.f)(t) : t } const N = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function F(t) { let e = []; if ("string" == typeof t) { let n; for (; n = N.exec(t);)e.push(n[1]); N.lastIndex = 0 } return e } function V(t, e, n) { const s = t.toString(), r = s.replace(N, (t, s) => { let r = e[s]; return e.hasOwnProperty(s) || (n.push(`Please provide a value for the animation param ${s}`), r = ""), r.toString() }); return r == s ? t : r } function B(t) { const e = []; let n = t.next(); for (; !n.done;)e.push(n.value), n = t.next(); return e } const U = /-+([a-z0-9])/g; function H(t) { return t.replace(U, (...t) => t[1].toUpperCase()) } function z(t, e) { return 0 === t || 0 === e } function $(t, e, n) { const s = Object.keys(n); if (s.length && e.length) { let i = e[0], o = []; if (s.forEach(t => { i.hasOwnProperty(t) || o.push(t), i[t] = n[t] }), o.length) for (var r = 1; r < e.length; r++) { let n = e[r]; o.forEach(function (e) { n[e] = q(t, e) }) } } return e } function W(t, e, n) { switch (e.type) { case 7: return t.visitTrigger(e, n); case 0: return t.visitState(e, n); case 1: return t.visitTransition(e, n); case 2: return t.visitSequence(e, n); case 3: return t.visitGroup(e, n); case 4: return t.visitAnimate(e, n); case 5: return t.visitKeyframes(e, n); case 6: return t.visitStyle(e, n); case 8: return t.visitReference(e, n); case 9: return t.visitAnimateChild(e, n); case 10: return t.visitAnimateRef(e, n); case 11: return t.visitQuery(e, n); case 12: return t.visitStagger(e, n); default: throw new Error(`Unable to resolve animation metadata node #${e.type}`) } } function q(t, e) { return window.getComputedStyle(t)[e] } function G(t, e) { const n = []; return "string" == typeof t ? t.split(/\s*,\s*/).forEach(t => function (t, e, n) { if (":" == t[0]) { const s = function (t, e) { switch (t) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (t, e) => parseFloat(e) > parseFloat(t); case ":decrement": return (t, e) => parseFloat(e) < parseFloat(t); default: return e.push(`The transition alias value "${t}" is not supported`), "* => *" } }(t, n); if ("function" == typeof s) return void e.push(s); t = s } const s = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == s || s.length < 4) return n.push(`The provided transition expression "${t}" is not supported`), e; const r = s[1], i = s[2], o = s[3]; e.push(Z(r, o)), "<" != i[0] || "*" == r && "*" == o || e.push(Z(o, r)) }(t, n, e)) : n.push(t), n } const X = new Set(["true", "1"]), K = new Set(["false", "0"]); function Z(t, e) { const n = X.has(t) || K.has(t), s = X.has(e) || K.has(e); return (r, i) => { let o = "*" == t || t == r, a = "*" == e || e == i; return !o && n && "boolean" == typeof r && (o = r ? X.has(t) : K.has(t)), !a && s && "boolean" == typeof i && (a = i ? X.has(e) : K.has(e)), o && a } } const Y = new RegExp("s*:selfs*,?", "g"); function Q(t, e, n) { return new J(t).build(e, n) } class J { constructor(t) { this._driver = t } build(t, e) { const n = new tt(e); return this._resetContextStyleTimingState(n), W(this, M(t), n) } _resetContextStyleTimingState(t) { t.currentQuerySelector = "", t.collectedStyles = {}, t.collectedStyles[""] = {}, t.currentTime = 0 } visitTrigger(t, e) { let n = e.queryCount = 0, s = e.depCount = 0; const r = [], i = []; return "@" == t.name.charAt(0) && e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), t.definitions.forEach(t => { if (this._resetContextStyleTimingState(e), 0 == t.type) { const n = t, s = n.name; s.toString().split(/\s*,\s*/).forEach(t => { n.name = t, r.push(this.visitState(n, e)) }), n.name = s } else if (1 == t.type) { const r = this.visitTransition(t, e); n += r.queryCount, s += r.depCount, i.push(r) } else e.errors.push("only state() and transition() definitions can sit inside of a trigger()") }), { type: 7, name: t.name, states: r, transitions: i, queryCount: n, depCount: s, options: null } } visitState(t, e) { const n = this.visitStyle(t.styles, e), s = t.options && t.options.params || null; if (n.containsDynamicStyles) { const r = new Set, i = s || {}; if (n.styles.forEach(t => { if (et(t)) { const e = t; Object.keys(e).forEach(t => { F(e[t]).forEach(t => { i.hasOwnProperty(t) || r.add(t) }) }) } }), r.size) { const n = B(r.values()); e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`) } } return { type: 0, name: t.name, style: n, options: s ? { params: s } : null } } visitTransition(t, e) { e.queryCount = 0, e.depCount = 0; const n = W(this, M(t.animation), e); return { type: 1, matchers: G(t.expr, e.errors), animation: n, queryCount: e.queryCount, depCount: e.depCount, options: nt(t.options) } } visitSequence(t, e) { return { type: 2, steps: t.steps.map(t => W(this, t, e)), options: nt(t.options) } } visitGroup(t, e) { const n = e.currentTime; let s = 0; const r = t.steps.map(t => { e.currentTime = n; const r = W(this, t, e); return s = Math.max(s, e.currentTime), r }); return e.currentTime = s, { type: 3, steps: r, options: nt(t.options) } } visitAnimate(t, e) { const n = function (t, e) { let n = null; if (t.hasOwnProperty("duration")) n = t; else if ("number" == typeof t) return st(j(t, e).duration, 0, ""); const s = t; if (s.split(/\s+/).some(t => "{" == t.charAt(0) && "{" == t.charAt(1))) { const t = st(0, 0, ""); return t.dynamic = !0, t.strValue = s, t } return n = n || j(s, e), st(n.duration, n.delay, n.easing) }(t.timings, e.errors); let s; e.currentAnimateTimings = n; let r = t.styles ? t.styles : Object(i.h)({}); if (5 == r.type) s = this.visitKeyframes(r, e); else { let r = t.styles, o = !1; if (!r) { o = !0; const t = {}; n.easing && (t.easing = n.easing), r = Object(i.h)(t) } e.currentTime += n.duration + n.delay; const a = this.visitStyle(r, e); a.isEmptyStep = o, s = a } return e.currentAnimateTimings = null, { type: 4, timings: n, style: s, options: null } } visitStyle(t, e) { const n = this._makeStyleAst(t, e); return this._validateStyleAst(n, e), n } _makeStyleAst(t, e) { const n = []; Array.isArray(t.styles) ? t.styles.forEach(t => { "string" == typeof t ? t == i.a ? n.push(t) : e.errors.push(`The provided style string value ${t} is not allowed.`) : n.push(t) }) : n.push(t.styles); let s = !1, r = null; return n.forEach(t => { if (et(t)) { const e = t, n = e.easing; if (n && (r = n, delete e.easing), !s) for (let t in e) if (e[t].toString().indexOf("{{") >= 0) { s = !0; break } } }), { type: 6, styles: n, easing: r, offset: t.offset, containsDynamicStyles: s, options: null } } _validateStyleAst(t, e) { const n = e.currentAnimateTimings; let s = e.currentTime, r = e.currentTime; n && r > 0 && (r -= n.duration + n.delay), t.styles.forEach(t => { "string" != typeof t && Object.keys(t).forEach(n => { if (!this._driver.validateStyleProperty(n)) return void e.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`); const i = e.collectedStyles[e.currentQuerySelector], o = i[n]; let a = !0; o && (r != s && r >= o.startTime && s <= o.endTime && (e.errors.push(`The CSS property "${n}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${r}ms" and "${s}ms"`), a = !1), r = o.startTime), a && (i[n] = { startTime: r, endTime: s }), e.options && function (t, e, n) { const s = e.params || {}, r = F(t); r.length && r.forEach(t => { s.hasOwnProperty(t) || n.push(`Unable to resolve the local animation param ${t} in the given list of values`) }) }(t[n], e.options, e.errors) }) }) } visitKeyframes(t, e) { const n = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push("keyframes() must be placed inside of a call to animate()"), n; let s = 0; const r = []; let i = !1, o = !1, a = 0; const c = t.steps.map(t => { const n = this._makeStyleAst(t, e); let c = null != n.offset ? n.offset : function (t) { if ("string" == typeof t) return null; let e = null; if (Array.isArray(t)) t.forEach(t => { if (et(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } }); else if (et(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } return e }(n.styles), l = 0; return null != c && (s++, l = n.offset = c), o = o || l < 0 || l > 1, i = i || l < a, a = l, r.push(l), n }); o && e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), i && e.errors.push("Please ensure that all keyframe offsets are in order"); const l = t.steps.length; let u = 0; s > 0 && s < l ? e.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == s && (u = 1 / (l - 1)); const h = l - 1, d = e.currentTime, p = e.currentAnimateTimings, f = p.duration; return c.forEach((t, s) => { const i = u > 0 ? s == h ? 1 : u * s : r[s], o = i * f; e.currentTime = d + p.delay + o, p.duration = o, this._validateStyleAst(t, e), t.offset = i, n.styles.push(t) }), n } visitReference(t, e) { return { type: 8, animation: W(this, M(t.animation), e), options: nt(t.options) } } visitAnimateChild(t, e) { return e.depCount++, { type: 9, options: nt(t.options) } } visitAnimateRef(t, e) { return { type: 10, animation: this.visitReference(t.animation, e), options: nt(t.options) } } visitQuery(t, e) { const n = e.currentQuerySelector, s = t.options || {}; e.queryCount++, e.currentQuery = t; const [r, i] = function (t) { const e = !!t.split(/\s*,\s*/).find(t => ":self" == t); return e && (t = t.replace(Y, "")), [t = t.replace(/@\*/g, ".ng-trigger").replace(/@\w+/g, t => ".ng-trigger-" + t.substr(1)).replace(/:animating/g, ".ng-animating"), e] }(t.selector); e.currentQuerySelector = n.length ? n + " " + r : r, d(e.collectedStyles, e.currentQuerySelector, {}); const o = W(this, M(t.animation), e); return e.currentQuery = null, e.currentQuerySelector = n, { type: 11, selector: r, limit: s.limit || 0, optional: !!s.optional, includeSelf: i, animation: o, originalSelector: t.selector, options: nt(t.options) } } visitStagger(t, e) { e.currentQuery || e.errors.push("stagger() can only be used inside of query()"); const n = "full" === t.timings ? { duration: 0, delay: 0, easing: "full" } : j(t.timings, e.errors, !0); return { type: 12, animation: W(this, M(t.animation), e), timings: n, options: null } } } class tt { constructor(t) { this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null } } function et(t) { return !Array.isArray(t) && "object" == typeof t } function nt(t) { var e; return t ? (t = A(t)).params && (t.params = (e = t.params) ? A(e) : null) : t = {}, t } function st(t, e, n) { return { duration: t, delay: e, easing: n } } function rt(t, e, n, s, r, i, o = null, a = !1) { return { type: 1, element: t, keyframes: e, preStyleProps: n, postStyleProps: s, duration: r, delay: i, totalTime: r + i, easing: o, subTimeline: a } } class it { constructor() { this._map = new Map } consume(t) { let e = this._map.get(t); return e ? this._map.delete(t) : e = [], e } append(t, e) { let n = this._map.get(t); n || this._map.set(t, n = []), n.push(...e) } has(t) { return this._map.has(t) } clear() { this._map.clear() } } const ot = new RegExp(":enter", "g"), at = new RegExp(":leave", "g"); function ct(t, e, n, s, r, i = {}, o = {}, a, c, l = []) { return (new lt).buildKeyframes(t, e, n, s, r, i, o, a, c, l) } class lt { buildKeyframes(t, e, n, s, r, i, o, a, c, l = []) { c = c || new it; const u = new ht(t, e, c, s, r, l, []); u.options = a, u.currentTimeline.setStyles([i], null, u.errors, a), W(this, n, u); const h = u.timelines.filter(t => t.containsAnimation()); if (h.length && Object.keys(o).length) { const t = h[h.length - 1]; t.allowOnlyTimelineStyles() || t.setStyles([o], null, u.errors, a) } return h.length ? h.map(t => t.buildKeyframes()) : [rt(e, [], [], [], 0, 0, "", !1)] } visitTrigger(t, e) { } visitState(t, e) { } visitTransition(t, e) { } visitAnimateChild(t, e) { const n = e.subInstructions.consume(e.element); if (n) { const s = e.createSubContext(t.options), r = e.currentTimeline.currentTime, i = this._visitSubInstructions(n, s, s.options); r != i && e.transformIntoNewTimeline(i) } e.previousNode = t } visitAnimateRef(t, e) { const n = e.createSubContext(t.options); n.transformIntoNewTimeline(), this.visitReference(t.animation, n), e.transformIntoNewTimeline(n.currentTimeline.currentTime), e.previousNode = t } _visitSubInstructions(t, e, n) { let s = e.currentTimeline.currentTime; const r = null != n.duration ? T(n.duration) : null, i = null != n.delay ? T(n.delay) : null; return 0 !== r && t.forEach(t => { const n = e.appendInstructionToTimeline(t, r, i); s = Math.max(s, n.duration + n.delay) }), s } visitReference(t, e) { e.updateOptions(t.options, !0), W(this, t.animation, e), e.previousNode = t } visitSequence(t, e) { const n = e.subContextCount; let s = e; const r = t.options; if (r && (r.params || r.delay) && (s = e.createSubContext(r), s.transformIntoNewTimeline(), null != r.delay)) { 6 == s.previousNode.type && (s.currentTimeline.snapshotCurrentStyles(), s.previousNode = ut); const t = T(r.delay); s.delayNextStep(t) } t.steps.length && (t.steps.forEach(t => W(this, t, s)), s.currentTimeline.applyStylesToKeyframe(), s.subContextCount > n && s.transformIntoNewTimeline()), e.previousNode = t } visitGroup(t, e) { const n = []; let s = e.currentTimeline.currentTime; const r = t.options && t.options.delay ? T(t.options.delay) : 0; t.steps.forEach(i => { const o = e.createSubContext(t.options); r && o.delayNextStep(r), W(this, i, o), s = Math.max(s, o.currentTimeline.currentTime), n.push(o.currentTimeline) }), n.forEach(t => e.currentTimeline.mergeTimelineCollectedStyles(t)), e.transformIntoNewTimeline(s), e.previousNode = t } _visitTiming(t, e) { if (t.dynamic) { const n = t.strValue; return j(e.params ? V(n, e.params, e.errors) : n, e.errors) } return { duration: t.duration, delay: t.delay, easing: t.easing } } visitAnimate(t, e) { const n = e.currentAnimateTimings = this._visitTiming(t.timings, e), s = e.currentTimeline; n.delay && (e.incrementTime(n.delay), s.snapshotCurrentStyles()); const r = t.style; 5 == r.type ? this.visitKeyframes(r, e) : (e.incrementTime(n.duration), this.visitStyle(r, e), s.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t } visitStyle(t, e) { const n = e.currentTimeline, s = e.currentAnimateTimings; !s && n.getCurrentStyleProperties().length && n.forwardFrame(); const r = s && s.easing || t.easing; t.isEmptyStep ? n.applyEmptyStep(r) : n.setStyles(t.styles, r, e.errors, e.options), e.previousNode = t } visitKeyframes(t, e) { const n = e.currentAnimateTimings, s = e.currentTimeline.duration, r = n.duration, i = e.createSubContext().currentTimeline; i.easing = n.easing, t.styles.forEach(t => { i.forwardTime((t.offset || 0) * r), i.setStyles(t.styles, t.easing, e.errors, e.options), i.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(i), e.transformIntoNewTimeline(s + r), e.previousNode = t } visitQuery(t, e) { const n = e.currentTimeline.currentTime, s = t.options || {}, r = s.delay ? T(s.delay) : 0; r && (6 === e.previousNode.type || 0 == n && e.currentTimeline.getCurrentStyleProperties().length) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = ut); let i = n; const o = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!s.optional, e.errors); e.currentQueryTotal = o.length; let a = null; o.forEach((n, s) => { e.currentQueryIndex = s; const o = e.createSubContext(t.options, n); r && o.delayNextStep(r), n === e.element && (a = o.currentTimeline), W(this, t.animation, o), o.currentTimeline.applyStylesToKeyframe(), i = Math.max(i, o.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(i), a && (e.currentTimeline.mergeTimelineCollectedStyles(a), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t } visitStagger(t, e) { const n = e.parentContext, s = e.currentTimeline, r = t.timings, i = Math.abs(r.duration), o = i * (e.currentQueryTotal - 1); let a = i * e.currentQueryIndex; switch (r.duration < 0 ? "reverse" : r.easing) { case "reverse": a = o - a; break; case "full": a = n.currentStaggerTime }const c = e.currentTimeline; a && c.delayNextStep(a); const l = c.currentTime; W(this, t.animation, e), e.previousNode = t, n.currentStaggerTime = s.currentTime - l + (s.startTime - n.currentTimeline.startTime) } } const ut = {}; class ht { constructor(t, e, n, s, r, i, o, a) { this._driver = t, this.element = e, this.subInstructions = n, this._enterClassName = s, this._leaveClassName = r, this.errors = i, this.timelines = o, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = ut, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = a || new dt(this._driver, e, 0), o.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(t, e) { if (!t) return; const n = t; let s = this.options; null != n.duration && (s.duration = T(n.duration)), null != n.delay && (s.delay = T(n.delay)); const r = n.params; if (r) { let t = s.params; t || (t = this.options.params = {}), Object.keys(r).forEach(n => { e && t.hasOwnProperty(n) || (t[n] = V(r[n], t, this.errors)) }) } } _copyOptions() { const t = {}; if (this.options) { const e = this.options.params; if (e) { const n = t.params = {}; Object.keys(e).forEach(t => { n[t] = e[t] }) } } return t } createSubContext(t = null, e, n) { const s = e || this.element, r = new ht(this._driver, s, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(s, n || 0)); return r.previousNode = this.previousNode, r.currentAnimateTimings = this.currentAnimateTimings, r.options = this._copyOptions(), r.updateOptions(t), r.currentQueryIndex = this.currentQueryIndex, r.currentQueryTotal = this.currentQueryTotal, r.parentContext = this, this.subContextCount++, r } transformIntoNewTimeline(t) { return this.previousNode = ut, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(t, e, n) { const s = { duration: null != e ? e : t.duration, delay: this.currentTimeline.currentTime + (null != n ? n : 0) + t.delay, easing: "" }, r = new pt(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, s, t.stretchStartingKeyframe); return this.timelines.push(r), s } incrementTime(t) { this.currentTimeline.forwardTime(this.currentTimeline.duration + t) } delayNextStep(t) { t > 0 && this.currentTimeline.delayNextStep(t) } invokeQuery(t, e, n, s, r, i) { let o = []; if (s && o.push(this.element), t.length > 0) { t = (t = t.replace(ot, "." + this._enterClassName)).replace(at, "." + this._leaveClassName); let e = this._driver.query(this.element, t, 1 != n); 0 !== n && (e = n < 0 ? e.slice(e.length + n, e.length) : e.slice(0, n)), o.push(...e) } return r || 0 != o.length || i.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`), o } } class dt { constructor(t, e, n, s) { this._driver = t, this.element = e, this.startTime = n, this._elementTimelineStylesLookup = s, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.getCurrentStyleProperties().length > 0; default: return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(t) { const e = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length; this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t } fork(t, e) { return this.applyStylesToKeyframe(), new dt(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(t) { this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe() } _updateStyle(t, e) { this._localTimelineStyles[t] = e, this._globalTimelineStyles[t] = e, this._styleSummary[t] = { time: this.currentTime, value: e } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(t) { t && (this._previousKeyframe.easing = t), Object.keys(this._globalTimelineStyles).forEach(t => { this._backFill[t] = this._globalTimelineStyles[t] || i.a, this._currentKeyframe[t] = i.a }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(t, e, n, s) { e && (this._previousKeyframe.easing = e); const r = s && s.params || {}, o = function (t, e) { const n = {}; let s; return t.forEach(t => { "*" === t ? (s = s || Object.keys(e), s.forEach(t => { n[t] = i.a })) : R(t, !1, n) }), n }(t, this._globalTimelineStyles); Object.keys(o).forEach(t => { const e = V(o[t], r, n); this._pendingStyles[t] = e, this._localTimelineStyles.hasOwnProperty(t) || (this._backFill[t] = this._globalTimelineStyles.hasOwnProperty(t) ? this._globalTimelineStyles[t] : i.a), this._updateStyle(t, e) }) } applyStylesToKeyframe() { const t = this._pendingStyles, e = Object.keys(t); 0 != e.length && (this._pendingStyles = {}, e.forEach(e => { this._currentKeyframe[e] = t[e] }), Object.keys(this._localTimelineStyles).forEach(t => { this._currentKeyframe.hasOwnProperty(t) || (this._currentKeyframe[t] = this._localTimelineStyles[t]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(t => { const e = this._localTimelineStyles[t]; this._pendingStyles[t] = e, this._updateStyle(t, e) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const t = []; for (let e in this._currentKeyframe) t.push(e); return t } mergeTimelineCollectedStyles(t) { Object.keys(t._styleSummary).forEach(e => { const n = this._styleSummary[e], s = t._styleSummary[e]; (!n || s.time > n.time) && this._updateStyle(e, s.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const t = new Set, e = new Set, n = 1 === this._keyframes.size && 0 === this.duration; let s = []; this._keyframes.forEach((r, o) => { const a = R(r, !0); Object.keys(a).forEach(n => { const s = a[n]; s == i.l ? t.add(n) : s == i.a && e.add(n) }), n || (a.offset = o / this.duration), s.push(a) }); const r = t.size ? B(t.values()) : [], o = e.size ? B(e.values()) : []; if (n) { const t = s[0], e = A(t); t.offset = 0, e.offset = 1, s = [t, e] } return rt(this.element, s, r, o, this.duration, this.startTime, this.easing, !1) } } class pt extends dt { constructor(t, e, n, s, r, i, o = !1) { super(t, e, i.delay), this.element = e, this.keyframes = n, this.preStyleProps = s, this.postStyleProps = r, this._stretchStartingKeyframe = o, this.timings = { duration: i.duration, delay: i.delay, easing: i.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let t = this.keyframes, { delay: e, duration: n, easing: s } = this.timings; if (this._stretchStartingKeyframe && e) { const r = [], i = n + e, o = e / i, a = R(t[0], !1); a.offset = 0, r.push(a); const c = R(t[0], !1); c.offset = ft(o), r.push(c); const l = t.length - 1; for (let s = 1; s <= l; s++) { let o = R(t[s], !1); o.offset = ft((e + o.offset * n) / i), r.push(o) } n = i, e = 0, s = "", t = r } return rt(this.element, t, this.preStyleProps, this.postStyleProps, n, e, s, !0) } } function ft(t, e = 3) { const n = Math.pow(10, e - 1); return Math.round(t * n) / n } class gt { } class mt extends gt { normalizePropertyName(t, e) { return H(t) } normalizeStyleValue(t, e, n, s) { let r = ""; const i = n.toString().trim(); if (bt[e] && 0 !== n && "0" !== n) if ("number" == typeof n) r = "px"; else { const e = n.match(/^[+-]?[\d\.]+([a-z]*)$/); e && 0 == e[1].length && s.push(`Please provide a CSS unit value for ${t}:${n}`) } return i + r } } const bt = (() => function (t) { const e = {}; return t.forEach(t => e[t] = !0), e }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))(); function _t(t, e, n, s, r, i, o, a, c, l, u, h, d) { return { type: 0, element: t, triggerName: e, isRemovalTransition: r, fromState: n, fromStyles: i, toState: s, toStyles: o, timelines: a, queriedElements: c, preStyleProps: l, postStyleProps: u, totalTime: h, errors: d } } const vt = {}; class yt { constructor(t, e, n) { this._triggerName = t, this.ast = e, this._stateStyles = n } match(t, e, n, s) { return function (t, e, n, s, r) { return t.some(t => t(e, n, s, r)) }(this.ast.matchers, t, e, n, s) } buildStyles(t, e, n) { const s = this._stateStyles["*"], r = this._stateStyles[t], i = s ? s.buildStyles(e, n) : {}; return r ? r.buildStyles(e, n) : i } build(t, e, n, s, r, i, o, a, c, l) { const u = [], h = this.ast.options && this.ast.options.params || vt, p = this.buildStyles(n, o && o.params || vt, u), f = a && a.params || vt, g = this.buildStyles(s, f, u), m = new Set, b = new Map, _ = new Map, v = "void" === s, y = { params: Object.assign(Object.assign({}, h), f) }, w = l ? [] : ct(t, e, this.ast.animation, r, i, p, g, y, c, u); let C = 0; if (w.forEach(t => { C = Math.max(t.duration + t.delay, C) }), u.length) return _t(e, this._triggerName, n, s, v, p, g, [], [], b, _, C, u); w.forEach(t => { const n = t.element, s = d(b, n, {}); t.preStyleProps.forEach(t => s[t] = !0); const r = d(_, n, {}); t.postStyleProps.forEach(t => r[t] = !0), n !== e && m.add(n) }); const O = B(m.values()); return _t(e, this._triggerName, n, s, v, p, g, w, O, b, _, C) } } class wt { constructor(t, e) { this.styles = t, this.defaultParams = e } buildStyles(t, e) { const n = {}, s = A(this.defaultParams); return Object.keys(t).forEach(e => { const n = t[e]; null != n && (s[e] = n) }), this.styles.styles.forEach(t => { if ("string" != typeof t) { const r = t; Object.keys(r).forEach(t => { let i = r[t]; i.length > 1 && (i = V(i, s, e)), n[t] = i }) } }), n } } class Ct { constructor(t, e) { this.name = t, this.ast = e, this.transitionFactories = [], this.states = {}, e.states.forEach(t => { this.states[t.name] = new wt(t.style, t.options && t.options.params || {}) }), Ot(this.states, "true", "1"), Ot(this.states, "false", "0"), e.transitions.forEach(e => { this.transitionFactories.push(new yt(t, e, this.states)) }), this.fallbackTransition = new yt(t, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(t, e) => !0], options: null, queryCount: 0, depCount: 0 }, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(t, e, n, s) { return this.transitionFactories.find(r => r.match(t, e, n, s)) || null } matchStyles(t, e, n) { return this.fallbackTransition.buildStyles(t, e, n) } } function Ot(t, e, n) { t.hasOwnProperty(e) ? t.hasOwnProperty(n) || (t[n] = t[e]) : t.hasOwnProperty(n) && (t[e] = t[n]) } const St = new it; class xt { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._normalizer = n, this._animations = {}, this._playersById = {}, this.players = [] } register(t, e) { const n = [], s = Q(this._driver, e, n); if (n.length) throw new Error(`Unable to build the animation due to the following errors: ${n.join("\n")}`); this._animations[t] = s } _buildPlayer(t, e, n) { const s = t.element, r = c(0, this._normalizer, 0, t.keyframes, e, n); return this._driver.animate(s, r, t.duration, t.delay, t.easing, [], !0) } create(t, e, n = {}) { const s = [], r = this._animations[t]; let o; const c = new Map; if (r ? (o = ct(this._driver, e, r, "ng-enter", "ng-leave", {}, {}, n, St, s), o.forEach(t => { const e = d(c, t.element, {}); t.postStyleProps.forEach(t => e[t] = null) })) : (s.push("The requested animation doesn't exist or has already been destroyed"), o = []), s.length) throw new Error(`Unable to create the animation due to the following errors: ${s.join("\n")}`); c.forEach((t, e) => { Object.keys(t).forEach(n => { t[n] = this._driver.computeStyle(e, n, i.a) }) }); const l = a(o.map(t => { const e = c.get(t.element); return this._buildPlayer(t, {}, e) })); return this._playersById[t] = l, l.onDestroy(() => this.destroy(t)), this.players.push(l), l } destroy(t) { const e = this._getPlayer(t); e.destroy(), delete this._playersById[t]; const n = this.players.indexOf(e); n >= 0 && this.players.splice(n, 1) } _getPlayer(t) { const e = this._playersById[t]; if (!e) throw new Error(`Unable to find the timeline player referenced by ${t}`); return e } listen(t, e, n, s) { const r = h(e, "", "", ""); return l(this._getPlayer(t), n, r, s), () => { } } command(t, e, n, s) { if ("register" == n) return void this.register(t, s[0]); if ("create" == n) return void this.create(t, e, s[0] || {}); const r = this._getPlayer(t); switch (n) { case "play": r.play(); break; case "pause": r.pause(); break; case "reset": r.reset(); break; case "restart": r.restart(); break; case "finish": r.finish(); break; case "init": r.init(); break; case "setPosition": r.setPosition(parseFloat(s[0])); break; case "destroy": this.destroy(t) } } } const Et = [], Tt = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, kt = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }; class jt { constructor(t, e = "") { this.namespaceId = e; const n = t && t.hasOwnProperty("value"); if (this.value = null != (s = n ? t.value : t) ? s : null, n) { const e = A(t); delete e.value, this.options = e } else this.options = {}; var s; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(t) { const e = t.params; if (e) { const t = this.options.params; Object.keys(e).forEach(n => { null == t[n] && (t[n] = e[n]) }) } } } const At = new jt("void"); class Rt { constructor(t, e, n) { this.id = t, this.hostElement = e, this._engine = n, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, Ft(e, this._hostClassName) } listen(t, e, n, s) { if (!this._triggers.hasOwnProperty(e)) throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`); if (null == n || 0 == n.length) throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`); if ("start" != (r = n) && "done" != r) throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`); var r; const i = d(this._elementListeners, t, []), o = { name: e, phase: n, callback: s }; i.push(o); const a = d(this._engine.statesByElement, t, {}); return a.hasOwnProperty(e) || (Ft(t, "ng-trigger"), Ft(t, "ng-trigger-" + e), a[e] = At), () => { this._engine.afterFlush(() => { const t = i.indexOf(o); t >= 0 && i.splice(t, 1), this._triggers[e] || delete a[e] }) } } register(t, e) { return !this._triggers[t] && (this._triggers[t] = e, !0) } _getTrigger(t) { const e = this._triggers[t]; if (!e) throw new Error(`The provided animation trigger "${t}" has not been registered!`); return e } trigger(t, e, n, s = !0) { const r = this._getTrigger(e), i = new It(this.id, e, t); let o = this._engine.statesByElement.get(t); o || (Ft(t, "ng-trigger"), Ft(t, "ng-trigger-" + e), this._engine.statesByElement.set(t, o = {})); let a = o[e]; const c = new jt(n, this.id); if (!(n && n.hasOwnProperty("value")) && a && c.absorbOptions(a.options), o[e] = c, a || (a = At), "void" !== c.value && a.value === c.value) { if (!function (t, e) { const n = Object.keys(t), s = Object.keys(e); if (n.length != s.length) return !1; for (let r = 0; r < n.length; r++) { const s = n[r]; if (!e.hasOwnProperty(s) || t[s] !== e[s]) return !1 } return !0 }(a.params, c.params)) { const e = [], n = r.matchStyles(a.value, a.params, e), s = r.matchStyles(c.value, c.params, e); e.length ? this._engine.reportError(e) : this._engine.afterFlush(() => { D(t, n), P(t, s) }) } return } const l = d(this._engine.playersByElement, t, []); l.forEach(t => { t.namespaceId == this.id && t.triggerName == e && t.queued && t.destroy() }); let u = r.matchTransition(a.value, c.value, t, c.params), h = !1; if (!u) { if (!s) return; u = r.fallbackTransition, h = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: u, fromState: a, toState: c, player: i, isFallbackTransition: h }), h || (Ft(t, "ng-animate-queued"), i.onStart(() => { Vt(t, "ng-animate-queued") })), i.onDone(() => { let e = this.players.indexOf(i); e >= 0 && this.players.splice(e, 1); const n = this._engine.playersByElement.get(t); if (n) { let t = n.indexOf(i); t >= 0 && n.splice(t, 1) } }), this.players.push(i), l.push(i), i } deregister(t) { delete this._triggers[t], this._engine.statesByElement.forEach((e, n) => { delete e[t] }), this._elementListeners.forEach((e, n) => { this._elementListeners.set(n, e.filter(e => e.name != t)) }) } clearElementCache(t) { this._engine.statesByElement.delete(t), this._elementListeners.delete(t); const e = this._engine.playersByElement.get(t); e && (e.forEach(t => t.destroy()), this._engine.playersByElement.delete(t)) } _signalRemovalForInnerTriggers(t, e) { const n = this._engine.driver.query(t, ".ng-trigger", !0); n.forEach(t => { if (t.__ng_removed) return; const n = this._engine.fetchNamespacesByElement(t); n.size ? n.forEach(n => n.triggerLeaveAnimation(t, e, !1, !0)) : this.clearElementCache(t) }), this._engine.afterFlushAnimationsDone(() => n.forEach(t => this.clearElementCache(t))) } triggerLeaveAnimation(t, e, n, s) { const r = this._engine.statesByElement.get(t); if (r) { const i = []; if (Object.keys(r).forEach(e => { if (this._triggers[e]) { const n = this.trigger(t, e, "void", s); n && i.push(n) } }), i.length) return this._engine.markElementAsRemoved(this.id, t, !0, e), n && a(i).onDone(() => this._engine.processLeaveNode(t)), !0 } return !1 } prepareLeaveAnimationListeners(t) { const e = this._elementListeners.get(t), n = this._engine.statesByElement.get(t); if (e && n) { const s = new Set; e.forEach(e => { const r = e.name; if (s.has(r)) return; s.add(r); const i = this._triggers[r].fallbackTransition, o = n[r] || At, a = new jt("void"), c = new It(this.id, r, t); this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: r, transition: i, fromState: o, toState: a, player: c, isFallbackTransition: !0 }) }) } } removeNode(t, e) { const n = this._engine; if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e), this.triggerLeaveAnimation(t, e, !0)) return; let s = !1; if (n.totalAnimations) { const e = n.players.length ? n.playersByQueriedElement.get(t) : []; if (e && e.length) s = !0; else { let e = t; for (; e = e.parentNode;)if (n.statesByElement.get(e)) { s = !0; break } } } if (this.prepareLeaveAnimationListeners(t), s) n.markElementAsRemoved(this.id, t, !1, e); else { const s = t.__ng_removed; s && s !== Tt || (n.afterFlush(() => this.clearElementCache(t)), n.destroyInnerAnimations(t), n._onRemovalComplete(t, e)) } } insertNode(t, e) { Ft(t, this._hostClassName) } drainQueuedTransitions(t) { const e = []; return this._queue.forEach(n => { const s = n.player; if (s.destroyed) return; const r = n.element, i = this._elementListeners.get(r); i && i.forEach(e => { if (e.name == n.triggerName) { const s = h(r, n.triggerName, n.fromState.value, n.toState.value); s._data = t, l(n.player, e.phase, s, e.callback) } }), s.markedForDestroy ? this._engine.afterFlush(() => { s.destroy() }) : e.push(n) }), this._queue = [], e.sort((t, e) => { const n = t.transition.ast.depCount, s = e.transition.ast.depCount; return 0 == n || 0 == s ? n - s : this._engine.driver.containsElement(t.element, e.element) ? 1 : -1 }) } destroy(t) { this.players.forEach(t => t.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t) } elementContainsData(t) { let e = !1; return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(e => e.element === t) || e, e } } class Lt { constructor(t, e, n) { this.bodyNode = t, this.driver = e, this._normalizer = n, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (t, e) => { } } _onRemovalComplete(t, e) { this.onRemovalComplete(t, e) } get queuedPlayers() { const t = []; return this._namespaceList.forEach(e => { e.players.forEach(e => { e.queued && t.push(e) }) }), t } createNamespace(t, e) { const n = new Rt(t, e, this); return e.parentNode ? this._balanceNamespaceList(n, e) : (this.newHostElements.set(e, n), this.collectEnterElement(e)), this._namespaceLookup[t] = n } _balanceNamespaceList(t, e) { const n = this._namespaceList.length - 1; if (n >= 0) { let s = !1; for (let r = n; r >= 0; r--)if (this.driver.containsElement(this._namespaceList[r].hostElement, e)) { this._namespaceList.splice(r + 1, 0, t), s = !0; break } s || this._namespaceList.splice(0, 0, t) } else this._namespaceList.push(t); return this.namespacesByHostElement.set(e, t), t } register(t, e) { let n = this._namespaceLookup[t]; return n || (n = this.createNamespace(t, e)), n } registerTrigger(t, e, n) { let s = this._namespaceLookup[t]; s && s.register(e, n) && this.totalAnimations++ } destroy(t, e) { if (!t) return; const n = this._fetchNamespace(t); this.afterFlush(() => { this.namespacesByHostElement.delete(n.hostElement), delete this._namespaceLookup[t]; const e = this._namespaceList.indexOf(n); e >= 0 && this._namespaceList.splice(e, 1) }), this.afterFlushAnimationsDone(() => n.destroy(e)) } _fetchNamespace(t) { return this._namespaceLookup[t] } fetchNamespacesByElement(t) { const e = new Set, n = this.statesByElement.get(t); if (n) { const t = Object.keys(n); for (let s = 0; s < t.length; s++) { const r = n[t[s]].namespaceId; if (r) { const t = this._fetchNamespace(r); t && e.add(t) } } } return e } trigger(t, e, n, s) { if (Pt(e)) { const r = this._fetchNamespace(t); if (r) return r.trigger(e, n, s), !0 } return !1 } insertNode(t, e, n, s) { if (!Pt(e)) return; const r = e.__ng_removed; if (r && r.setForRemoval) { r.setForRemoval = !1, r.setForMove = !0; const t = this.collectedLeaveElements.indexOf(e); t >= 0 && this.collectedLeaveElements.splice(t, 1) } if (t) { const s = this._fetchNamespace(t); s && s.insertNode(e, n) } s && this.collectEnterElement(e) } collectEnterElement(t) { this.collectedEnterElements.push(t) } markElementAsDisabled(t, e) { e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), Ft(t, "ng-animate-disabled")) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), Vt(t, "ng-animate-disabled")) } removeNode(t, e, n, s) { if (Pt(e)) { const r = t ? this._fetchNamespace(t) : null; if (r ? r.removeNode(e, s) : this.markElementAsRemoved(t, e, !1, s), n) { const n = this.namespacesByHostElement.get(e); n && n.id !== t && n.removeNode(e, s) } } else this._onRemovalComplete(e, s) } markElementAsRemoved(t, e, n, s) { this.collectedLeaveElements.push(e), e.__ng_removed = { namespaceId: t, setForRemoval: s, hasAnimation: n, removedBeforeQueried: !1 } } listen(t, e, n, s, r) { return Pt(e) ? this._fetchNamespace(t).listen(e, n, s, r) : () => { } } _buildInstruction(t, e, n, s, r) { return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, n, s, t.fromState.options, t.toState.options, e, r) } destroyInnerAnimations(t) { let e = this.driver.query(t, ".ng-trigger", !0); e.forEach(t => this.destroyActiveAnimationsForElement(t)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, ".ng-animating", !0), e.forEach(t => this.finishActiveQueriedAnimationOnElement(t))) } destroyActiveAnimationsForElement(t) { const e = this.playersByElement.get(t); e && e.forEach(t => { t.queued ? t.markedForDestroy = !0 : t.destroy() }) } finishActiveQueriedAnimationOnElement(t) { const e = this.playersByQueriedElement.get(t); e && e.forEach(t => t.finish()) } whenRenderingDone() { return new Promise(t => { if (this.players.length) return a(this.players).onDone(() => t()); t() }) } processLeaveNode(t) { const e = t.__ng_removed; if (e && e.setForRemoval) { if (t.__ng_removed = Tt, e.namespaceId) { this.destroyInnerAnimations(t); const n = this._fetchNamespace(e.namespaceId); n && n.clearElementCache(t) } this._onRemovalComplete(t, e.setForRemoval) } this.driver.matchesElement(t, ".ng-animate-disabled") && this.markElementAsDisabled(t, !1), this.driver.query(t, ".ng-animate-disabled", !0).forEach(t => { this.markElementAsDisabled(t, !1) }) } flush(t = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((t, e) => this._balanceNamespaceList(t, e)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let n = 0; n < this.collectedEnterElements.length; n++)Ft(this.collectedEnterElements[n], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const n = []; try { e = this._flushAnimations(n, t) } finally { for (let t = 0; t < n.length; t++)n[t]() } } else for (let n = 0; n < this.collectedLeaveElements.length; n++)this.processLeaveNode(this.collectedLeaveElements[n]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(t => t()), this._flushFns = [], this._whenQuietFns.length) { const t = this._whenQuietFns; this._whenQuietFns = [], e.length ? a(e).onDone(() => { t.forEach(t => t()) }) : t.forEach(t => t()) } } reportError(t) { throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`) } _flushAnimations(t, e) { const n = new it, s = [], r = new Map, o = [], c = new Map, l = new Map, u = new Map, h = new Set; this.disabledNodes.forEach(t => { h.add(t); const e = this.driver.query(t, ".ng-animate-queued", !0); for (let n = 0; n < e.length; n++)h.add(e[n]) }); const p = this.bodyNode, f = Array.from(this.statesByElement.keys()), g = Nt(f, this.collectedEnterElements), m = new Map; let b = 0; g.forEach((t, e) => { const n = "ng-enter" + b++; m.set(e, n), t.forEach(t => Ft(t, n)) }); const _ = [], v = new Set, y = new Set; for (let i = 0; i < this.collectedLeaveElements.length; i++) { const t = this.collectedLeaveElements[i], e = t.__ng_removed; e && e.setForRemoval && (_.push(t), v.add(t), e.hasAnimation ? this.driver.query(t, ".ng-star-inserted", !0).forEach(t => v.add(t)) : y.add(t)) } const w = new Map, C = Nt(f, Array.from(v)); C.forEach((t, e) => { const n = "ng-leave" + b++; w.set(e, n), t.forEach(t => Ft(t, n)) }), t.push(() => { g.forEach((t, e) => { const n = m.get(e); t.forEach(t => Vt(t, n)) }), C.forEach((t, e) => { const n = w.get(e); t.forEach(t => Vt(t, n)) }), _.forEach(t => { this.processLeaveNode(t) }) }); const O = [], S = []; for (let i = this._namespaceList.length - 1; i >= 0; i--)this._namespaceList[i].drainQueuedTransitions(e).forEach(t => { const e = t.player, r = t.element; if (O.push(e), this.collectedEnterElements.length) { const t = r.__ng_removed; if (t && t.setForMove) return void e.destroy() } const i = !p || !this.driver.containsElement(p, r), a = w.get(r), h = m.get(r), f = this._buildInstruction(t, n, h, a, i); if (f.errors && f.errors.length) S.push(f); else { if (i) return e.onStart(() => D(r, f.fromStyles)), e.onDestroy(() => P(r, f.toStyles)), void s.push(e); if (t.isFallbackTransition) return e.onStart(() => D(r, f.fromStyles)), e.onDestroy(() => P(r, f.toStyles)), void s.push(e); f.timelines.forEach(t => t.stretchStartingKeyframe = !0), n.append(r, f.timelines), o.push({ instruction: f, player: e, element: r }), f.queriedElements.forEach(t => d(c, t, []).push(e)), f.preStyleProps.forEach((t, e) => { const n = Object.keys(t); if (n.length) { let t = l.get(e); t || l.set(e, t = new Set), n.forEach(e => t.add(e)) } }), f.postStyleProps.forEach((t, e) => { const n = Object.keys(t); let s = u.get(e); s || u.set(e, s = new Set), n.forEach(t => s.add(t)) }) } }); if (S.length) { const t = []; S.forEach(e => { t.push(`@${e.triggerName} has failed due to:\n`), e.errors.forEach(e => t.push(`- ${e}\n`)) }), O.forEach(t => t.destroy()), this.reportError(t) } const x = new Map, E = new Map; o.forEach(t => { const e = t.element; n.has(e) && (E.set(e, e), this._beforeAnimationBuild(t.player.namespaceId, t.instruction, x)) }), s.forEach(t => { const e = t.element; this._getPreviousPlayers(e, !1, t.namespaceId, t.triggerName, null).forEach(t => { d(x, e, []).push(t), t.destroy() }) }); const T = _.filter(t => Ht(t, l, u)), k = new Map; Mt(k, this.driver, y, u, i.a).forEach(t => { Ht(t, l, u) && T.push(t) }); const j = new Map; g.forEach((t, e) => { Mt(j, this.driver, new Set(t), l, i.l) }), T.forEach(t => { const e = k.get(t), n = j.get(t); k.set(t, Object.assign(Object.assign({}, e), n)) }); const A = [], R = [], L = {}; o.forEach(t => { const { element: e, player: i, instruction: o } = t; if (n.has(e)) { if (h.has(e)) return i.onDestroy(() => P(e, o.toStyles)), i.disabled = !0, i.overrideTotalTime(o.totalTime), void s.push(i); let t = L; if (E.size > 1) { let n = e; const s = []; for (; n = n.parentNode;) { const e = E.get(n); if (e) { t = e; break } s.push(n) } s.forEach(e => E.set(e, t)) } const n = this._buildAnimation(i.namespaceId, o, x, r, j, k); if (i.setRealPlayer(n), t === L) A.push(i); else { const e = this.playersByElement.get(t); e && e.length && (i.parentPlayer = a(e)), s.push(i) } } else D(e, o.fromStyles), i.onDestroy(() => P(e, o.toStyles)), R.push(i), h.has(e) && s.push(i) }), R.forEach(t => { const e = r.get(t.element); if (e && e.length) { const n = a(e); t.setRealPlayer(n) } }), s.forEach(t => { t.parentPlayer ? t.syncPlayerEvents(t.parentPlayer) : t.destroy() }); for (let i = 0; i < _.length; i++) { const t = _[i], e = t.__ng_removed; if (Vt(t, "ng-leave"), e && e.hasAnimation) continue; let n = []; if (c.size) { let e = c.get(t); e && e.length && n.push(...e); let s = this.driver.query(t, ".ng-animating", !0); for (let t = 0; t < s.length; t++) { let e = c.get(s[t]); e && e.length && n.push(...e) } } const s = n.filter(t => !t.destroyed); s.length ? Bt(this, t, s) : this.processLeaveNode(t) } return _.length = 0, A.forEach(t => { this.players.push(t), t.onDone(() => { t.destroy(); const e = this.players.indexOf(t); this.players.splice(e, 1) }), t.play() }), A } elementContainsData(t, e) { let n = !1; const s = e.__ng_removed; return s && s.setForRemoval && (n = !0), this.playersByElement.has(e) && (n = !0), this.playersByQueriedElement.has(e) && (n = !0), this.statesByElement.has(e) && (n = !0), this._fetchNamespace(t).elementContainsData(e) || n } afterFlush(t) { this._flushFns.push(t) } afterFlushAnimationsDone(t) { this._whenQuietFns.push(t) } _getPreviousPlayers(t, e, n, s, r) { let i = []; if (e) { const e = this.playersByQueriedElement.get(t); e && (i = e) } else { const e = this.playersByElement.get(t); if (e) { const t = !r || "void" == r; e.forEach(e => { e.queued || (t || e.triggerName == s) && i.push(e) }) } } return (n || s) && (i = i.filter(t => !(n && n != t.namespaceId || s && s != t.triggerName))), i } _beforeAnimationBuild(t, e, n) { const s = e.element, r = e.isRemovalTransition ? void 0 : t, i = e.isRemovalTransition ? void 0 : e.triggerName; for (const o of e.timelines) { const t = o.element, a = t !== s, c = d(n, t, []); this._getPreviousPlayers(t, a, r, i, e.toState).forEach(t => { const e = t.getRealPlayer(); e.beforeDestroy && e.beforeDestroy(), t.destroy(), c.push(t) }) } D(s, e.fromStyles) } _buildAnimation(t, e, n, s, r, o) { const l = e.triggerName, u = e.element, h = [], p = new Set, f = new Set, g = e.timelines.map(e => { const a = e.element; p.add(a); const d = a.__ng_removed; if (d && d.removedBeforeQueried) return new i.d(e.duration, e.delay); const g = a !== u, m = function (t) { const e = []; return Ut(t, e), e }((n.get(a) || Et).map(t => t.getRealPlayer())).filter(t => !!t.element && t.element === a), b = r.get(a), _ = o.get(a), v = c(0, this._normalizer, 0, e.keyframes, b, _), y = this._buildPlayer(e, v, m); if (e.subTimeline && s && f.add(a), g) { const e = new It(t, l, a); e.setRealPlayer(y), h.push(e) } return y }); h.forEach(t => { d(this.playersByQueriedElement, t.element, []).push(t), t.onDone(() => function (t, e, n) { let s; if (t instanceof Map) { if (s = t.get(e), s) { if (s.length) { const t = s.indexOf(n); s.splice(t, 1) } 0 == s.length && t.delete(e) } } else if (s = t[e], s) { if (s.length) { const t = s.indexOf(n); s.splice(t, 1) } 0 == s.length && delete t[e] } return s }(this.playersByQueriedElement, t.element, t)) }), p.forEach(t => Ft(t, "ng-animating")); const m = a(g); return m.onDestroy(() => { p.forEach(t => Vt(t, "ng-animating")), P(u, e.toStyles) }), f.forEach(t => { d(s, t, []).push(m) }), m } _buildPlayer(t, e, n) { return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, n) : new i.d(t.duration, t.delay) } } class It { constructor(t, e, n) { this.namespaceId = t, this.triggerName = e, this.element = n, this._player = new i.d, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(t) { this._containsRealPlayer || (this._player = t, Object.keys(this._queuedCallbacks).forEach(e => { this._queuedCallbacks[e].forEach(n => l(t, e, void 0, n)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(t) { this.totalTime = t } syncPlayerEvents(t) { const e = this._player; e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy()) } _queueEvent(t, e) { d(this._queuedCallbacks, t, []).push(e) } onDone(t) { this.queued && this._queueEvent("done", t), this._player.onDone(t) } onStart(t) { this.queued && this._queueEvent("start", t), this._player.onStart(t) } onDestroy(t) { this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(t) { this.queued || this._player.setPosition(t) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(t) { const e = this._player; e.triggerCallback && e.triggerCallback(t) } } function Pt(t) { return t && 1 === t.nodeType } function Dt(t, e) { const n = t.style.display; return t.style.display = null != e ? e : "none", n } function Mt(t, e, n, s, r) { const i = []; n.forEach(t => i.push(Dt(t))); const o = []; s.forEach((n, s) => { const i = {}; n.forEach(t => { const n = i[t] = e.computeStyle(s, t, r); n && 0 != n.length || (s.__ng_removed = kt, o.push(s)) }), t.set(s, i) }); let a = 0; return n.forEach(t => Dt(t, i[a++])), o } function Nt(t, e) { const n = new Map; if (t.forEach(t => n.set(t, [])), 0 == e.length) return n; const s = new Set(e), r = new Map; function i(t) { if (!t) return 1; let e = r.get(t); if (e) return e; const o = t.parentNode; return e = n.has(o) ? o : s.has(o) ? 1 : i(o), r.set(t, e), e } return e.forEach(t => { const e = i(t); 1 !== e && n.get(e).push(t) }), n } function Ft(t, e) { if (t.classList) t.classList.add(e); else { let n = t.$$classes; n || (n = t.$$classes = {}), n[e] = !0 } } function Vt(t, e) { if (t.classList) t.classList.remove(e); else { let n = t.$$classes; n && delete n[e] } } function Bt(t, e, n) { a(n).onDone(() => t.processLeaveNode(e)) } function Ut(t, e) { for (let n = 0; n < t.length; n++) { const s = t[n]; s instanceof i.k ? Ut(s.players, e) : e.push(s) } } function Ht(t, e, n) { const s = n.get(t); if (!s) return !1; let r = e.get(t); return r ? s.forEach(t => r.add(t)) : e.set(t, s), n.delete(t), !0 } class zt { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._triggerCache = {}, this.onRemovalComplete = (t, e) => { }, this._transitionEngine = new Lt(t, e, n), this._timelineEngine = new xt(t, e, n), this._transitionEngine.onRemovalComplete = (t, e) => this.onRemovalComplete(t, e) } registerTrigger(t, e, n, s, r) { const i = t + "-" + s; let o = this._triggerCache[i]; if (!o) { const t = [], e = Q(this._driver, r, t); if (t.length) throw new Error(`The animation trigger "${s}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`); o = function (t, e) { return new Ct(t, e) }(s, e), this._triggerCache[i] = o } this._transitionEngine.registerTrigger(e, s, o) } register(t, e) { this._transitionEngine.register(t, e) } destroy(t, e) { this._transitionEngine.destroy(t, e) } onInsert(t, e, n, s) { this._transitionEngine.insertNode(t, e, n, s) } onRemove(t, e, n, s) { this._transitionEngine.removeNode(t, e, s || !1, n) } disableAnimations(t, e) { this._transitionEngine.markElementAsDisabled(t, e) } process(t, e, n, s) { if ("@" == n.charAt(0)) { const [t, r] = p(n); this._timelineEngine.command(t, e, r, s) } else this._transitionEngine.trigger(t, e, n, s) } listen(t, e, n, s, r) { if ("@" == n.charAt(0)) { const [t, s] = p(n); return this._timelineEngine.listen(t, e, s, r) } return this._transitionEngine.listen(t, e, n, s, r) } flush(t = -1) { this._transitionEngine.flush(t) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } function $t(t, e) { let n = null, s = null; return Array.isArray(e) && e.length ? (n = qt(e[0]), e.length > 1 && (s = qt(e[e.length - 1]))) : e && (n = qt(e)), n || s ? new Wt(t, n, s) : null } let Wt = (() => { class t { constructor(e, n, s) { this._element = e, this._startStyles = n, this._endStyles = s, this._state = 0; let r = t.initialStylesByElement.get(e); r || t.initialStylesByElement.set(e, r = {}), this._initialStyles = r } start() { this._state < 1 && (this._startStyles && P(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (P(this._element, this._initialStyles), this._endStyles && (P(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (D(this._element, this._startStyles), this._endStyles = null), this._endStyles && (D(this._element, this._endStyles), this._endStyles = null), P(this._element, this._initialStyles), this._state = 3) } } return t.initialStylesByElement = new WeakMap, t })(); function qt(t) { let e = null; const n = Object.keys(t); for (let s = 0; s < n.length; s++) { const r = n[s]; Gt(r) && (e = e || {}, e[r] = t[r]) } return e } function Gt(t) { return "display" === t || "position" === t } class Xt { constructor(t, e, n, s, r, i, o) { this._element = t, this._name = e, this._duration = n, this._delay = s, this._easing = r, this._fillMode = i, this._onDoneFn = o, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = t => this._handleCallback(t) } apply() { !function (t, e) { const n = te(t, "").trim(); n.length && (function (t, e) { let n = 0; for (let s = 0; s < t.length; s++)"," === t.charAt(s) && n++ }(n), e = `${n}, ${e}`), Jt(t, "", e) }(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), Qt(this._element, this._eventFn, !1), this._startTime = Date.now() } pause() { Kt(this._element, this._name, "paused") } resume() { Kt(this._element, this._name, "running") } setPosition(t) { const e = Zt(this._element, this._name); this._position = t * this._duration, Jt(this._element, "Delay", `-${this._position}ms`, e) } getPosition() { return this._position } _handleCallback(t) { const e = t._ngTestManualTimestamp || Date.now(), n = 1e3 * parseFloat(t.elapsedTime.toFixed(3)); t.animationName == this._name && Math.max(e - this._startTime, 0) >= this._delay && n >= this._duration && this.finish() } finish() { this._finished || (this._finished = !0, this._onDoneFn(), Qt(this._element, this._eventFn, !0)) } destroy() { this._destroyed || (this._destroyed = !0, this.finish(), function (t, e) { const n = te(t, "").split(","), s = Yt(n, e); s >= 0 && (n.splice(s, 1), Jt(t, "", n.join(","))) }(this._element, this._name)) } } function Kt(t, e, n) { Jt(t, "PlayState", n, Zt(t, e)) } function Zt(t, e) { const n = te(t, ""); return n.indexOf(",") > 0 ? Yt(n.split(","), e) : Yt([n], e) } function Yt(t, e) { for (let n = 0; n < t.length; n++)if (t[n].indexOf(e) >= 0) return n; return -1 } function Qt(t, e, n) { n ? t.removeEventListener("animationend", e) : t.addEventListener("animationend", e) } function Jt(t, e, n, s) { const r = "animation" + e; if (null != s) { const e = t.style[r]; if (e.length) { const t = e.split(","); t[s] = n, n = t.join(",") } } t.style[r] = n } function te(t, e) { return t.style["animation" + e] || "" } class ee { constructor(t, e, n, s, r, i, o, a) { this.element = t, this.keyframes = e, this.animationName = n, this._duration = s, this._delay = r, this._finalStyles = o, this._specialStyles = a, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this.currentSnapshot = {}, this._state = 0, this.easing = i || "linear", this.totalTime = s + r, this._buildStyler() } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } destroy() { this.init(), this._state >= 4 || (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } _flushDoneFns() { this._onDoneFns.forEach(t => t()), this._onDoneFns = [] } _flushStartFns() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } finish() { this.init(), this._state >= 3 || (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns()) } setPosition(t) { this._styler.setPosition(t) } getPosition() { return this._styler.getPosition() } hasStarted() { return this._state >= 2 } init() { this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause()) } play() { this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume() } pause() { this.init(), this._styler.pause() } restart() { this.reset(), this.play() } reset() { this._styler.destroy(), this._buildStyler(), this._styler.apply() } _buildStyler() { this._styler = new Xt(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish()) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } beforeDestroy() { this.init(); const t = {}; if (this.hasStarted()) { const e = this._state >= 3; Object.keys(this._finalStyles).forEach(n => { "offset" != n && (t[n] = e ? this._finalStyles[n] : q(this.element, n)) }) } this.currentSnapshot = t } } class ne extends i.d { constructor(t, e) { super(), this.element = t, this._startingStyles = {}, this.__initialized = !1, this._styles = S(e) } init() { !this.__initialized && this._startingStyles && (this.__initialized = !0, Object.keys(this._styles).forEach(t => { this._startingStyles[t] = this.element.style[t] }), super.init()) } play() { this._startingStyles && (this.init(), Object.keys(this._styles).forEach(t => this.element.style.setProperty(t, this._styles[t])), super.play()) } destroy() { this._startingStyles && (Object.keys(this._startingStyles).forEach(t => { const e = this._startingStyles[t]; e ? this.element.style.setProperty(t, e) : this.element.style.removeProperty(t) }), this._startingStyles = null, super.destroy()) } } class se { constructor() { this._count = 0, this._head = document.querySelector("head") } validateStyleProperty(t) { return y(t) } matchesElement(t, e) { return w(t, e) } containsElement(t, e) { return C(t, e) } query(t, e, n) { return O(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } buildKeyframeElement(t, e, n) { n = n.map(t => S(t)); let s = `@keyframes ${e} {\n`, r = ""; n.forEach(t => { r = " "; const e = parseFloat(t.offset); s += `${r}${100 * e}% {\n`, r += " ", Object.keys(t).forEach(e => { const n = t[e]; switch (e) { case "offset": return; case "easing": return void (n && (s += `${r}animation-timing-function: ${n};\n`)); default: return void (s += `${r}${e}: ${n};\n`) } }), s += `${r}}\n` }), s += "}\n"; const i = document.createElement("style"); return i.textContent = s, i } animate(t, e, n, s, r, i = [], o) { const a = i.filter(t => t instanceof ee), c = {}; z(n, s) && a.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => c[t] = e[t]) }); const l = function (t) { let e = {}; return t && (Array.isArray(t) ? t : [t]).forEach(t => { Object.keys(t).forEach(n => { "offset" != n && "easing" != n && (e[n] = t[n]) }) }), e }(e = $(t, e, c)); if (0 == n) return new ne(t, l); const u = "gen_css_kf_" + this._count++, h = this.buildKeyframeElement(t, u, e); document.querySelector("head").appendChild(h); const d = $t(t, e), p = new ee(t, e, u, n, s, r, l, d); return p.onDestroy(() => { var t; (t = h).parentNode.removeChild(t) }), p } } class re { constructor(t, e, n, s) { this.element = t, this.keyframes = e, this.options = n, this._specialStyles = s, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = n.duration, this._delay = n.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const t = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(t, e, n) { return t.animate(e, n) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } setPosition(t) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = t * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const t = {}; this.hasStarted() && Object.keys(this._finalKeyframe).forEach(e => { "offset" != e && (t[e] = this._finished ? this._finalKeyframe[e] : q(this.element, e)) }), this.currentSnapshot = t } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class ie { constructor() { this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(oe().toString()), this._cssKeyframesDriver = new se } validateStyleProperty(t) { return y(t) } matchesElement(t, e) { return w(t, e) } containsElement(t, e) { return C(t, e) } query(t, e, n) { return O(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } overrideWebAnimationsSupport(t) { this._isNativeImpl = t } animate(t, e, n, s, r, i = [], o) { if (!o && !this._isNativeImpl) return this._cssKeyframesDriver.animate(t, e, n, s, r, i); const a = { duration: n, delay: s, fill: 0 == s ? "both" : "forwards" }; r && (a.easing = r); const c = {}, l = i.filter(t => t instanceof re); z(n, s) && l.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => c[t] = e[t]) }); const u = $t(t, e = $(t, e = e.map(t => R(t, !1)), c)); return new re(t, e, a, u) } } function oe() { return "undefined" != typeof window && void 0 !== window.document && Element.prototype.animate || {} } var ae = n("ofXK"); let ce = (() => { class t extends i.b { constructor(t, e) { super(), this._nextAnimationId = 0, this._renderer = t.createRenderer(e.body, { id: "0", encapsulation: s.S.None, styles: [], data: { animation: [] } }) } build(t) { const e = this._nextAnimationId.toString(); this._nextAnimationId++; const n = Array.isArray(t) ? Object(i.f)(t) : t; return he(this._renderer, null, e, "register", [n]), new le(e, this._renderer) } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(s.G), s.bc(ae.e)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); class le extends i.c { constructor(t, e) { super(), this._id = t, this._renderer = e } create(t, e) { return new ue(this._id, t, e || {}, this._renderer) } } class ue { constructor(t, e, n, s) { this.id = t, this.element = e, this._renderer = s, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", n) } _listen(t, e) { return this._renderer.listen(this.element, `@@${this.id}:${t}`, e) } _command(t, ...e) { return he(this._renderer, this.element, this.id, t, e) } onDone(t) { this._listen("done", t) } onStart(t) { this._listen("start", t) } onDestroy(t) { this._listen("destroy", t) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset") } setPosition(t) { this._command("setPosition", t) } getPosition() { var t, e; return null !== (e = null === (t = this._renderer.engine.players[+this.id]) || void 0 === t ? void 0 : t.getPosition()) && void 0 !== e ? e : 0 } } function he(t, e, n, s, r) { return t.setProperty(e, `@@${n}:${s}`, r) } let de = (() => { class t { constructor(t, e, n) { this.delegate = t, this.engine = e, this._zone = n, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), e.onRemovalComplete = (t, e) => { e && e.parentNode(t) && e.removeChild(t.parentNode, t) } } createRenderer(t, e) { const n = this.delegate.createRenderer(t, e); if (!(t && e && e.data && e.data.animation)) { let t = this._rendererCache.get(n); return t || (t = new pe("", n, this.engine), this._rendererCache.set(n, t)), t } const s = e.id, r = e.id + "-" + this._currentId; this._currentId++, this.engine.register(r, t); const i = e => { Array.isArray(e) ? e.forEach(i) : this.engine.registerTrigger(s, r, t, e.name, e) }; return e.data.animation.forEach(i), new fe(this, r, n, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(t, e, n) { t >= 0 && t < this._microtaskId ? this._zone.run(() => e(n)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(t => { const [e, n] = t; e(n) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([e, n])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(s.G), s.bc(zt), s.bc(s.A)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); class pe { constructor(t, e, n) { this.namespaceId = t, this.delegate = e, this.engine = n, this.destroyNode = this.delegate.destroyNode ? t => e.destroyNode(t) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(t, e) { return this.delegate.createElement(t, e) } createComment(t) { return this.delegate.createComment(t) } createText(t) { return this.delegate.createText(t) } appendChild(t, e) { this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1) } insertBefore(t, e, n, s = !0) { this.delegate.insertBefore(t, e, n), this.engine.onInsert(this.namespaceId, e, t, s) } removeChild(t, e, n) { this.engine.onRemove(this.namespaceId, e, this.delegate, n) } selectRootElement(t, e) { return this.delegate.selectRootElement(t, e) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setAttribute(t, e, n, s) { this.delegate.setAttribute(t, e, n, s) } removeAttribute(t, e, n) { this.delegate.removeAttribute(t, e, n) } addClass(t, e) { this.delegate.addClass(t, e) } removeClass(t, e) { this.delegate.removeClass(t, e) } setStyle(t, e, n, s) { this.delegate.setStyle(t, e, n, s) } removeStyle(t, e, n) { this.delegate.removeStyle(t, e, n) } setProperty(t, e, n) { "@" == e.charAt(0) && "@.disabled" == e ? this.disableAnimations(t, !!n) : this.delegate.setProperty(t, e, n) } setValue(t, e) { this.delegate.setValue(t, e) } listen(t, e, n) { return this.delegate.listen(t, e, n) } disableAnimations(t, e) { this.engine.disableAnimations(t, e) } } class fe extends pe { constructor(t, e, n, s) { super(e, n, s), this.factory = t, this.namespaceId = e } setProperty(t, e, n) { "@" == e.charAt(0) ? "." == e.charAt(1) && "@.disabled" == e ? this.disableAnimations(t, n = void 0 === n || !!n) : this.engine.process(this.namespaceId, t, e.substr(1), n) : this.delegate.setProperty(t, e, n) } listen(t, e, n) { if ("@" == e.charAt(0)) { const s = function (t) { switch (t) { case "body": return document.body; case "document": return document; case "window": return window; default: return t } }(t); let r = e.substr(1), i = ""; return "@" != r.charAt(0) && ([r, i] = function (t) { const e = t.indexOf("."); return [t.substring(0, e), t.substr(e + 1)] }(r)), this.engine.listen(this.namespaceId, s, r, i, t => { this.factory.scheduleListenerCallback(t._data || -1, n, t) }) } return this.delegate.listen(t, e, n) } } let ge = (() => { class t extends zt { constructor(t, e, n) { super(t.body, e, n) } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(ae.e), s.bc(E), s.bc(gt)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); const me = [{ provide: E, useFactory: function () { return "function" == typeof oe() ? new ie : new se } }, { provide: new s.r("AnimationModuleType"), useValue: "BrowserAnimations" }, { provide: i.b, useClass: ce }, { provide: gt, useFactory: function () { return new mt } }, { provide: zt, useClass: ge }, { provide: s.G, useFactory: function (t, e, n) { return new de(t, e, n) }, deps: [r.e, zt, s.A] }]; let be = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = s.Pb({ type: t }), t.\u0275inj = s.Ob({ providers: me, imports: [r.a] }), t })() }, "Se/U": function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }); var s = n("/Tr7"), r = n("jIYg"); function i(t) { Object(r.a)(1, arguments); var e = Object(s.a)(t); return !isNaN(e) } }, SeVD: function (t, e, n) { "use strict"; n.d(e, "a", function () { return u }); var s = n("ngJS"), r = n("NJ4a"), i = n("Lhse"), o = n("kJWO"), a = n("I55L"), c = n("c2HN"), l = n("XoHu"); const u = t => { if (t && "function" == typeof t[o.a]) return u = t, t => { const e = u[o.a](); if ("function" != typeof e.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable"); return e.subscribe(t) }; if (Object(a.a)(t)) return Object(s.a)(t); if (Object(c.a)(t)) return n = t, t => (n.then(e => { t.closed || (t.next(e), t.complete()) }, e => t.error(e)).then(null, r.a), t); if (t && "function" == typeof t[i.a]) return e = t, t => { const n = e[i.a](); for (; ;) { let e; try { e = n.next() } catch (s) { return t.error(s), t } if (e.done) { t.complete(); break } if (t.next(e.value), t.closed) break } return "function" == typeof n.return && t.add(() => { n.return && n.return() }), t }; { const e = Object(l.a)(t) ? "an invalid object" : `'${t}'`; throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`) } var e, n, u } }, SpAZ: function (t, e, n) { "use strict"; function s(t) { return t } n.d(e, "a", function () { return s }) }, SxV6: function (t, e, n) { "use strict"; n.d(e, "a", function () { return l }); var s = n("sVev"), r = n("pLZG"), i = n("IzEk"), o = n("xbPD"), a = n("XDbj"), c = n("SpAZ"); function l(t, e) { const n = arguments.length >= 2; return l => l.pipe(t ? Object(r.a)((e, n) => t(e, n, l)) : c.a, Object(i.a)(1), n ? Object(o.a)(e) : Object(a.a)(() => new s.a)) } }, UXun: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("jtHE"); function r(t, e, n) { let r; return r = t && "object" == typeof t ? t : { bufferSize: t, windowTime: e, refCount: !1, scheduler: n }, t => t.lift(function ({ bufferSize: t = Number.POSITIVE_INFINITY, windowTime: e = Number.POSITIVE_INFINITY, refCount: n, scheduler: r }) { let i, o, a = 0, c = !1, l = !1; return function (u) { let h; a++, !i || c ? (c = !1, i = new s.a(t, e, r), h = i.subscribe(this), o = u.subscribe({ next(t) { i.next(t) }, error(t) { c = !0, i.error(t) }, complete() { l = !0, o = void 0, i.complete() } })) : h = i.subscribe(this), this.add(() => { a--, h.unsubscribe(), o && !l && n && 0 === a && (o.unsubscribe(), o = void 0, i = void 0) }) } }(r)) } }, VRyK: function (t, e, n) { "use strict"; n.d(e, "a", function () { return a }); var s = n("HDdC"), r = n("z+Ro"), i = n("bHdf"), o = n("yCtX"); function a(...t) { let e = Number.POSITIVE_INFINITY, n = null, a = t[t.length - 1]; return Object(r.a)(a) ? (n = t.pop(), t.length > 1 && "number" == typeof t[t.length - 1] && (e = t.pop())) : "number" == typeof a && (e = t.pop()), null === n && 1 === t.length && t[0] instanceof s.a ? t[0] : Object(i.a)(e)(Object(o.a)(t, n)) } }, WMd4: function (t, e, n) { "use strict"; n.d(e, "a", function () { return o }); var s = n("EY2u"), r = n("LRne"), i = n("z6cu"); let o = (() => { class t { constructor(t, e, n) { this.kind = t, this.value = e, this.error = n, this.hasValue = "N" === t } observe(t) { switch (this.kind) { case "N": return t.next && t.next(this.value); case "E": return t.error && t.error(this.error); case "C": return t.complete && t.complete() } } do(t, e, n) { switch (this.kind) { case "N": return t && t(this.value); case "E": return e && e(this.error); case "C": return n && n() } } accept(t, e, n) { return t && "function" == typeof t.next ? this.observe(t) : this.do(t, e, n) } toObservable() { switch (this.kind) { case "N": return Object(r.a)(this.value); case "E": return Object(i.a)(this.error); case "C": return Object(s.b)() }throw new Error("unexpected notification kind value") } static createNext(e) { return void 0 !== e ? new t("N", e) : t.undefinedValueNotification } static createError(e) { return new t("E", void 0, e) } static createComplete() { return t.completeNotification } } return t.completeNotification = new t("C"), t.undefinedValueNotification = new t("N", void 0), t })() }, XDbj: function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }); var s = n("sVev"), r = n("7o/Q"); function i(t = c) { return e => e.lift(new o(t)) } class o { constructor(t) { this.errorFactory = t } call(t, e) { return e.subscribe(new a(t, this.errorFactory)) } } class a extends r.a { constructor(t, e) { super(t), this.errorFactory = e, this.hasValue = !1 } _next(t) { this.hasValue = !0, this.destination.next(t) } _complete() { if (this.hasValue) return this.destination.complete(); { let e; try { e = this.errorFactory() } catch (t) { e = t } this.destination.error(e) } } } function c() { return new s.a } }, XNiG: function (t, e, n) { "use strict"; n.d(e, "b", function () { return l }), n.d(e, "a", function () { return u }); var s = n("HDdC"), r = n("7o/Q"), i = n("quSY"), o = n("9ppp"), a = n("Ylt2"), c = n("2QA8"); class l extends r.a { constructor(t) { super(t), this.destination = t } } let u = (() => { class t extends s.a { constructor() { super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null } [c.a]() { return new l(this) } lift(t) { const e = new h(this, this); return e.operator = t, e } next(t) { if (this.closed) throw new o.a; if (!this.isStopped) { const { observers: e } = this, n = e.length, s = e.slice(); for (let r = 0; r < n; r++)s[r].next(t) } } error(t) { if (this.closed) throw new o.a; this.hasError = !0, this.thrownError = t, this.isStopped = !0; const { observers: e } = this, n = e.length, s = e.slice(); for (let r = 0; r < n; r++)s[r].error(t); this.observers.length = 0 } complete() { if (this.closed) throw new o.a; this.isStopped = !0; const { observers: t } = this, e = t.length, n = t.slice(); for (let s = 0; s < e; s++)n[s].complete(); this.observers.length = 0 } unsubscribe() { this.isStopped = !0, this.closed = !0, this.observers = null } _trySubscribe(t) { if (this.closed) throw new o.a; return super._trySubscribe(t) } _subscribe(t) { if (this.closed) throw new o.a; return this.hasError ? (t.error(this.thrownError), i.a.EMPTY) : this.isStopped ? (t.complete(), i.a.EMPTY) : (this.observers.push(t), new a.a(this, t)) } asObservable() { const t = new s.a; return t.source = this, t } } return t.create = (t, e) => new h(t, e), t })(); class h extends u { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { const { destination: e } = this; e && e.next && e.next(t) } error(t) { const { destination: e } = this; e && e.error && this.destination.error(t) } complete() { const { destination: t } = this; t && t.complete && this.destination.complete() } _subscribe(t) { const { source: e } = this; return e ? this.source.subscribe(t) : i.a.EMPTY } } }, XoHu: function (t, e, n) { "use strict"; function s(t) { return null !== t && "object" == typeof t } n.d(e, "a", function () { return s }) }, Ylt2: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("quSY"); class r extends s.a { constructor(t, e) { super(), this.subject = t, this.subscriber = e, this.closed = !1 } unsubscribe() { if (this.closed) return; this.closed = !0; const t = this.subject, e = t.observers; if (this.subject = null, !e || 0 === e.length || t.isStopped || t.closed) return; const n = e.indexOf(this.subscriber); -1 !== n && e.splice(n, 1) } } }, ZUHj: function (t, e, n) { "use strict"; n.d(e, "a", function () { return a }); var s = n("7o/Q"); class r extends s.a { constructor(t, e, n) { super(), this.parent = t, this.outerValue = e, this.outerIndex = n, this.index = 0 } _next(t) { this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this) } _error(t) { this.parent.notifyError(t, this), this.unsubscribe() } _complete() { this.parent.notifyComplete(this), this.unsubscribe() } } var i = n("SeVD"), o = n("HDdC"); function a(t, e, n, s, a = new r(t, n, s)) { if (!a.closed) return e instanceof o.a ? e.subscribe(a) : Object(i.a)(e)(a) } }, aUTY: function (t, e, n) { "use strict"; n.d(e, "a", function () { return H }), n.d(e, "b", function () { return B }), n.d(e, "c", function () { return U }), n.d(e, "d", function () { return T }), n.d(e, "e", function () { return k }), n.d(e, "f", function () { return R }), n.d(e, "g", function () { return j }), n.d(e, "h", function () { return A }); var s = n("ofXK"), r = n("tk/3"), i = n("fXoL"), o = n("tyNb"), a = n("Q35M"), c = n("gnMq"), l = n("l7P3"), u = n("HWId"), h = n("itXk"), d = n("EY2u"), p = n("LRne"), f = n("lJxs"), g = n("/uUt"), m = n("zp1y"), b = n("vkgz"), _ = n("JIr8"); n("Se/U"), n("/Tr7"), n("jIYg"), n("piIK"), n("jKzE"); const v = ["*"]; function y(t, e) { 1 & t && (i.Xb(0, "li", 5), i.Xb(1, "a", 7), i.Sb(2, "ptrn-icon", 8), i.Xb(3, "span", 9), i.Ic(4, "JW.ORG"), i.Wb(), i.Wb(), i.Wb()), 2 & t && (i.Cb(2), i.oc("size", 24)) } function w(t, e) { if (1 & t && (i.Xb(0, "li", 5), i.Ic(1, " \xa0| "), i.Sb(2, "a", 6), i.Wb()), 2 & t) { const t = e.ngIf, n = i.hc(); i.Cb(2), i.oc("href", t, i.Dc)("ptrnTranslate", n.contactUsText || "Common_TxtContactUs") } } function C(t, e) { if (1 & t && (i.Xb(0, "p", 5), i.Ic(1), i.Wb()), 2 & t) { const t = i.hc(); i.Cb(1), i.Jc(t.displayName) } } function O(t, e) { if (1 & t && (i.Xb(0, "p", 5), i.Ic(1), i.Wb()), 2 & t) { const t = i.hc(); i.Cb(1), i.Jc(t.congregationName) } } function S(t, e) { if (1 & t && (i.Xb(0, "a", 6), i.Ic(1), i.Wb()), 2 & t) { const t = i.hc(); i.oc("href", t.jwAppsProfileUrl, i.Dc), i.Cb(1), i.Jc(t.yourAccountText) } } function x(t, e) { if (1 & t && (i.Xb(0, "a", 10), i.Ic(1, "Impersonate"), i.Wb()), 2 & t) { const t = i.hc(2); i.oc("href", t.impersonateUrl, i.Dc) } } function E(t, e) { if (1 & t && (i.Xb(0, "section", 7), i.Xb(1, "div", 8), i.Gc(2, x, 2, 1, "a", 9), i.Wb(), i.Xb(3, "aside", 8), i.Xb(4, "a", 10), i.Ic(5), i.Wb(), i.Wb(), i.Wb()), 2 & t) { const t = i.hc(); i.Cb(2), i.oc("ngIf", t.impersonationAllowed), i.Cb(2), i.oc("href", t.logoutUrl, i.Dc), i.Cb(1), i.Jc(t.logOutText) } } let T = (() => { class t { constructor(t, e) { this.store = t, this.translate = e, this.homeUrl$ = this.store.pipe(Object(l.v)(u.l)) } ngOnInit() { var t; this.translate.isEnabled || (this.linkText = null !== (t = this.linkText) && void 0 !== t ? t : "Home") } } return t.\u0275fac = function (e) { return new (e || t)(i.Rb(l.i), i.Rb(c.W)) }, t.\u0275cmp = i.Lb({ type: t, selectors: [["app-home-link"]], inputs: { linkText: "linkText" }, decls: 5, vars: 5, consts: [[1, "side-nav__context-link", 3, "href"], ["cssClass", "side-nav__context-icon", "icon", "jw-dashboard", 3, "size"]], template: function (t, e) { 1 & t && (i.Xb(0, "a", 0), i.ic(1, "async"), i.Sb(2, "ptrn-icon", 1), i.Xb(3, "ptrn-translate"), i.Ic(4), i.Wb(), i.Wb()), 2 & t && (i.oc("href", i.jc(1, 3, e.homeUrl$), i.Dc), i.Cb(2), i.oc("size", 32), i.Cb(2), i.Jc(e.linkText || "Common_LnkHome")) }, directives: [c.r, c.U], pipes: [s.b], encapsulation: 2, changeDetection: 0 }), t })(), k = (() => { class t { constructor(t, e, n) { this.window = t, this.store = e, this.translation = n, this.jwOrgLink = !0, this.year = (new Date).getFullYear(), this.languageCode$ = this.store.select(u.m).pipe(Object(f.a)(t => t.langcode)), this.contactUsUrl$ = Object(h.a)([this.languageCode$, this.store.select(u.s)]).pipe(Object(f.a)(([t, e]) => null == e ? null : `/home/api/redirect/contact-us?langCode=${t}`)), this.termsOfUseUrl$ = this.languageCode$.pipe(Object(f.a)(t => `/home/api/redirect/terms-of-use?langCode=${t}`)), this.privacyPolicyUrl$ = this.languageCode$.pipe(Object(f.a)(t => `/home/api/redirect/privacy-policy?langCode=${t}`)); const s = t.getLocation().hostname.toLowerCase(); -1 === s.indexOf("my.jw.org") && -1 === s.indexOf("my.jw-union.org") && -1 === s.indexOf("localhost") && (this.jwOrgLink = !1) } ngOnInit() { this.translation.isEnabled || (this.contactUsText = this.contactUsText || a.a.Common_TxtContactUs, this.termsOfUseText = this.termsOfUseText || a.a.Common_TxtTermsOfUse, this.privacyPolicyText = this.privacyPolicyText || a.a.Common_TxtPrivacyPolicy) } } return t.\u0275fac = function (e) { return new (e || t)(i.Rb(a.g), i.Rb(l.i), i.Rb(c.W)) }, t.\u0275cmp = i.Lb({ type: t, selectors: [["app-standard-footer"]], inputs: { contactUsText: "contactUsText", termsOfUseText: "termsOfUseText", privacyPolicyText: "privacyPolicyText" }, decls: 16, vars: 13, consts: [[1, "grid", "grid--cross-center", "grid--wrap-gutter@small", "grid--shrink", "grid--no-bleed", "padding-1"], [1, "grid__item", "grid__item--grow"], [1, "layout__footer-text"], [1, "grid__item", "grid", "grid--no-bleed", "grid--cross-center", "list", "list--inline"], ["class", "list__item", 4, "ngIf"], [1, "list__item"], ["target", "_blank", 1, "layout__footer-link", 3, "href", "ptrnTranslate"], ["href", "https://jw.org", "target", "_blank", 1, "layout__footer-link", "grid", "grid--cross-center", "grid--no-bleed"], ["icon", "logo-no-trademark", "cssClass", "p700", "aria-hidden", "true", 3, "size"], [1, "margin-left-05"]], template: function (t, e) { 1 & t && (i.Xb(0, "div", 0), i.Xb(1, "div", 1), i.Xb(2, "p", 2), i.Ic(3), i.Wb(), i.Wb(), i.Xb(4, "ul", 3), i.Gc(5, y, 5, 1, "li", 4), i.Gc(6, w, 3, 2, "li", 4), i.ic(7, "async"), i.Xb(8, "li", 5), i.Ic(9, " \xa0| "), i.Sb(10, "a", 6), i.ic(11, "async"), i.Wb(), i.Xb(12, "li", 5), i.Ic(13, " \xa0| "), i.Sb(14, "a", 6), i.ic(15, "async"), i.Wb(), i.Wb(), i.Wb()), 2 & t && (i.Cb(3), i.Kc("\xa9 ", e.year, " Watch Tower Bible and Tract Society of Pennsylvania."), i.Cb(2), i.oc("ngIf", e.jwOrgLink), i.Cb(1), i.oc("ngIf", i.jc(7, 7, e.contactUsUrl$)), i.Cb(4), i.oc("href", i.jc(11, 9, e.termsOfUseUrl$), i.Dc)("ptrnTranslate", e.termsOfUseText || "Common_TxtTermsOfUse"), i.Cb(4), i.oc("href", i.jc(15, 11, e.privacyPolicyUrl$), i.Dc)("ptrnTranslate", e.privacyPolicyText || "Common_TxtPrivacyPolicy")) }, directives: [s.o, c.U, c.r], pipes: [s.b], encapsulation: 2, changeDetection: 0 }), t })(), j = (() => { class t { constructor(t, e) { var n; this.store = t, this.config = e, this.logOutText = "Log Out", this.yourAccountText = "Your User Account", this.impersonateUrl = `${null === (n = this.config.apiBaseUrl) || void 0 === n ? void 0 : n.replace("api/", "panel/impersonate")}`, this.logoutUrl = `${this.config.apiBaseUrl}logout`, this.networkStatusOffline$ = this.store.pipe(Object(l.v)(u.o), Object(f.a)(t => null != t && t === a.e.offline)) } set user(t) { var e, n, s; if (null != t) { this.impersonationAllowed = null == this.impersonationAllowed ? null != t.impersonated : this.impersonationAllowed, this.displayName = t.displayName; const r = null === (e = t.claims) || void 0 === e ? void 0 : e.find(t => t.type === a.c.email); this.email = null != r ? r.value : "unknown e-mail"; const i = null === (n = t.claims) || void 0 === n ? void 0 : n.find(t => t.type === a.c.congregationName); this.congregationName = i ? i.value : void 0; const o = null === (s = t.claims) || void 0 === s ? void 0 : s.find(t => t.type === a.c.spiritualStatus); this.spiritualStatus = null != o ? o.value : "Unknown" } } } return t.\u0275fac = function (e) { return new (e || t)(i.Rb(l.i), i.Rb(a.b)) }, t.\u0275cmp = i.Lb({ type: t, selectors: [["app-user-profile-card"]], inputs: { logOutText: "logOutText", yourAccountText: "yourAccountText", user: "user", impersonationAllowed: "impersonationAllowed", jwAppsProfileUrl: "jwAppsProfileUrl" }, decls: 8, vars: 7, consts: [[1, "user-profile-card"], ["class", "margin-bottom-05", 4, "ngIf"], [1, "email", "text-break-word@small", "margin-bottom-05"], ["class", "button", 3, "href", 4, "ngIf"], ["class", "grid grid--main-between grid--shrink", 4, "ngIf"], [1, "margin-bottom-05"], [1, "button", 3, "href"], [1, "grid", "grid--main-between", "grid--shrink"], [1, "grid__item"], [3, "href", 4, "ngIf"], [3, "href"]], template: function (t, e) { 1 & t && (i.Xb(0, "article", 0), i.Gc(1, C, 2, 1, "p", 1), i.Xb(2, "pre", 2), i.Ic(3), i.Wb(), i.Gc(4, O, 2, 1, "p", 1), i.Gc(5, S, 2, 2, "a", 3), i.Gc(6, E, 6, 3, "section", 4), i.ic(7, "async"), i.Wb()), 2 & t && (i.Cb(1), i.oc("ngIf", !!e.displayName), i.Cb(2), i.Jc(e.email), i.Cb(1), i.oc("ngIf", !!e.congregationName), i.Cb(1), i.oc("ngIf", e.jwAppsProfileUrl), i.Cb(1), i.oc("ngIf", !1 === i.jc(7, 5, e.networkStatusOffline$))) }, directives: [s.o], pipes: [s.b], styles: [".user-profile-card[_ngcontent-%COMP%] {\n        width: calc(320px - 2rem);\n      }"], changeDetection: 0 }), t })(), A = (() => { class t { get userEmail() { if (null == this.user || null == this.user.claims) return null; const t = this.user.claims.find(t => t.type === a.c.email); return null == t ? null : t.value } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = i.Lb({ type: t, selectors: [["app-user-profile"]], inputs: { user: "user" }, ngContentSelectors: v, decls: 5, vars: 2, consts: [["click", "", "show", "false", "placement", "bottom-end"], ["aria-hidden", "true", "ptrnPopoverTarget", "", "type", "button", 1, "top-nav__secondary-item", "top-nav__secondary-item--clickable"], [3, "icon", "size"], ["ptrnPopoverContent", "", 1, "user-profile-card"]], template: function (t, e) { 1 & t && (i.nc(), i.Xb(0, "ptrn-popover", 0), i.Xb(1, "button", 1), i.Sb(2, "ptrn-icon", 2), i.Wb(), i.Xb(3, "div", 3), i.mc(4), i.Wb(), i.Wb()), 2 & t && (i.Cb(2), i.oc("icon", null != e.user && e.user.impersonated ? "impersonated" : "person")("size", 32)) }, directives: [c.E, c.F, c.r], encapsulation: 2, changeDetection: 0 }), t })(), R = (() => { class t { constructor(t, e) { this.store = t, this.toasterService = e, this.toastSequence = this.store.pipe(Object(l.v)(u.q)), this.toast$ = this.store.pipe(Object(l.v)(u.p)) } ngOnInit() { this.toastSequence.pipe(Object(g.a)(), Object(m.a)(this.toast$), Object(f.a)(([t, e]) => e), Object(b.a)(t => { null != t && this.toasterService.pop(t.type, t.title, t.body) }), Object(_.a)(t => (console.warn("Could not show toast.", t), d.a))).subscribe() } } return t.\u0275fac = function (e) { return new (e || t)(i.Rb(l.i), i.Rb(c.O)) }, t.\u0275cmp = i.Lb({ type: t, selectors: [["app-toasts"]], decls: 1, vars: 0, template: function (t, e) { 1 & t && i.Sb(0, "ptrn-toasts") }, directives: [c.P], encapsulation: 2, changeDetection: 0 }), t })(), L = (() => { class t { constructor(t) { this.config = t } intercept(t, e) { const n = this.config.apiBaseUrl; return t.url.startsWith("/") || t.url.startsWith("http://") || t.url.startsWith("https://") ? e.handle(t) : e.handle(t.clone({ url: n + t.url })) } } return t.\u0275fac = function (e) { return new (e || t)(i.bc(a.b)) }, t.\u0275prov = i.Nb({ token: t, factory: t.\u0275fac }), t })(), I = (() => { class t { constructor(t, e) { this.userConfig = t, this.languageService = e } intercept(t, e) { let n = t.headers; return n = n.set("X-Requested-With", this.userConfig.requestedWithHeader || "cdh-application").set("Accept-Language", this.languageService.currentLanguage || "en").set("Accept", "application/json"), e.handle(t.clone({ withCredentials: !0, headers: n })) } } return t.\u0275fac = function (e) { return new (e || t)(i.bc(a.b), i.bc(c.u)) }, t.\u0275prov = i.Nb({ token: t, factory: t.\u0275fac }), t })(); const P = new i.r("app.core.root.config"); function D(t) { return Object.assign(Object.assign(Object.assign({}, a.h), { isDevMode: Object(i.X)() }), t) } function M(t, e) { var n, s; return null == (null == e ? void 0 : e.audience) ? t : Object.assign(Object.assign({}, t), { localesBaseUrl: null !== (n = null == t ? void 0 : t.localesBaseUrl) && void 0 !== n ? n : "https://cdh.azureedge.net/locales/ng9/", languagesBaseUrl: null !== (s = null == t ? void 0 : t.languagesBaseUrl) && void 0 !== s ? s : "https://cdh.azureedge.net/assets/pattern/languages/v1/" }) } let N = (() => { class t extends c.v { constructor(t, e, n) { super(t, e), this.coreConfig = n } init() { return null == this.coreConfig.audience ? (console.warn("[CoreLanguagesProvider] no languages loaded because audience is not set."), Promise.resolve()) : "members" === this.coreConfig.audience ? this.loadSupportedLanguages("members.e395af70544002cc85fa85c400f3d0d22707b674.js", "sha384-EdeKNWW5TuWvcAdSOq8UR78dZbQ411DkpJYMAXOfdDuwStZsYNPnOQTY+n4KBDlw") : "bethel" === this.coreConfig.audience ? this.loadSupportedLanguages("bethel.c5d3e8772047824c849e00ce888e727fa0120efe.js", "sha384-YmIT13BxtBhUjRu7kqpWOL6BShKtLXX0cNmwrDQUlm1KjGxzT/zOgZ9c4JIWaO2G") : "internal" === this.coreConfig.audience ? this.loadSupportedLanguages("internal.f1ace2ab3186c231686dea78108bcb8bb47e293e.js", "sha384-uDTXK0v6Fv582ni00YDENImQJuwRN453UWit2kFfdxqL4UNCS3P5MqJWUvHhEay4") : (console.warn(`[CoreLanguagesProvider] audience ${this.coreConfig.audience} is not supported.`), Promise.resolve()) } } return t.\u0275fac = function (e) { return new (e || t)(i.bc(c.X), i.bc(c.z), i.bc(a.b)) }, t.\u0275prov = i.Nb({ token: t, factory: t.\u0275fac }), t })(); function F(t) { return () => t.init() } let V = (() => { class t { constructor(t, e) { this.location = t, this.config = e } init() { return this.config.baseHref = this.location.getBaseHref(), Promise.resolve(!0) } } return t.\u0275fac = function (e) { return new (e || t)(i.bc(s.k), i.bc(a.b)) }, t.\u0275prov = Object(i.Nb)({ factory: function () { return new t(Object(i.bc)(s.k), Object(i.bc)(a.b)) }, token: t, providedIn: "root" }), t })(), B = (() => { class t { static forRoot(e) { return { ngModule: t, providers: [{ provide: P, useValue: e }, { provide: a.b, useFactory: D, deps: [P] }, { provide: c.z, useFactory: M, deps: [c.A, P] }, null != (null == e ? void 0 : e.audience) ? { provide: c.v, useClass: N } : [], { provide: i.d, useFactory: F, deps: [V], multi: !0 }, { provide: r.a, useClass: L, multi: !0 }, { provide: r.a, useClass: I, deps: [a.b, c.u], multi: !0 }] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = i.Pb({ type: t }), t.\u0275inj = i.Ob({ imports: [[s.c, o.l, c.C, c.D]] }), t })(); class U { constructor(t, e) { this.httpClient = t, this.config = e, this.localEnFile = `${e.assetsBaseUrl}i18n/en.json`, this.transformMarkers = !1 !== e.transformMarkers } getTranslation(t) { return this.httpClient.get("en" === t ? this.localEnFile : `${this.config.prefix || ""}${t}${this.config.suffix || ""}`).pipe(Object(f.a)(t => { if (this.transformMarkers) for (const e in t) t.hasOwnProperty(e) && (t[e] = t[e].replace(/%([0-9]+)\$s/g, "{{$1}}")); return t }), Object(_.a)(e => (console.warn(`CoreTranslateLoader: error loading translations for [${t}]`, e), Object(p.a)({})))) } } class H { handle(t) { var e; let n = null !== (e = a.a[t.key]) && void 0 !== e ? e : t.key; return null != t.interpolateParams && (n = t.translateService.parser.interpolate(n, t.interpolateParams)), n } } }, agSv: function (module, __webpack_exports__, __webpack_require__) { "use strict"; __webpack_require__.d(__webpack_exports__, "a", function () { return StoreDevtoolsModule }); var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fXoL"), _ngrx_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("l7P3"), rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("EY2u"), rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("HDdC"), rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("LRne"), rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("VRyK"), rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("qgXg"), rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("jtHE"), rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("w1tV"), rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("pLZG"), rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("lJxs"), rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("bOdf"), rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("tS1D"), rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("Kj3r"), rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("JIr8"), rxjs_operators__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("IzEk"), rxjs_operators__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("1G5W"), rxjs_operators__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("eIep"), rxjs_operators__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("zP0r"), rxjs_operators__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("pxpQ"), rxjs_operators__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("zp1y"), rxjs_operators__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("Kqap"); class StoreDevtoolsConfig { constructor() { this.maxAge = !1 } } const STORE_DEVTOOLS_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.r("@ngrx/store-devtools Options"), INITIAL_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.r("@ngrx/store-devtools Initial Config"); function noMonitor() { return null } const DEFAULT_NAME = "NgRx Store DevTools"; function createConfig(t) { const e = { maxAge: !1, monitor: noMonitor, actionSanitizer: void 0, stateSanitizer: void 0, name: DEFAULT_NAME, serialize: !1, logOnly: !1, features: { pause: !0, lock: !0, persist: !0, export: !0, import: "custom", jump: !0, skip: !0, reorder: !0, dispatch: !0, test: !0 } }; let n = "function" == typeof t ? t() : t; const s = Object.assign({}, e, { features: n.features || !!n.logOnly && { pause: !0, export: !0, test: !0 } || e.features }, n); if (s.maxAge && s.maxAge < 2) throw new Error(`Devtools 'maxAge' cannot be less than 2, got ${s.maxAge}`); return s } const PERFORM_ACTION = "PERFORM_ACTION", REFRESH = "REFRESH", RESET = "RESET", ROLLBACK = "ROLLBACK", COMMIT = "COMMIT", SWEEP = "SWEEP", TOGGLE_ACTION = "TOGGLE_ACTION", SET_ACTIONS_ACTIVE = "SET_ACTIONS_ACTIVE", JUMP_TO_STATE = "JUMP_TO_STATE", JUMP_TO_ACTION = "JUMP_TO_ACTION", IMPORT_STATE = "IMPORT_STATE", LOCK_CHANGES = "LOCK_CHANGES", PAUSE_RECORDING = "PAUSE_RECORDING"; class PerformAction { constructor(t, e) { if (this.action = t, this.timestamp = e, this.type = PERFORM_ACTION, void 0 === t.type) throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?') } } class Refresh { constructor() { this.type = REFRESH } } class Reset { constructor(t) { this.timestamp = t, this.type = RESET } } class Rollback { constructor(t) { this.timestamp = t, this.type = ROLLBACK } } class Commit { constructor(t) { this.timestamp = t, this.type = COMMIT } } class Sweep { constructor() { this.type = SWEEP } } class ToggleAction { constructor(t) { this.id = t, this.type = TOGGLE_ACTION } } class SetActionsActive { constructor(t, e, n = !0) { this.start = t, this.end = e, this.active = n, this.type = SET_ACTIONS_ACTIVE } } class JumpToState { constructor(t) { this.index = t, this.type = JUMP_TO_STATE } } class JumpToAction { constructor(t) { this.actionId = t, this.type = JUMP_TO_ACTION } } class ImportState { constructor(t) { this.nextLiftedState = t, this.type = IMPORT_STATE } } class LockChanges { constructor(t) { this.status = t, this.type = LOCK_CHANGES } } class PauseRecording { constructor(t) { this.status = t, this.type = PAUSE_RECORDING } } let DevtoolsDispatcher = (() => { class t extends _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.b { } return t.\u0275fac = function (e) { return \u0275DevtoolsDispatcher_BaseFactory(e || t) }, t.\u0275prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Nb({ token: t, factory: t.\u0275fac }), t })(); const \u0275DevtoolsDispatcher_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Zb(DevtoolsDispatcher); function difference(t, e) { return t.filter(t => e.indexOf(t) < 0) } function unliftState(t) { const { computedStates: e, currentStateIndex: n } = t; if (n >= e.length) { const { state: t } = e[e.length - 1]; return t } const { state: s } = e[n]; return s } function unliftAction(t) { return t.actionsById[t.nextActionId - 1] } function liftAction(t) { return new PerformAction(t, +Date.now()) } function sanitizeActions(t, e) { return Object.keys(e).reduce((n, s) => { const r = Number(s); return n[r] = sanitizeAction(t, e[r], r), n }, {}) } function sanitizeAction(t, e, n) { return Object.assign(Object.assign({}, e), { action: t(e.action, n) }) } function sanitizeStates(t, e) { return e.map((e, n) => ({ state: sanitizeState(t, e.state, n), error: e.error })) } function sanitizeState(t, e, n) { return t(e, n) } function shouldFilterActions(t) { return t.predicate || t.actionsSafelist || t.actionsBlocklist } function filterLiftedState(t, e, n, s) { const r = [], i = {}, o = []; return t.stagedActionIds.forEach((a, c) => { const l = t.actionsById[a]; l && (c && isActionFiltered(t.computedStates[c], l, e, n, s) || (i[a] = l, r.push(a), o.push(t.computedStates[c]))) }), Object.assign(Object.assign({}, t), { stagedActionIds: r, actionsById: i, computedStates: o }) } function isActionFiltered(t, e, n, s, r) { const i = n && !n(t, e.action), o = s && !e.action.type.match(s.map(t => escapeRegExp(t)).join("|")), a = r && e.action.type.match(r.map(t => escapeRegExp(t)).join("|")); return i || o || a } function escapeRegExp(t) { return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") } const ExtensionActionTypes = { START: "START", DISPATCH: "DISPATCH", STOP: "STOP", ACTION: "ACTION" }, REDUX_DEVTOOLS_EXTENSION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.r("@ngrx/store-devtools Redux Devtools Extension"); let DevtoolsExtension = (() => { class DevtoolsExtension { constructor(t, e, n) { this.config = e, this.dispatcher = n, this.devtoolsExtension = t, this.createActionStreams() } notify(t, e) { if (this.devtoolsExtension) if (t.type === PERFORM_ACTION) { if (e.isLocked || e.isPaused) return; const n = unliftState(e); if (shouldFilterActions(this.config) && isActionFiltered(n, t, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) return; const s = this.config.stateSanitizer ? sanitizeState(this.config.stateSanitizer, n, e.currentStateIndex) : n, r = this.config.actionSanitizer ? sanitizeAction(this.config.actionSanitizer, t, e.nextActionId) : t; this.sendToReduxDevtools(() => this.extensionConnection.send(r, s)) } else { const t = Object.assign(Object.assign({}, e), { stagedActionIds: e.stagedActionIds, actionsById: this.config.actionSanitizer ? sanitizeActions(this.config.actionSanitizer, e.actionsById) : e.actionsById, computedStates: this.config.stateSanitizer ? sanitizeStates(this.config.stateSanitizer, e.computedStates) : e.computedStates }); this.sendToReduxDevtools(() => this.devtoolsExtension.send(null, t, this.getExtensionConfig(this.config))) } } createChangesObservable() { return this.devtoolsExtension ? new rxjs__WEBPACK_IMPORTED_MODULE_3__.a(t => { const e = this.devtoolsExtension.connect(this.getExtensionConfig(this.config)); return this.extensionConnection = e, e.init(), e.subscribe(e => t.next(e)), e.unsubscribe }) : rxjs__WEBPACK_IMPORTED_MODULE_2__.a } createActionStreams() { const t = this.createChangesObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.a)()), e = t.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.a)(t => t.type === ExtensionActionTypes.START)), n = t.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.a)(t => t.type === ExtensionActionTypes.STOP)), s = t.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.a)(t => t.type === ExtensionActionTypes.DISPATCH), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)(t => this.unwrapAction(t.payload)), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.a)(t => t.type === IMPORT_STATE ? this.dispatcher.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.a)(t => t.type === _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.m), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.a)(1e3), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.a)(1e3), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)(() => t), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__.a)(() => Object(rxjs__WEBPACK_IMPORTED_MODULE_4__.a)(t)), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_15__.a)(1)) : Object(rxjs__WEBPACK_IMPORTED_MODULE_4__.a)(t))), r = t.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.a)(t => t.type === ExtensionActionTypes.ACTION), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)(t => this.unwrapAction(t.payload))).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.a)(n)), i = s.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.a)(n)); this.start$ = e.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_16__.a)(n)), this.actions$ = this.start$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_17__.a)(() => r)), this.liftedActions$ = this.start$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_17__.a)(() => i)) } unwrapAction(action) { return "string" == typeof action ? eval(`(${action})`) : action } getExtensionConfig(t) { const e = { name: t.name, features: t.features, serialize: t.serialize }; return !1 !== t.maxAge && (e.maxAge = t.maxAge), e } sendToReduxDevtools(t) { try { t() } catch (e) { console.warn("@ngrx/store-devtools: something went wrong inside the redux devtools", e) } } } return DevtoolsExtension.\u0275fac = function (t) { return new (t || DevtoolsExtension)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.bc(REDUX_DEVTOOLS_EXTENSION), _angular_core__WEBPACK_IMPORTED_MODULE_0__.bc(STORE_DEVTOOLS_CONFIG), _angular_core__WEBPACK_IMPORTED_MODULE_0__.bc(DevtoolsDispatcher)) }, DevtoolsExtension.\u0275prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Nb({ token: DevtoolsExtension, factory: DevtoolsExtension.\u0275fac }), DevtoolsExtension })(); const INIT_ACTION = { type: _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.c }, RECOMPUTE = "@ngrx/store-devtools/recompute", RECOMPUTE_ACTION = { type: RECOMPUTE }; function computeNextEntry(t, e, n, s, r) { if (s) return { state: n, error: "Interrupted by an error up the chain" }; let i, o = n; try { o = t(n, e) } catch (a) { i = a.toString(), r.handleError(a) } return { state: o, error: i } } function recomputeStates(t, e, n, s, r, i, o, a, c) { if (e >= t.length && t.length === i.length) return t; const l = t.slice(0, e), u = i.length - (c ? 1 : 0); for (let h = e; h < u; h++) { const t = i[h], e = r[t].action, c = l[h - 1], u = c ? c.state : s, d = c ? c.error : void 0, p = o.indexOf(t) > -1 ? c : computeNextEntry(n, e, u, d, a); l.push(p) } return c && l.push(t[t.length - 1]), l } function liftInitialState(t, e) { return { monitorState: e(void 0, {}), nextActionId: 1, actionsById: { 0: liftAction(INIT_ACTION) }, stagedActionIds: [0], skippedActionIds: [], committedState: t, currentStateIndex: 0, computedStates: [], isLocked: !1, isPaused: !1 } } function liftReducerWith(t, e, n, s, r = {}) { return i => (o, a) => { let { monitorState: c, actionsById: l, nextActionId: u, stagedActionIds: h, skippedActionIds: d, committedState: p, currentStateIndex: f, computedStates: g, isLocked: m, isPaused: b } = o || e; function _(t) { let e = t, n = h.slice(1, e + 1); for (let s = 0; s < n.length; s++) { if (g[s + 1].error) { e = s, n = h.slice(1, e + 1); break } delete l[n[s]] } d = d.filter(t => -1 === n.indexOf(t)), h = [0, ...h.slice(e + 1)], p = g[e].state, g = g.slice(e), f = f > e ? f - e : 0 } function v() { l = { 0: liftAction(INIT_ACTION) }, u = 1, h = [0], d = [], p = g[f].state, f = 0, g = [] } o || (l = Object.create(l)); let y = 0; switch (a.type) { case LOCK_CHANGES: m = a.status, y = 1 / 0; break; case PAUSE_RECORDING: b = a.status, b ? (h = [...h, u], l[u] = new PerformAction({ type: "@ngrx/devtools/pause" }, +Date.now()), u++, y = h.length - 1, g = g.concat(g[g.length - 1]), f === h.length - 2 && f++, y = 1 / 0) : v(); break; case RESET: l = { 0: liftAction(INIT_ACTION) }, u = 1, h = [0], d = [], p = t, f = 0, g = []; break; case COMMIT: v(); break; case ROLLBACK: l = { 0: liftAction(INIT_ACTION) }, u = 1, h = [0], d = [], f = 0, g = []; break; case TOGGLE_ACTION: { const { id: t } = a, e = d.indexOf(t); d = -1 === e ? [t, ...d] : d.filter(e => e !== t), y = h.indexOf(t); break } case SET_ACTIONS_ACTIVE: { const { start: t, end: e, active: n } = a, s = []; for (let r = t; r < e; r++)s.push(r); d = n ? difference(d, s) : [...d, ...s], y = h.indexOf(t); break } case JUMP_TO_STATE: f = a.index, y = 1 / 0; break; case JUMP_TO_ACTION: { const t = h.indexOf(a.actionId); -1 !== t && (f = t), y = 1 / 0; break } case SWEEP: h = difference(h, d), d = [], f = Math.min(f, h.length - 1); break; case PERFORM_ACTION: { if (m) return o || e; if (b || o && isActionFiltered(o.computedStates[f], a, r.predicate, r.actionsSafelist, r.actionsBlocklist)) { const t = g[g.length - 1]; g = [...g.slice(0, -1), computeNextEntry(i, a.action, t.state, t.error, n)], y = 1 / 0; break } r.maxAge && h.length === r.maxAge && _(1), f === h.length - 1 && f++; const t = u++; l[t] = a, h = [...h, t], y = h.length - 1; break } case IMPORT_STATE: ({ monitorState: c, actionsById: l, nextActionId: u, stagedActionIds: h, skippedActionIds: d, committedState: p, currentStateIndex: f, computedStates: g, isLocked: m, isPaused: b } = a.nextLiftedState); break; case _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.c: y = 0, r.maxAge && h.length > r.maxAge && (g = recomputeStates(g, y, i, p, l, h, d, n, b), _(h.length - r.maxAge), y = 1 / 0); break; case _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.m: if (g.filter(t => t.error).length > 0) y = 0, r.maxAge && h.length > r.maxAge && (g = recomputeStates(g, y, i, p, l, h, d, n, b), _(h.length - r.maxAge), y = 1 / 0); else { if (!b && !m) { f === h.length - 1 && f++; const t = u++; l[t] = new PerformAction(a, +Date.now()), h = [...h, t], y = h.length - 1, g = recomputeStates(g, y, i, p, l, h, d, n, b) } g = g.map(t => Object.assign(Object.assign({}, t), { state: i(t.state, RECOMPUTE_ACTION) })), f = h.length - 1, r.maxAge && h.length > r.maxAge && _(h.length - r.maxAge), y = 1 / 0 } break; default: y = 1 / 0 }return g = recomputeStates(g, y, i, p, l, h, d, n, b), c = s(c, a), { monitorState: c, actionsById: l, nextActionId: u, stagedActionIds: h, skippedActionIds: d, committedState: p, currentStateIndex: f, computedStates: g, isLocked: m, isPaused: b } } } let StoreDevtools = (() => { class t { constructor(t, e, n, s, r, i, o, a) { const c = liftInitialState(o, a.monitor), l = liftReducerWith(o, c, i, a.monitor, a), u = Object(rxjs__WEBPACK_IMPORTED_MODULE_5__.a)(Object(rxjs__WEBPACK_IMPORTED_MODULE_5__.a)(e.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_18__.a)(1)), s.actions$).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)(liftAction)), t, s.liftedActions$).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_19__.b)(rxjs__WEBPACK_IMPORTED_MODULE_6__.b)), h = n.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)(l)), d = new rxjs__WEBPACK_IMPORTED_MODULE_7__.a(1), p = u.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_20__.a)(h), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_21__.a)(({ state: t }, [e, n]) => { let r = n(t, e); return e.type !== PERFORM_ACTION && shouldFilterActions(a) && (r = filterLiftedState(r, a.predicate, a.actionsSafelist, a.actionsBlocklist)), s.notify(e, r), { state: r, action: e } }, { state: c, action: null })).subscribe(({ state: t, action: e }) => { d.next(t), e.type === PERFORM_ACTION && r.next(e.action) }), f = s.start$.subscribe(() => { this.refresh() }), g = d.asObservable(), m = g.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.a)(unliftState)); this.extensionStartSubscription = f, this.stateSubscription = p, this.dispatcher = t, this.liftedState = g, this.state = m } dispatch(t) { this.dispatcher.next(t) } next(t) { this.dispatcher.next(t) } error(t) { } complete() { } performAction(t) { this.dispatch(new PerformAction(t, +Date.now())) } refresh() { this.dispatch(new Refresh) } reset() { this.dispatch(new Reset(+Date.now())) } rollback() { this.dispatch(new Rollback(+Date.now())) } commit() { this.dispatch(new Commit(+Date.now())) } sweep() { this.dispatch(new Sweep) } toggleAction(t) { this.dispatch(new ToggleAction(t)) } jumpToAction(t) { this.dispatch(new JumpToAction(t)) } jumpToState(t) { this.dispatch(new JumpToState(t)) } importState(t) { this.dispatch(new ImportState(t)) } lockChanges(t) { this.dispatch(new LockChanges(t)) } pauseRecording(t) { this.dispatch(new PauseRecording(t)) } } return t.\u0275fac = function (e) { return new (e || t)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.bc(DevtoolsDispatcher), _angular_core__WEBPACK_IMPORTED_MODULE_0__.bc(_ngrx_store__WEBPACK_IMPORTED_MODULE_1__.b), _angular_core__WEBPACK_IMPORTED_MODULE_0__.bc(_ngrx_store__WEBPACK_IMPORTED_MODULE_1__.f), _angular_core__WEBPACK_IMPORTED_MODULE_0__.bc(DevtoolsExtension), _angular_core__WEBPACK_IMPORTED_MODULE_0__.bc(_ngrx_store__WEBPACK_IMPORTED_MODULE_1__.g), _angular_core__WEBPACK_IMPORTED_MODULE_0__.bc(_angular_core__WEBPACK_IMPORTED_MODULE_0__.m), _angular_core__WEBPACK_IMPORTED_MODULE_0__.bc(_ngrx_store__WEBPACK_IMPORTED_MODULE_1__.d), _angular_core__WEBPACK_IMPORTED_MODULE_0__.bc(STORE_DEVTOOLS_CONFIG)) }, t.\u0275prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Nb({ token: t, factory: t.\u0275fac }), t })(); const IS_EXTENSION_OR_MONITOR_PRESENT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.r("@ngrx/store-devtools Is Devtools Extension or Monitor Present"); function createIsExtensionOrMonitorPresent(t, e) { return Boolean(t) || e.monitor !== noMonitor } function createReduxDevtoolsExtension() { return "object" == typeof window && void 0 !== window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : null } function createStateObservable(t) { return t.state } let StoreDevtoolsModule = (() => { class t { static instrument(e = {}) { return { ngModule: t, providers: [DevtoolsExtension, DevtoolsDispatcher, StoreDevtools, { provide: INITIAL_OPTIONS, useValue: e }, { provide: IS_EXTENSION_OR_MONITOR_PRESENT, deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG], useFactory: createIsExtensionOrMonitorPresent }, { provide: REDUX_DEVTOOLS_EXTENSION, useFactory: createReduxDevtoolsExtension }, { provide: STORE_DEVTOOLS_CONFIG, deps: [INITIAL_OPTIONS], useFactory: createConfig }, { provide: _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.h, deps: [StoreDevtools], useFactory: createStateObservable }, { provide: _ngrx_store__WEBPACK_IMPORTED_MODULE_1__.e, useExisting: DevtoolsDispatcher }] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb({ type: t }), t.\u0275inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__.Ob({}), t })() }, bHdf: function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }); var s = n("5+tZ"), r = n("SpAZ"); function i(t = Number.POSITIVE_INFINITY) { return Object(s.a)(r.a, t) } }, bOdf: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("5+tZ"); function r(t, e) { return Object(s.a)(t, e, 1) } }, c2HN: function (t, e, n) { "use strict"; function s(t) { return !!t && "function" != typeof t.subscribe && "function" == typeof t.then } n.d(e, "a", function () { return s }) }, cp0P: function (t, e, n) { "use strict"; n.d(e, "a", function () { return c }); var s = n("HDdC"), r = n("DH7j"), i = n("lJxs"), o = n("XoHu"), a = n("Cfvw"); function c(...t) { if (1 === t.length) { const e = t[0]; if (Object(r.a)(e)) return l(e, null); if (Object(o.a)(e) && Object.getPrototypeOf(e) === Object.prototype) { const t = Object.keys(e); return l(t.map(t => e[t]), t) } } if ("function" == typeof t[t.length - 1]) { const e = t.pop(); return l(t = 1 === t.length && Object(r.a)(t[0]) ? t[0] : t, null).pipe(Object(i.a)(t => e(...t))) } return l(t, null) } function l(t, e) { return new s.a(n => { const s = t.length; if (0 === s) return void n.complete(); const r = new Array(s); let i = 0, o = 0; for (let c = 0; c < s; c++) { const l = Object(a.a)(t[c]); let u = !1; n.add(l.subscribe({ next: t => { u || (u = !0, o++), r[c] = t }, error: t => n.error(t), complete: () => { i++, i !== s && u || (o === s && n.next(e ? e.reduce((t, e, n) => (t[e] = r[n], t), {}) : r), n.complete()) } })) } }) } }, eIep: function (t, e, n) { "use strict"; n.d(e, "a", function () { return o }); var s = n("lJxs"), r = n("Cfvw"), i = n("zx2A"); function o(t, e) { return "function" == typeof e ? n => n.pipe(o((n, i) => Object(r.a)(t(n, i)).pipe(Object(s.a)((t, s) => e(n, t, i, s))))) : e => e.lift(new a(t)) } class a { constructor(t) { this.project = t } call(t, e) { return e.subscribe(new c(t, this.project)) } } class c extends i.b { constructor(t, e) { super(t), this.project = e, this.index = 0 } _next(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (s) { return void this.destination.error(s) } this._innerSub(e) } _innerSub(t) { const e = this.innerSubscription; e && e.unsubscribe(); const n = new i.a(this), s = this.destination; s.add(n), this.innerSubscription = Object(i.c)(t, n), this.innerSubscription !== n && s.add(this.innerSubscription) } _complete() { const { innerSubscription: t } = this; t && !t.closed || super._complete(), this.unsubscribe() } _unsubscribe() { this.innerSubscription = void 0 } notifyComplete() { this.innerSubscription = void 0, this.isStopped && super._complete() } notifyNext(t) { this.destination.next(t) } } }, fXoL: function (t, e, n) { "use strict"; n.d(e, "a", function () { return nn }), n.d(e, "b", function () { return cl }), n.d(e, "c", function () { return sl }), n.d(e, "d", function () { return el }), n.d(e, "e", function () { return nl }), n.d(e, "f", function () { return eu }), n.d(e, "g", function () { return Wl }), n.d(e, "h", function () { return $a }), n.d(e, "i", function () { return vl }), n.d(e, "j", function () { return fa }), n.d(e, "k", function () { return hl }), n.d(e, "l", function () { return _a }), n.d(e, "m", function () { return ws }), n.d(e, "n", function () { return Pc }), n.d(e, "o", function () { return ui }), n.d(e, "p", function () { return On }), n.d(e, "q", function () { return j }), n.d(e, "r", function () { return en }), n.d(e, "s", function () { return Ei }), n.d(e, "t", function () { return Na }), n.d(e, "u", function () { return Va }), n.d(e, "v", function () { return ul }), n.d(e, "w", function () { return ec }), n.d(e, "x", function () { return Gl }), n.d(e, "y", function () { return tc }), n.d(e, "z", function () { return Bl }), n.d(e, "A", function () { return Cl }), n.d(e, "B", function () { return Sn }), n.d(e, "C", function () { return al }), n.d(e, "D", function () { return ol }), n.d(e, "E", function () { return Mc }), n.d(e, "F", function () { return wa }), n.d(e, "G", function () { return ya }), n.d(e, "H", function () { return Ts }), n.d(e, "I", function () { return Oa }), n.d(e, "J", function () { return fs }), n.d(e, "K", function () { return xn }), n.d(e, "L", function () { return En }), n.d(e, "M", function () { return Zl }), n.d(e, "N", function () { return Za }), n.d(e, "O", function () { return jl }), n.d(e, "P", function () { return sn }), n.d(e, "Q", function () { return Sa }), n.d(e, "R", function () { return sc }), n.d(e, "S", function () { return D }), n.d(e, "T", function () { return Ul }), n.d(e, "U", function () { return Fl }), n.d(e, "V", function () { return p }), n.d(e, "W", function () { return yn }), n.d(e, "X", function () { return Nl }), n.d(e, "Y", function () { return Jl }), n.d(e, "Z", function () { return Ll }), n.d(e, "ab", function () { return ll }), n.d(e, "bb", function () { return di }), n.d(e, "cb", function () { return ea }), n.d(e, "db", function () { return ds }), n.d(e, "eb", function () { return Kn }), n.d(e, "fb", function () { return Fn }), n.d(e, "gb", function () { return Bn }), n.d(e, "hb", function () { return $n }), n.d(e, "ib", function () { return Hn }), n.d(e, "jb", function () { return Un }), n.d(e, "kb", function () { return zn }), n.d(e, "lb", function () { return Yo }), n.d(e, "mb", function () { return Ql }), n.d(e, "nb", function () { return Qo }), n.d(e, "ob", function () { return Jo }), n.d(e, "pb", function () { return Vn }), n.d(e, "qb", function () { return B }), n.d(e, "rb", function () { return Mi }), n.d(e, "sb", function () { return ao }), n.d(e, "tb", function () { return io }), n.d(e, "ub", function () { return oo }), n.d(e, "vb", function () { return Zo }), n.d(e, "wb", function () { return Ot }), n.d(e, "xb", function () { return u }), n.d(e, "yb", function () { return Nn }), n.d(e, "zb", function () { return ki }), n.d(e, "Ab", function () { return bt }), n.d(e, "Bb", function () { return ha }), n.d(e, "Cb", function () { return pr }), n.d(e, "Db", function () { return Hi }), n.d(e, "Eb", function () { return Wi }), n.d(e, "Fb", function () { return qi }), n.d(e, "Gb", function () { return To }), n.d(e, "Hb", function () { return $o }), n.d(e, "Ib", function () { return Wo }), n.d(e, "Jb", function () { return Eo }), n.d(e, "Kb", function () { return Xc }), n.d(e, "Lb", function () { return Q }), n.d(e, "Mb", function () { return it }), n.d(e, "Nb", function () { return y }), n.d(e, "Ob", function () { return w }), n.d(e, "Pb", function () { return nt }), n.d(e, "Qb", function () { return ot }), n.d(e, "Rb", function () { return Ki }), n.d(e, "Sb", function () { return to }), n.d(e, "Tb", function () { return so }), n.d(e, "Ub", function () { return no }), n.d(e, "Vb", function () { return eo }), n.d(e, "Wb", function () { return Ji }), n.d(e, "Xb", function () { return Qi }), n.d(e, "Yb", function () { return ro }), n.d(e, "Zb", function () { return Ye }), n.d(e, "ac", function () { return qo }), n.d(e, "bc", function () { return vn }), n.d(e, "cc", function () { return Je }), n.d(e, "dc", function () { return tl }), n.d(e, "ec", function () { return co }), n.d(e, "fc", function () { return Kc }), n.d(e, "gc", function () { return me }), n.d(e, "hc", function () { return ho }), n.d(e, "ic", function () { return Tc }), n.d(e, "jc", function () { return kc }), n.d(e, "kc", function () { return jc }), n.d(e, "lc", function () { return Ac }), n.d(e, "mc", function () { return go }), n.d(e, "nc", function () { return fo }), n.d(e, "oc", function () { return Zi }), n.d(e, "pc", function () { return mo }), n.d(e, "qc", function () { return bo }), n.d(e, "rc", function () { return _o }), n.d(e, "sc", function () { return _c }), n.d(e, "tc", function () { return vc }), n.d(e, "uc", function () { return yc }), n.d(e, "vc", function () { return wc }), n.d(e, "wc", function () { return Cc }), n.d(e, "xc", function () { return qc }), n.d(e, "yc", function () { return Xi }), n.d(e, "zc", function () { return xs }), n.d(e, "Ac", function () { return Ss }), n.d(e, "Bc", function () { return zt }), n.d(e, "Cc", function () { return gs }), n.d(e, "Dc", function () { return ms }), n.d(e, "Ec", function () { return st }), n.d(e, "Fc", function () { return xo }), n.d(e, "Gc", function () { return Gi }), n.d(e, "Hc", function () { return Jc }), n.d(e, "Ic", function () { return Vo }), n.d(e, "Jc", function () { return Bo }), n.d(e, "Kc", function () { return Uo }), n.d(e, "Lc", function () { return Ho }), n.d(e, "Mc", function () { return zo }), n.d(e, "Nc", function () { return Gc }); var s = n("XNiG"), r = n("quSY"), i = n("HDdC"), o = n("VRyK"), a = n("w1tV"); function c(t) { for (let e in t) if (t[e] === c) return e; throw Error("Could not find renamed property on target object.") } function l(t, e) { for (const n in e) e.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = e[n]) } function u(t) { if ("string" == typeof t) return t; if (Array.isArray(t)) return "[" + t.map(u).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return `${t.overriddenName}`; if (t.name) return `${t.name}`; const e = t.toString(); if (null == e) return "" + e; const n = e.indexOf("\n"); return -1 === n ? e : e.substring(0, n) } function h(t, e) { return null == t || "" === t ? null === e ? "" : e : null == e || "" === e ? t : t + " " + e } const d = c({ __forward_ref__: c }); function p(t) { return t.__forward_ref__ = p, t.toString = function () { return u(this()) }, t } function f(t) { return g(t) ? t() : t } function g(t) { return "function" == typeof t && t.hasOwnProperty(d) && t.__forward_ref__ === p } class m extends Error { constructor(t, e) { super(function (t, e) { return `${t ? `NG0${t}: ` : ""}${e}` }(t, e)), this.code = t } } function b(t) { return "string" == typeof t ? t : null == t ? "" : String(t) } function _(t) { return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : b(t) } function v(t, e) { const n = e ? ` in ${e}` : ""; throw new m("201", `No provider for ${_(t)} found${n}`) } function y(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function w(t) { return { providers: t.providers || [], imports: t.imports || [] } } function C(t) { return O(t, x) || O(t, T) } function O(t, e) { return t.hasOwnProperty(e) ? t[e] : null } function S(t) { return t && (t.hasOwnProperty(E) || t.hasOwnProperty(k)) ? t[E] : null } const x = c({ "\u0275prov": c }), E = c({ "\u0275inj": c }), T = c({ ngInjectableDef: c }), k = c({ ngInjectorDef: c }); var j = function (t) { return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t }({}); let A; function R(t) { const e = A; return A = t, e } function L(t, e, n) { const s = C(t); return s && "root" == s.providedIn ? void 0 === s.value ? s.value = s.factory() : s.value : n & j.Optional ? null : void 0 !== e ? e : void v(u(t), "Injector") } function I(t) { return { toString: t }.toString() } var P = function (t) { return t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default", t }({}), D = function (t) { return t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", t }({}); const M = "undefined" != typeof globalThis && globalThis, N = "undefined" != typeof window && window, F = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, V = "undefined" != typeof global && global, B = M || V || N || F, U = {}, H = [], z = [], $ = c({ "\u0275cmp": c }), W = c({ "\u0275dir": c }), q = c({ "\u0275pipe": c }), G = c({ "\u0275mod": c }), X = c({ "\u0275loc": c }), K = c({ "\u0275fac": c }), Z = c({ __NG_ELEMENT_ID__: c }); let Y = 0; function Q(t) { return I(() => { const e = {}, n = { type: t.type, providersResolver: null, decls: t.decls, vars: t.vars, factory: null, template: t.template || null, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: e, inputs: null, outputs: null, exportAs: t.exportAs || null, onPush: t.changeDetection === P.OnPush, directiveDefs: null, pipeDefs: null, selectors: t.selectors || z, viewQuery: t.viewQuery || null, features: t.features || null, data: t.data || {}, encapsulation: t.encapsulation || D.Emulated, id: "c", styles: t.styles || z, _: null, setInput: null, schemas: t.schemas || null, tView: null }, s = t.directives, r = t.features, i = t.pipes; return n.id += Y++, n.inputs = rt(t.inputs, e), n.outputs = rt(t.outputs), r && r.forEach(t => t(n)), n.directiveDefs = s ? () => ("function" == typeof s ? s() : s).map(J) : null, n.pipeDefs = i ? () => ("function" == typeof i ? i() : i).map(tt) : null, n }) } function J(t) { return at(t) || function (t) { return t[W] || null }(t) } function tt(t) { return function (t) { return t[q] || null }(t) } const et = {}; function nt(t) { const e = { type: t.type, bootstrap: t.bootstrap || z, declarations: t.declarations || z, imports: t.imports || z, exports: t.exports || z, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null }; return null != t.id && I(() => { et[t.id] = t.type }), e } function st(t, e) { return I(() => { const n = ct(t, !0); n.declarations = e.declarations || z, n.imports = e.imports || z, n.exports = e.exports || z }) } function rt(t, e) { if (null == t) return U; const n = {}; for (const s in t) if (t.hasOwnProperty(s)) { let r = t[s], i = r; Array.isArray(r) && (i = r[1], r = r[0]), n[r] = s, e && (e[r] = i) } return n } const it = Q; function ot(t) { return { type: t.type, name: t.name, factory: null, pure: !1 !== t.pure, onDestroy: t.type.prototype.ngOnDestroy || null } } function at(t) { return t[$] || null } function ct(t, e) { const n = t[G] || null; if (!n && !0 === e) throw new Error(`Type ${u(t)} does not have '\u0275mod' property.`); return n } function lt(t) { return Array.isArray(t) && "object" == typeof t[1] } function ut(t) { return Array.isArray(t) && !0 === t[1] } function ht(t) { return 0 != (8 & t.flags) } function dt(t) { return 2 == (2 & t.flags) } function pt(t) { return 1 == (1 & t.flags) } function ft(t) { return null !== t.template } function gt(t, e) { return t.hasOwnProperty(K) ? t[K] : null } class mt { constructor(t, e, n) { this.previousValue = t, this.currentValue = e, this.firstChange = n } isFirstChange() { return this.firstChange } } function bt() { return _t } function _t(t) { return t.type.prototype.ngOnChanges && (t.setInput = yt), vt } function vt() { const t = wt(this), e = null == t ? void 0 : t.current; if (e) { const n = t.previous; if (n === U) t.previous = e; else for (let t in e) n[t] = e[t]; t.current = null, this.ngOnChanges(e) } } function yt(t, e, n, s) { const r = wt(t) || function (t, e) { return t.__ngSimpleChanges__ = e }(t, { previous: U, current: null }), i = r.current || (r.current = {}), o = r.previous, a = this.declaredInputs[n], c = o[a]; i[a] = new mt(c && c.currentValue, e, o === U), t[s] = e } function wt(t) { return t.__ngSimpleChanges__ || null } let Ct; function Ot(t) { Ct = t } function St() { return void 0 !== Ct ? Ct : "undefined" != typeof document ? document : void 0 } function xt(t) { return !!t.listen } bt.ngInherit = !0; const Et = { createRenderer: (t, e) => St() }; function Tt(t) { for (; Array.isArray(t);)t = t[0]; return t } function kt(t, e) { return Tt(e[t]) } function jt(t, e) { return Tt(e[t.index]) } function At(t, e) { return t.data[e] } function Rt(t, e) { return t[e] } function Lt(t, e) { const n = e[t]; return lt(n) ? n : n[0] } function It(t) { const e = function (t) { return t.__ngContext__ || null }(t); return e ? Array.isArray(e) ? e : e.lView : null } function Pt(t) { return 4 == (4 & t[2]) } function Dt(t) { return 128 == (128 & t[2]) } function Mt(t, e) { return null == e ? null : t[e] } function Nt(t) { t[18] = 0 } function Ft(t, e) { t[5] += e; let n = t, s = t[3]; for (; null !== s && (1 === e && 1 === n[5] || -1 === e && 0 === n[5]);)s[5] += e, n = s, s = s[3] } const Vt = { lFrame: le(null), bindingsEnabled: !0, isInCheckNoChangesMode: !1 }; function Bt() { return Vt.bindingsEnabled } function Ut() { return Vt.lFrame.lView } function Ht() { return Vt.lFrame.tView } function zt(t) { Vt.lFrame.contextLView = t } function $t() { let t = Wt(); for (; null !== t && 64 === t.type;)t = t.parent; return t } function Wt() { return Vt.lFrame.currentTNode } function qt(t, e) { const n = Vt.lFrame; n.currentTNode = t, n.isParent = e } function Gt() { return Vt.lFrame.isParent } function Xt() { Vt.lFrame.isParent = !1 } function Kt() { return Vt.isInCheckNoChangesMode } function Zt(t) { Vt.isInCheckNoChangesMode = t } function Yt() { const t = Vt.lFrame; let e = t.bindingRootIndex; return -1 === e && (e = t.bindingRootIndex = t.tView.bindingStartIndex), e } function Qt() { return Vt.lFrame.bindingIndex } function Jt() { return Vt.lFrame.bindingIndex++ } function te(t) { const e = Vt.lFrame, n = e.bindingIndex; return e.bindingIndex = e.bindingIndex + t, n } function ee(t, e) { const n = Vt.lFrame; n.bindingIndex = n.bindingRootIndex = t, ne(e) } function ne(t) { Vt.lFrame.currentDirectiveIndex = t } function se() { return Vt.lFrame.currentQueryIndex } function re(t) { Vt.lFrame.currentQueryIndex = t } function ie(t) { const e = t[1]; return 2 === e.type ? e.declTNode : 1 === e.type ? t[6] : null } function oe(t, e, n) { if (n & j.SkipSelf) { let s = e, r = t; for (; s = s.parent, !(null !== s || n & j.Host || (s = ie(r), null === s) || (r = r[15], 10 & s.type));); if (null === s) return !1; e = s, t = r } const s = Vt.lFrame = ce(); return s.currentTNode = e, s.lView = t, !0 } function ae(t) { const e = ce(), n = t[1]; Vt.lFrame = e, e.currentTNode = n.firstChild, e.lView = t, e.tView = n, e.contextLView = t, e.bindingIndex = n.bindingStartIndex, e.inI18n = !1 } function ce() { const t = Vt.lFrame, e = null === t ? null : t.child; return null === e ? le(t) : e } function le(t) { const e = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null, inI18n: !1 }; return null !== t && (t.child = e), e } function ue() { const t = Vt.lFrame; return Vt.lFrame = t.parent, t.currentTNode = null, t.lView = null, t } const he = ue; function de() { const t = ue(); t.isParent = !0, t.tView = null, t.selectedIndex = -1, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 } function pe() { return Vt.lFrame.selectedIndex } function fe(t) { Vt.lFrame.selectedIndex = t } function ge() { const t = Vt.lFrame; return At(t.tView, t.selectedIndex) } function me() { Vt.lFrame.currentNamespace = "http://www.w3.org/2000/svg" } function be(t, e) { for (let n = e.directiveStart, s = e.directiveEnd; n < s; n++) { const e = t.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: r, ngAfterViewInit: i, ngAfterViewChecked: o, ngOnDestroy: a } = e; s && (t.contentHooks || (t.contentHooks = [])).push(-n, s), r && ((t.contentHooks || (t.contentHooks = [])).push(n, r), (t.contentCheckHooks || (t.contentCheckHooks = [])).push(n, r)), i && (t.viewHooks || (t.viewHooks = [])).push(-n, i), o && ((t.viewHooks || (t.viewHooks = [])).push(n, o), (t.viewCheckHooks || (t.viewCheckHooks = [])).push(n, o)), null != a && (t.destroyHooks || (t.destroyHooks = [])).push(n, a) } } function _e(t, e, n) { we(t, e, 3, n) } function ve(t, e, n, s) { (3 & t[2]) === n && we(t, e, n, s) } function ye(t, e) { let n = t[2]; (3 & n) === e && (n &= 2047, n += 1, t[2] = n) } function we(t, e, n, s) { const r = null != s ? s : -1, i = e.length - 1; let o = 0; for (let a = void 0 !== s ? 65535 & t[18] : 0; a < i; a++)if ("number" == typeof e[a + 1]) { if (o = e[a], null != s && o >= s) break } else e[a] < 0 && (t[18] += 65536), (o < r || -1 == r) && (Ce(t, n, e, a), t[18] = (4294901760 & t[18]) + a + 2), a++ } function Ce(t, e, n, s) { const r = n[s] < 0, i = n[s + 1], o = t[r ? -n[s] : n[s]]; if (r) { if (t[2] >> 11 < t[18] >> 16 && (3 & t[2]) === e) { t[2] += 2048; try { i.call(o) } finally { } } } else try { i.call(o) } finally { } } class Oe { constructor(t, e, n) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = n } } function Se(t, e, n) { const s = xt(t); let r = 0; for (; r < n.length;) { const i = n[r]; if ("number" == typeof i) { if (0 !== i) break; r++; const o = n[r++], a = n[r++], c = n[r++]; s ? t.setAttribute(e, a, c, o) : e.setAttributeNS(o, a, c) } else { const o = i, a = n[++r]; Ee(o) ? s && t.setProperty(e, o, a) : s ? t.setAttribute(e, o, a) : e.setAttribute(o, a), r++ } } return r } function xe(t) { return 3 === t || 4 === t || 6 === t } function Ee(t) { return 64 === t.charCodeAt(0) } function Te(t, e) { if (null === e || 0 === e.length); else if (null === t || 0 === t.length) t = e.slice(); else { let n = -1; for (let s = 0; s < e.length; s++) { const r = e[s]; "number" == typeof r ? n = r : 0 === n || ke(t, n, r, null, -1 === n || 2 === n ? e[++s] : null) } } return t } function ke(t, e, n, s, r) { let i = 0, o = t.length; if (-1 === e) o = -1; else for (; i < t.length;) { const n = t[i++]; if ("number" == typeof n) { if (n === e) { o = -1; break } if (n > e) { o = i - 1; break } } } for (; i < t.length;) { const e = t[i]; if ("number" == typeof e) break; if (e === n) { if (null === s) return void (null !== r && (t[i + 1] = r)); if (s === t[i + 1]) return void (t[i + 2] = r) } i++, null !== s && i++, null !== r && i++ } -1 !== o && (t.splice(o, 0, e), i = o + 1), t.splice(i++, 0, n), null !== s && t.splice(i++, 0, s), null !== r && t.splice(i++, 0, r) } function je(t) { return -1 !== t } function Ae(t) { return 32767 & t } function Re(t, e) { let n = t >> 16, s = e; for (; n > 0;)s = s[15], n--; return s } let Le = !0; function Ie(t) { const e = Le; return Le = t, e } let Pe = 0; function De(t, e) { const n = Ne(t, e); if (-1 !== n) return n; const s = e[1]; s.firstCreatePass && (t.injectorIndex = e.length, Me(s.data, t), Me(e, null), Me(s.blueprint, null)); const r = Fe(t, e), i = t.injectorIndex; if (je(r)) { const t = Ae(r), n = Re(r, e), s = n[1].data; for (let r = 0; r < 8; r++)e[i + r] = n[t + r] | s[t + r] } return e[i + 8] = r, i } function Me(t, e) { t.push(0, 0, 0, 0, 0, 0, 0, 0, e) } function Ne(t, e) { return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null === e[t.injectorIndex + 8] ? -1 : t.injectorIndex } function Fe(t, e) { if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex; let n = 0, s = null, r = e; for (; null !== r;) { const t = r[1], e = t.type; if (s = 2 === e ? t.declTNode : 1 === e ? r[6] : null, null === s) return -1; if (n++, r = r[15], -1 !== s.injectorIndex) return s.injectorIndex | n << 16 } return -1 } function Ve(t, e, n) { !function (t, e, n) { let s; "string" == typeof n ? s = n.charCodeAt(0) || 0 : n.hasOwnProperty(Z) && (s = n[Z]), null == s && (s = n[Z] = Pe++); const r = 255 & s; e.data[t + (r >> 5)] |= 1 << r }(t, e, n) } function Be(t, e, n) { if (n & j.Optional) return t; v(e, "NodeInjector") } function Ue(t, e, n, s) { if (n & j.Optional && void 0 === s && (s = null), 0 == (n & (j.Self | j.Host))) { const r = t[9], i = R(void 0); try { return r ? r.get(e, s, n & j.Optional) : L(e, s, n & j.Optional) } finally { R(i) } } return Be(s, e, n) } function He(t, e, n, s = j.Default, r) { if (null !== t) { const i = function (t) { if ("string" == typeof t) return t.charCodeAt(0) || 0; const e = t.hasOwnProperty(Z) ? t[Z] : void 0; return "number" == typeof e ? e >= 0 ? 255 & e : $e : e }(n); if ("function" == typeof i) { if (!oe(e, t, s)) return s & j.Host ? Be(r, n, s) : Ue(e, n, s, r); try { const t = i(); if (null != t || s & j.Optional) return t; v(n) } finally { he() } } else if ("number" == typeof i) { let r = null, o = Ne(t, e), a = -1, c = s & j.Host ? e[16][6] : null; for ((-1 === o || s & j.SkipSelf) && (a = -1 === o ? Fe(t, e) : e[o + 8], -1 !== a && Ke(s, !1) ? (r = e[1], o = Ae(a), e = Re(a, e)) : o = -1); -1 !== o;) { const t = e[1]; if (Xe(i, o, t.data)) { const t = We(o, e, n, r, s, c); if (t !== ze) return t } a = e[o + 8], -1 !== a && Ke(s, e[1].data[o + 8] === c) && Xe(i, o, e) ? (r = t, o = Ae(a), e = Re(a, e)) : o = -1 } } } return Ue(e, n, s, r) } const ze = {}; function $e() { return new Ze($t(), Ut()) } function We(t, e, n, s, r, i) { const o = e[1], a = o.data[t + 8], c = qe(a, o, n, null == s ? dt(a) && Le : s != o && 0 != (3 & a.type), r & j.Host && i === a); return null !== c ? Ge(e, o, c, a) : ze } function qe(t, e, n, s, r) { const i = t.providerIndexes, o = e.data, a = 1048575 & i, c = t.directiveStart, l = i >> 20, u = r ? a + l : t.directiveEnd; for (let h = s ? a : a + l; h < u; h++) { const t = o[h]; if (h < c && n === t || h >= c && t.type === n) return h } if (r) { const t = o[c]; if (t && ft(t) && t.type === n) return c } return null } function Ge(t, e, n, s) { let r = t[n]; const i = e.data; if (r instanceof Oe) { const o = r; o.resolving && function (t, e) { throw new m("200", `Circular dependency in DI detected for ${t}`) }(_(i[n])); const a = Ie(o.canSeeViewProviders); o.resolving = !0; const c = o.injectImpl ? R(o.injectImpl) : null; oe(t, s, j.Default); try { r = t[n] = o.factory(void 0, i, t, s), e.firstCreatePass && n >= s.directiveStart && function (t, e, n) { const { ngOnChanges: s, ngOnInit: r, ngDoCheck: i } = e.type.prototype; if (s) { const s = _t(e); (n.preOrderHooks || (n.preOrderHooks = [])).push(t, s), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, s) } r && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - t, r), i && ((n.preOrderHooks || (n.preOrderHooks = [])).push(t, i), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, i)) }(n, i[n], e) } finally { null !== c && R(c), Ie(a), o.resolving = !1, he() } } return r } function Xe(t, e, n) { return !!(n[e + (t >> 5)] & 1 << t) } function Ke(t, e) { return !(t & j.Self || t & j.Host && e) } class Ze { constructor(t, e) { this._tNode = t, this._lView = e } get(t, e) { return He(this._tNode, this._lView, t, void 0, e) } } function Ye(t) { return I(() => { const e = t.prototype.constructor, n = e[K] || Qe(e), s = Object.prototype; let r = Object.getPrototypeOf(t.prototype).constructor; for (; r && r !== s;) { const t = r[K] || Qe(r); if (t && t !== n) return t; r = Object.getPrototypeOf(r) } return t => new t }) } function Qe(t) { return g(t) ? () => { const e = Qe(f(t)); return e && e() } : gt(t) } function Je(t) { return function (t, e) { if ("class" === e) return t.classes; if ("style" === e) return t.styles; const n = t.attrs; if (n) { const t = n.length; let s = 0; for (; s < t;) { const r = n[s]; if (xe(r)) break; if (0 === r) s += 2; else if ("number" == typeof r) for (s++; s < t && "string" == typeof n[s];)s++; else { if (r === e) return n[s + 1]; s += 2 } } } return null }($t(), t) } function tn(t, e, n) { return I(() => { const s = function (t) { return function (...e) { if (t) { const n = t(...e); for (const t in n) this[t] = n[t] } } }(e); function r(...t) { if (this instanceof r) return s.apply(this, t), this; const e = new r(...t); return n.annotation = e, n; function n(t, n, s) { const r = t.hasOwnProperty("__parameters__") ? t.__parameters__ : Object.defineProperty(t, "__parameters__", { value: [] }).__parameters__; for (; r.length <= s;)r.push(null); return (r[s] = r[s] || []).push(e), t } } return n && (r.prototype = Object.create(n.prototype)), r.prototype.ngMetadataName = t, r.annotationCls = r, r }) } class en { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = y({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } toString() { return `InjectionToken ${this._desc}` } } const nn = new en("AnalyzeForEntryComponents"), sn = Function; function rn(t, e) { void 0 === e && (e = t); for (let n = 0; n < t.length; n++) { let s = t[n]; Array.isArray(s) ? (e === t && (e = t.slice(0, n)), rn(s, e)) : e !== t && e.push(s) } return e } function on(t, e) { t.forEach(t => Array.isArray(t) ? on(t, e) : e(t)) } function an(t, e, n) { e >= t.length ? t.push(n) : t.splice(e, 0, n) } function cn(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] } function ln(t, e) { const n = []; for (let s = 0; s < t; s++)n.push(e); return n } function un(t, e, n) { let s = dn(t, e); return s >= 0 ? t[1 | s] = n : (s = ~s, function (t, e, n, s) { let r = t.length; if (r == e) t.push(n, s); else if (1 === r) t.push(s, t[0]), t[0] = n; else { for (r--, t.push(t[r - 1], t[r]); r > e;)t[r] = t[r - 2], r--; t[e] = n, t[e + 1] = s } }(t, s, e, n)), s } function hn(t, e) { const n = dn(t, e); if (n >= 0) return t[1 | n] } function dn(t, e) { return function (t, e, n) { let s = 0, r = t.length >> 1; for (; r !== s;) { const n = s + (r - s >> 1), i = t[n << 1]; if (e === i) return n << 1; i > e ? r = n : s = n + 1 } return ~(r << 1) }(t, e) } const pn = {}, fn = /\n/gm, gn = c({ provide: String, useValue: c }); let mn; function bn(t) { const e = mn; return mn = t, e } function _n(t, e = j.Default) { if (void 0 === mn) throw new Error("inject() must be called from an injection context"); return null === mn ? L(t, void 0, e) : mn.get(t, e & j.Optional ? null : void 0, e) } function vn(t, e = j.Default) { return (A || _n)(f(t), e) } const yn = vn; function wn(t) { const e = []; for (let n = 0; n < t.length; n++) { const s = f(t[n]); if (Array.isArray(s)) { if (0 === s.length) throw new Error("Arguments array must have arguments."); let t, n = j.Default; for (let e = 0; e < s.length; e++) { const r = s[e], i = r.__NG_DI_FLAG__; "number" == typeof i ? -1 === i ? t = r.token : n |= i : t = r } e.push(vn(t, n)) } else e.push(vn(s)) } return e } function Cn(t, e) { return t.__NG_DI_FLAG__ = e, t.prototype.__NG_DI_FLAG__ = e, t } const On = Cn(tn("Inject", t => ({ token: t })), -1), Sn = Cn(tn("Optional"), 8), xn = Cn(tn("Self"), 2), En = Cn(tn("SkipSelf"), 4); let Tn, kn; function jn(t) { var e; return (null === (e = function () { if (void 0 === Tn && (Tn = null, B.trustedTypes)) try { Tn = B.trustedTypes.createPolicy("angular", { createHTML: t => t, createScript: t => t, createScriptURL: t => t }) } catch (e) { } return Tn }()) || void 0 === e ? void 0 : e.createHTML(t)) || t } function An(t) { var e; return (null === (e = function () { if (void 0 === kn && (kn = null, B.trustedTypes)) try { kn = B.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: t => t, createScript: t => t, createScriptURL: t => t }) } catch (e) { } return kn }()) || void 0 === e ? void 0 : e.createHTML(t)) || t } class Rn { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } class Ln extends Rn { getTypeName() { return "HTML" } } class In extends Rn { getTypeName() { return "Style" } } class Pn extends Rn { getTypeName() { return "Script" } } class Dn extends Rn { getTypeName() { return "URL" } } class Mn extends Rn { getTypeName() { return "ResourceURL" } } function Nn(t) { return t instanceof Rn ? t.changingThisBreaksApplicationSecurity : t } function Fn(t, e) { const n = Vn(t); if (null != n && n !== e) { if ("ResourceURL" === n && "URL" === e) return !0; throw new Error(`Required a safe ${e}, got a ${n} (see https://g.co/ng/security#xss)`) } return n === e } function Vn(t) { return t instanceof Rn && t.getTypeName() || null } function Bn(t) { return new Ln(t) } function Un(t) { return new In(t) } function Hn(t) { return new Pn(t) } function zn(t) { return new Dn(t) } function $n(t) { return new Mn(t) } class Wn { constructor(t) { this.inertDocumentHelper = t } getInertBodyElement(t) { t = "<body><remove></remove>" + t; try { const e = (new window.DOMParser).parseFromString(jn(t), "text/html").body; return null === e ? this.inertDocumentHelper.getInertBodyElement(t) : (e.removeChild(e.firstChild), e) } catch (e) { return null } } } class qn { constructor(t) { if (this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) { const t = this.inertDocument.createElement("html"); this.inertDocument.appendChild(t); const e = this.inertDocument.createElement("body"); t.appendChild(e) } } getInertBodyElement(t) { const e = this.inertDocument.createElement("template"); if ("content" in e) return e.innerHTML = jn(t), e; const n = this.inertDocument.createElement("body"); return n.innerHTML = jn(t), this.defaultDoc.documentMode && this.stripCustomNsAttrs(n), n } stripCustomNsAttrs(t) { const e = t.attributes; for (let s = e.length - 1; 0 < s; s--) { const n = e.item(s).name; "xmlns:ns1" !== n && 0 !== n.indexOf("ns1:") || t.removeAttribute(n) } let n = t.firstChild; for (; n;)n.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(n), n = n.nextSibling } } const Gn = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi, Xn = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; function Kn(t) { return (t = String(t)).match(Gn) || t.match(Xn) ? t : "unsafe:" + t } function Zn(t) { const e = {}; for (const n of t.split(",")) e[n] = !0; return e } function Yn(...t) { const e = {}; for (const n of t) for (const t in n) n.hasOwnProperty(t) && (e[t] = !0); return e } const Qn = Zn("area,br,col,hr,img,wbr"), Jn = Zn("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), ts = Zn("rp,rt"), es = Yn(ts, Jn), ns = Yn(Qn, Yn(Jn, Zn("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Yn(ts, Zn("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), es), ss = Zn("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), rs = Zn("srcset"), is = Yn(ss, rs, Zn("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), Zn("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), os = Zn("script,style,template"); class as { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(t) { let e = t.firstChild, n = !0; for (; e;)if (e.nodeType === Node.ELEMENT_NODE ? n = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = !0, n && e.firstChild) e = e.firstChild; else for (; e;) { e.nodeType === Node.ELEMENT_NODE && this.endElement(e); let t = this.checkClobberedElement(e, e.nextSibling); if (t) { e = t; break } e = this.checkClobberedElement(e, e.parentNode) } return this.buf.join("") } startElement(t) { const e = t.nodeName.toLowerCase(); if (!ns.hasOwnProperty(e)) return this.sanitizedSomething = !0, !os.hasOwnProperty(e); this.buf.push("<"), this.buf.push(e); const n = t.attributes; for (let r = 0; r < n.length; r++) { const t = n.item(r), e = t.name, i = e.toLowerCase(); if (!is.hasOwnProperty(i)) { this.sanitizedSomething = !0; continue } let o = t.value; ss[i] && (o = Kn(o)), rs[i] && (s = o, o = (s = String(s)).split(",").map(t => Kn(t.trim())).join(", ")), this.buf.push(" ", e, '="', us(o), '"') } var s; return this.buf.push(">"), !0 } endElement(t) { const e = t.nodeName.toLowerCase(); ns.hasOwnProperty(e) && !Qn.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">")) } chars(t) { this.buf.push(us(t)) } checkClobberedElement(t, e) { if (e && (t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`); return e } } const cs = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, ls = /([^\#-~ |!])/g; function us(t) { return t.replace(/&/g, "&amp;").replace(cs, function (t) { return "&#" + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ";" }).replace(ls, function (t) { return "&#" + t.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let hs; function ds(t, e) { let n = null; try { hs = hs || function (t) { const e = new qn(t); return function () { try { return !!(new window.DOMParser).parseFromString(jn(""), "text/html") } catch (t) { return !1 } }() ? new Wn(e) : e }(t); let s = e ? String(e) : ""; n = hs.getInertBodyElement(s); let r = 5, i = s; do { if (0 === r) throw new Error("Failed to sanitize html because the input is unstable"); r--, s = i, i = n.innerHTML, n = hs.getInertBodyElement(s) } while (s !== i); return jn((new as).sanitizeChildren(ps(n) || n)) } finally { if (n) { const t = ps(n) || n; for (; t.firstChild;)t.removeChild(t.firstChild) } } } function ps(t) { return "content" in t && function (t) { return t.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === t.nodeName }(t) ? t.content : null } var fs = function (t) { return t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL", t }({}); function gs(t) { const e = bs(); return e ? An(e.sanitize(fs.HTML, t) || "") : Fn(t, "HTML") ? An(Nn(t)) : ds(St(), b(t)) } function ms(t) { const e = bs(); return e ? e.sanitize(fs.URL, t) || "" : Fn(t, "URL") ? Nn(t) : Kn(b(t)) } function bs() { const t = Ut(); return t && t[12] } function _s(t) { return t.ngDebugContext } function vs(t) { return t.ngOriginalError } function ys(t, ...e) { t.error(...e) } class ws { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t), n = this._findContext(t), s = function (t) { return t.ngErrorLogger || ys }(t); s(this._console, "ERROR", t), e && s(this._console, "ORIGINAL ERROR", e), n && s(this._console, "ERROR CONTEXT", n) } _findContext(t) { return t ? _s(t) ? _s(t) : this._findContext(vs(t)) : null } _findOriginalError(t) { let e = vs(t); for (; e && vs(e);)e = vs(e); return e } } function Cs(t, e) { t.__ngContext__ = e } const Os = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(B))(); function Ss(t) { return { name: "window", target: t.ownerDocument.defaultView } } function xs(t) { return { name: "document", target: t.ownerDocument } } function Es(t) { return t instanceof Function ? t() : t } var Ts = function (t) { return t[t.Important = 1] = "Important", t[t.DashCase = 2] = "DashCase", t }({}); function ks(t, e) { return (void 0)(t, e) } function js(t) { const e = t[3]; return ut(e) ? e[3] : e } function As(t) { return Ls(t[13]) } function Rs(t) { return Ls(t[4]) } function Ls(t) { for (; null !== t && !ut(t);)t = t[4]; return t } function Is(t, e, n, s, r) { if (null != s) { let i, o = !1; ut(s) ? i = s : lt(s) && (o = !0, s = s[0]); const a = Tt(s); 0 === t && null !== n ? null == r ? Us(e, n, a) : Bs(e, n, a, r || null, !0) : 1 === t && null !== n ? Bs(e, n, a, r || null, !0) : 2 === t ? function (t, e, n) { const s = zs(t, e); s && function (t, e, n, s) { xt(t) ? t.removeChild(e, n, s) : e.removeChild(n) }(t, s, e, n) }(e, a, o) : 3 === t && e.destroyNode(a), null != i && function (t, e, n, s, r) { const i = n[7]; i !== Tt(n) && Is(e, t, s, i, r); for (let o = 10; o < n.length; o++) { const r = n[o]; Ys(r[1], r, t, e, s, i) } }(e, t, i, n, r) } } function Ps(t, e, n) { return xt(t) ? t.createElement(e, n) : null === n ? t.createElement(e) : t.createElementNS(n, e) } function Ds(t, e) { const n = t[9], s = n.indexOf(e), r = e[3]; 1024 & e[2] && (e[2] &= -1025, Ft(r, -1)), n.splice(s, 1) } function Ms(t, e) { if (t.length <= 10) return; const n = 10 + e, s = t[n]; if (s) { const i = s[17]; null !== i && i !== t && Ds(i, s), e > 0 && (t[n - 1][4] = s[4]); const o = cn(t, 10 + e); Ys(s[1], r = s, r[11], 2, null, null), r[0] = null, r[6] = null; const a = o[19]; null !== a && a.detachView(o[1]), s[3] = null, s[4] = null, s[2] &= -129 } var r; return s } function Ns(t, e) { if (!(256 & e[2])) { const n = e[11]; xt(n) && n.destroyNode && Ys(t, e, n, 3, null, null), function (t) { let e = t[13]; if (!e) return Fs(t[1], t); for (; e;) { let n = null; if (lt(e)) n = e[13]; else { const t = e[10]; t && (n = t) } if (!n) { for (; e && !e[4] && e !== t;)lt(e) && Fs(e[1], e), e = e[3]; null === e && (e = t), lt(e) && Fs(e[1], e), n = e && e[4] } e = n } }(e) } } function Fs(t, e) { if (!(256 & e[2])) { e[2] &= -129, e[2] |= 256, function (t, e) { let n; if (null != t && null != (n = t.destroyHooks)) for (let s = 0; s < n.length; s += 2) { const t = e[n[s]]; if (!(t instanceof Oe)) { const e = n[s + 1]; if (Array.isArray(e)) for (let n = 0; n < e.length; n += 2)e[n + 1].call(t[e[n]]); else e.call(t) } } }(t, e), function (t, e) { const n = t.cleanup, s = e[7]; let r = -1; if (null !== n) for (let i = 0; i < n.length - 1; i += 2)if ("string" == typeof n[i]) { const t = n[i + 1], o = "function" == typeof t ? t(e) : Tt(e[t]), a = s[r = n[i + 2]], c = n[i + 3]; "boolean" == typeof c ? o.removeEventListener(n[i], a, c) : c >= 0 ? s[r = c]() : s[r = -c].unsubscribe(), i += 2 } else { const t = s[r = n[i + 1]]; n[i].call(t) } if (null !== s) { for (let t = r + 1; t < s.length; t++)(0, s[t])(); e[7] = null } }(t, e), 1 === e[1].type && xt(e[11]) && e[11].destroy(); const n = e[17]; if (null !== n && ut(e[3])) { n !== e[3] && Ds(n, e); const s = e[19]; null !== s && s.detachView(t) } } } function Vs(t, e, n) { return function (t, e, n) { let s = e; for (; null !== s && 40 & s.type;)s = (e = s).parent; if (null === s) return n[0]; if (2 & s.flags) { const e = t.data[s.directiveStart].encapsulation; if (e === D.None || e === D.Emulated) return null } return jt(s, n) }(t, e.parent, n) } function Bs(t, e, n, s, r) { xt(t) ? t.insertBefore(e, n, s, r) : e.insertBefore(n, s, r) } function Us(t, e, n) { xt(t) ? t.appendChild(e, n) : e.appendChild(n) } function Hs(t, e, n, s, r) { null !== s ? Bs(t, e, n, s, r) : Us(t, e, n) } function zs(t, e) { return xt(t) ? t.parentNode(e) : e.parentNode } function $s(t, e, n) { return Ws(t, e, n) } let Ws = function (t, e, n) { return 40 & t.type ? jt(t, n) : null }; function qs(t, e, n, s) { const r = Vs(t, s, e), i = e[11], o = $s(s.parent || e[6], s, e); if (null != r) if (Array.isArray(n)) for (let a = 0; a < n.length; a++)Hs(i, r, n[a], o, !1); else Hs(i, r, n, o, !1) } function Gs(t, e) { if (null !== e) { const n = e.type; if (3 & n) return jt(e, t); if (4 & n) return Ks(-1, t[e.index]); if (8 & n) { const n = e.child; if (null !== n) return Gs(t, n); { const n = t[e.index]; return ut(n) ? Ks(-1, n) : Tt(n) } } if (32 & n) return ks(e, t)() || Tt(t[e.index]); { const n = Xs(t, e); return null !== n ? Array.isArray(n) ? n[0] : Gs(js(t[16]), n) : Gs(t, e.next) } } return null } function Xs(t, e) { return null !== e ? t[16][6].projection[e.projection] : null } function Ks(t, e) { const n = 10 + t + 1; if (n < e.length) { const t = e[n], s = t[1].firstChild; if (null !== s) return Gs(t, s) } return e[7] } function Zs(t, e, n, s, r, i, o) { for (; null != n;) { const a = s[n.index], c = n.type; if (o && 0 === e && (a && Cs(Tt(a), s), n.flags |= 4), 64 != (64 & n.flags)) if (8 & c) Zs(t, e, n.child, s, r, i, !1), Is(e, t, r, a, i); else if (32 & c) { const o = ks(n, s); let c; for (; c = o();)Is(e, t, r, c, i); Is(e, t, r, a, i) } else 16 & c ? Qs(t, e, s, n, r, i) : Is(e, t, r, a, i); n = o ? n.projectionNext : n.next } } function Ys(t, e, n, s, r, i) { Zs(n, s, t.firstChild, e, r, i, !1) } function Qs(t, e, n, s, r, i) { const o = n[16], a = o[6].projection[s.projection]; if (Array.isArray(a)) for (let c = 0; c < a.length; c++)Is(e, t, r, a[c], i); else Zs(t, e, a, o[3], r, i, !0) } function Js(t, e, n) { xt(t) ? t.setAttribute(e, "style", n) : e.style.cssText = n } function tr(t, e, n) { xt(t) ? "" === n ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", n) : e.className = n } function er(t, e, n) { let s = t.length; for (; ;) { const r = t.indexOf(e, n); if (-1 === r) return r; if (0 === r || t.charCodeAt(r - 1) <= 32) { const n = e.length; if (r + n === s || t.charCodeAt(r + n) <= 32) return r } n = r + 1 } } function nr(t, e, n) { let s = 0; for (; s < t.length;) { let r = t[s++]; if (n && "class" === r) { if (r = t[s], -1 !== er(r.toLowerCase(), e, 0)) return !0 } else if (1 === r) { for (; s < t.length && "string" == typeof (r = t[s++]);)if (r.toLowerCase() === e) return !0; return !1 } } return !1 } function sr(t) { return 4 === t.type && "ng-template" !== t.value } function rr(t, e, n) { return e === (4 !== t.type || n ? t.value : "ng-template") } function ir(t, e, n) { let s = 4; const r = t.attrs || [], i = function (t) { for (let e = 0; e < t.length; e++)if (xe(t[e])) return e; return t.length }(r); let o = !1; for (let a = 0; a < e.length; a++) { const c = e[a]; if ("number" != typeof c) { if (!o) if (4 & s) { if (s = 2 | 1 & s, "" !== c && !rr(t, c, n) || "" === c && 1 === e.length) { if (or(s)) return !1; o = !0 } } else { const l = 8 & s ? c : e[++a]; if (8 & s && null !== t.attrs) { if (!nr(t.attrs, l, n)) { if (or(s)) return !1; o = !0 } continue } const u = ar(8 & s ? "class" : c, r, sr(t), n); if (-1 === u) { if (or(s)) return !1; o = !0; continue } if ("" !== l) { let t; t = u > i ? "" : r[u + 1].toLowerCase(); const e = 8 & s ? t : null; if (e && -1 !== er(e, l, 0) || 2 & s && l !== t) { if (or(s)) return !1; o = !0 } } } } else { if (!o && !or(s) && !or(c)) return !1; if (o && or(c)) continue; o = !1, s = c | 1 & s } } return or(s) || o } function or(t) { return 0 == (1 & t) } function ar(t, e, n, s) { if (null === e) return -1; let r = 0; if (s || !n) { let n = !1; for (; r < e.length;) { const s = e[r]; if (s === t) return r; if (3 === s || 6 === s) n = !0; else { if (1 === s || 2 === s) { let t = e[++r]; for (; "string" == typeof t;)t = e[++r]; continue } if (4 === s) break; if (0 === s) { r += 4; continue } } r += n ? 1 : 2 } return -1 } return function (t, e) { let n = t.indexOf(4); if (n > -1) for (n++; n < t.length;) { const s = t[n]; if ("number" == typeof s) return -1; if (s === e) return n; n++ } return -1 }(e, t) } function cr(t, e, n = !1) { for (let s = 0; s < e.length; s++)if (ir(t, e[s], n)) return !0; return !1 } function lr(t, e) { t: for (let n = 0; n < e.length; n++) { const s = e[n]; if (t.length === s.length) { for (let e = 0; e < t.length; e++)if (t[e] !== s[e]) continue t; return !0 } } return !1 } function ur(t, e) { return t ? ":not(" + e.trim() + ")" : e } function hr(t) { let e = t[0], n = 1, s = 2, r = "", i = !1; for (; n < t.length;) { let o = t[n]; if ("string" == typeof o) if (2 & s) { const e = t[++n]; r += "[" + o + (e.length > 0 ? '="' + e + '"' : "") + "]" } else 8 & s ? r += "." + o : 4 & s && (r += " " + o); else "" === r || or(o) || (e += ur(i, r), r = ""), s = o, i = i || !or(s); n++ } return "" !== r && (e += ur(i, r)), e } const dr = {}; function pr(t) { fr(Ht(), Ut(), pe() + t, Kt()) } function fr(t, e, n, s) { if (!s) if (3 == (3 & e[2])) { const s = t.preOrderCheckHooks; null !== s && _e(e, s, n) } else { const s = t.preOrderHooks; null !== s && ve(e, s, 0, n) } fe(n) } function gr(t, e) { return t << 17 | e << 2 } function mr(t) { return t >> 17 & 32767 } function br(t) { return 2 | t } function _r(t) { return (131068 & t) >> 2 } function vr(t, e) { return -131069 & t | e << 2 } function yr(t) { return 1 | t } function wr(t, e) { const n = t.contentQueries; if (null !== n) for (let s = 0; s < n.length; s += 2) { const r = n[s], i = n[s + 1]; if (-1 !== i) { const n = t.data[i]; re(r), n.contentQueries(2, e[i], i) } } } function Cr(t, e, n, s, r, i, o, a, c, l) { const u = e.blueprint.slice(); return u[0] = r, u[2] = 140 | s, Nt(u), u[3] = u[15] = t, u[8] = n, u[10] = o || t && t[10], u[11] = a || t && t[11], u[12] = c || t && t[12] || null, u[9] = l || t && t[9] || null, u[6] = i, u[16] = 2 == e.type ? t[16] : u, u } function Or(t, e, n, s, r) { let i = t.data[e]; if (null === i) i = function (t, e, n, s, r) { const i = Wt(), o = Gt(), a = t.data[e] = function (t, e, n, s, r, i) { return { type: n, index: s, insertBeforeIndex: null, injectorIndex: e ? e.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: r, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: e, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, o ? i : i && i.parent, n, e, s, r); return null === t.firstChild && (t.firstChild = a), null !== i && (o ? null == i.child && null !== a.parent && (i.child = a) : null === i.next && (i.next = a)), a }(t, e, n, s, r), Vt.lFrame.inI18n && (i.flags |= 64); else if (64 & i.type) { i.type = n, i.value = s, i.attrs = r; const t = function () { const t = Vt.lFrame, e = t.currentTNode; return t.isParent ? e : e.parent }(); i.injectorIndex = null === t ? -1 : t.injectorIndex } return qt(i, !0), i } function Sr(t, e, n, s) { if (0 === n) return -1; const r = e.length; for (let i = 0; i < n; i++)e.push(s), t.blueprint.push(s), t.data.push(null); return r } function xr(t, e, n) { ae(e); try { const s = t.viewQuery; null !== s && ni(1, s, n); const r = t.template; null !== r && kr(t, e, r, 1, n), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && wr(t, e), t.staticViewQueries && ni(2, t.viewQuery, n); const i = t.components; null !== i && function (t, e) { for (let n = 0; n < e.length; n++)Yr(t, e[n]) }(e, i) } catch (s) { throw t.firstCreatePass && (t.incompleteFirstPass = !0), s } finally { e[2] &= -5, de() } } function Er(t, e, n, s) { const r = e[2]; if (256 == (256 & r)) return; ae(e); const i = Kt(); try { Nt(e), Vt.lFrame.bindingIndex = t.bindingStartIndex, null !== n && kr(t, e, n, 2, s); const o = 3 == (3 & r); if (!i) if (o) { const n = t.preOrderCheckHooks; null !== n && _e(e, n, null) } else { const n = t.preOrderHooks; null !== n && ve(e, n, 0, null), ye(e, 0) } if (function (t) { for (let e = As(t); null !== e; e = Rs(e)) { if (!e[2]) continue; const t = e[9]; for (let e = 0; e < t.length; e++) { const n = t[e], s = n[3]; 0 == (1024 & n[2]) && Ft(s, 1), n[2] |= 1024 } } }(e), function (t) { for (let e = As(t); null !== e; e = Rs(e))for (let t = 10; t < e.length; t++) { const n = e[t], s = n[1]; Dt(n) && Er(s, n, s.template, n[8]) } }(e), null !== t.contentQueries && wr(t, e), !i) if (o) { const n = t.contentCheckHooks; null !== n && _e(e, n) } else { const n = t.contentHooks; null !== n && ve(e, n, 1), ye(e, 1) } !function (t, e) { const n = t.hostBindingOpCodes; if (null !== n) try { for (let t = 0; t < n.length; t++) { const s = n[t]; if (s < 0) fe(~s); else { const r = s, i = n[++t], o = n[++t]; ee(i, r), o(2, e[r]) } } } finally { fe(-1) } }(t, e); const a = t.components; null !== a && function (t, e) { for (let n = 0; n < e.length; n++)Kr(t, e[n]) }(e, a); const c = t.viewQuery; if (null !== c && ni(2, c, s), !i) if (o) { const n = t.viewCheckHooks; null !== n && _e(e, n) } else { const n = t.viewHooks; null !== n && ve(e, n, 2), ye(e, 2) } !0 === t.firstUpdatePass && (t.firstUpdatePass = !1), i || (e[2] &= -73), 1024 & e[2] && (e[2] &= -1025, Ft(e[3], -1)) } finally { de() } } function Tr(t, e, n, s) { const r = e[10], i = !Kt(), o = Pt(e); try { i && !o && r.begin && r.begin(), o && xr(t, e, s), Er(t, e, n, s) } finally { i && !o && r.end && r.end() } } function kr(t, e, n, s, r) { const i = pe(), o = 2 & s; try { fe(-1), o && e.length > 20 && fr(t, e, 20, Kt()), n(s, r) } finally { fe(i) } } function jr(t, e, n) { if (ht(e)) { const s = e.directiveEnd; for (let r = e.directiveStart; r < s; r++) { const e = t.data[r]; e.contentQueries && e.contentQueries(1, n[r], r) } } } function Ar(t, e, n) { Bt() && (function (t, e, n, s) { const r = n.directiveStart, i = n.directiveEnd; t.firstCreatePass || De(n, e), Cs(s, e); const o = n.initialInputs; for (let a = r; a < i; a++) { const s = t.data[a], i = ft(s); i && $r(e, n, s); const c = Ge(e, t, a, n); Cs(c, e), null !== o && qr(0, a - r, c, s, 0, o), i && (Lt(n.index, e)[8] = c) } }(t, e, n, jt(n, e)), 128 == (128 & n.flags) && function (t, e, n) { const s = n.directiveStart, r = n.directiveEnd, i = n.index, o = Vt.lFrame.currentDirectiveIndex; try { fe(i); for (let n = s; n < r; n++) { const s = t.data[n], r = e[n]; ne(n), null === s.hostBindings && 0 === s.hostVars && null === s.hostAttrs || Vr(s, r) } } finally { fe(-1), ne(o) } }(t, e, n)) } function Rr(t, e, n = jt) { const s = e.localNames; if (null !== s) { let r = e.index + 1; for (let i = 0; i < s.length; i += 2) { const o = s[i + 1], a = -1 === o ? n(e, t) : t[o]; t[r++] = a } } } function Lr(t) { const e = t.tView; return null === e || e.incompleteFirstPass ? t.tView = Ir(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts) : e } function Ir(t, e, n, s, r, i, o, a, c, l) { const u = 20 + s, h = u + r, d = function (t, e) { const n = []; for (let s = 0; s < e; s++)n.push(s < t ? null : dr); return n }(u, h), p = "function" == typeof l ? l() : l; return d[1] = { type: t, blueprint: d, template: n, queries: null, viewQuery: a, declTNode: e, data: d.slice().fill(null, u), bindingStartIndex: u, expandoStartIndex: h, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof o ? o() : o, firstChild: null, schemas: c, consts: p, incompleteFirstPass: !1 } } function Pr(t, e, n, s) { const r = ri(e); null === n ? r.push(s) : (r.push(n), t.firstCreatePass && ii(t).push(s, r.length - 1)) } function Dr(t, e, n) { for (let s in t) if (t.hasOwnProperty(s)) { const r = t[s]; (n = null === n ? {} : n).hasOwnProperty(s) ? n[s].push(e, r) : n[s] = [e, r] } return n } function Mr(t, e, n, s, r, i, o, a) { const c = jt(e, n); let l, u = e.inputs; var h; !a && null != u && (l = u[s]) ? (ai(t, n, l, s, r), dt(e) && function (t, e) { const n = Lt(e, t); 16 & n[2] || (n[2] |= 64) }(n, e.index)) : 3 & e.type && (s = "class" === (h = s) ? "className" : "for" === h ? "htmlFor" : "formaction" === h ? "formAction" : "innerHtml" === h ? "innerHTML" : "readonly" === h ? "readOnly" : "tabindex" === h ? "tabIndex" : h, r = null != o ? o(r, e.value || "", s) : r, xt(i) ? i.setProperty(c, s, r) : Ee(s) || (c.setProperty ? c.setProperty(s, r) : c[s] = r)) } function Nr(t, e, n, s) { let r = !1; if (Bt()) { const i = function (t, e, n) { const s = t.directiveRegistry; let r = null; if (s) for (let i = 0; i < s.length; i++) { const o = s[i]; cr(n, o.selectors, !1) && (r || (r = []), Ve(De(n, e), t, o.type), ft(o) ? (Br(t, n), r.unshift(o)) : r.push(o)) } return r }(t, e, n), o = null === s ? null : { "": -1 }; if (null !== i) { r = !0, Hr(n, t.data.length, i.length); for (let t = 0; t < i.length; t++) { const e = i[t]; e.providersResolver && e.providersResolver(e) } let s = !1, a = !1, c = Sr(t, e, i.length, null); for (let r = 0; r < i.length; r++) { const l = i[r]; n.mergedAttrs = Te(n.mergedAttrs, l.hostAttrs), zr(t, n, e, c, l), Ur(c, l, o), null !== l.contentQueries && (n.flags |= 8), null === l.hostBindings && null === l.hostAttrs && 0 === l.hostVars || (n.flags |= 128); const u = l.type.prototype; !s && (u.ngOnChanges || u.ngOnInit || u.ngDoCheck) && ((t.preOrderHooks || (t.preOrderHooks = [])).push(n.index), s = !0), a || !u.ngOnChanges && !u.ngDoCheck || ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(n.index), a = !0), c++ } !function (t, e) { const n = e.directiveEnd, s = t.data, r = e.attrs, i = []; let o = null, a = null; for (let c = e.directiveStart; c < n; c++) { const t = s[c], n = t.inputs, l = null === r || sr(e) ? null : Gr(n, r); i.push(l), o = Dr(n, c, o), a = Dr(t.outputs, c, a) } null !== o && (o.hasOwnProperty("class") && (e.flags |= 16), o.hasOwnProperty("style") && (e.flags |= 32)), e.initialInputs = i, e.inputs = o, e.outputs = a }(t, n) } o && function (t, e, n) { if (e) { const s = t.localNames = []; for (let t = 0; t < e.length; t += 2) { const r = n[e[t + 1]]; if (null == r) throw new m("301", `Export of name '${e[t + 1]}' not found!`); s.push(e[t], r) } } }(n, s, o) } return n.mergedAttrs = Te(n.mergedAttrs, n.attrs), r } function Fr(t, e, n, s, r, i) { const o = i.hostBindings; if (o) { let n = t.hostBindingOpCodes; null === n && (n = t.hostBindingOpCodes = []); const i = ~e.index; (function (t) { let e = t.length; for (; e > 0;) { const n = t[--e]; if ("number" == typeof n && n < 0) return n } return 0 })(n) != i && n.push(i), n.push(s, r, o) } } function Vr(t, e) { null !== t.hostBindings && t.hostBindings(1, e) } function Br(t, e) { e.flags |= 2, (t.components || (t.components = [])).push(e.index) } function Ur(t, e, n) { if (n) { if (e.exportAs) for (let s = 0; s < e.exportAs.length; s++)n[e.exportAs[s]] = t; ft(e) && (n[""] = t) } } function Hr(t, e, n) { t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + n, t.providerIndexes = e } function zr(t, e, n, s, r) { t.data[s] = r; const i = r.factory || (r.factory = gt(r.type)), o = new Oe(i, ft(r), null); t.blueprint[s] = o, n[s] = o, Fr(t, e, 0, s, Sr(t, n, r.hostVars, dr), r) } function $r(t, e, n) { const s = jt(e, t), r = Lr(n), i = t[10], o = Qr(t, Cr(t, r, null, n.onPush ? 64 : 16, s, e, i, i.createRenderer(s, n), null, null)); t[e.index] = o } function Wr(t, e, n, s, r, i) { const o = jt(t, e); !function (t, e, n, s, r, i, o) { if (null == i) xt(t) ? t.removeAttribute(e, r, n) : e.removeAttribute(r); else { const a = null == o ? b(i) : o(i, s || "", r); xt(t) ? t.setAttribute(e, r, a, n) : n ? e.setAttributeNS(n, r, a) : e.setAttribute(r, a) } }(e[11], o, i, t.value, n, s, r) } function qr(t, e, n, s, r, i) { const o = i[e]; if (null !== o) { const t = s.setInput; for (let e = 0; e < o.length;) { const r = o[e++], i = o[e++], a = o[e++]; null !== t ? s.setInput(n, a, r, i) : n[i] = a } } } function Gr(t, e) { let n = null, s = 0; for (; s < e.length;) { const r = e[s]; if (0 !== r) if (5 !== r) { if ("number" == typeof r) break; t.hasOwnProperty(r) && (null === n && (n = []), n.push(r, t[r], e[s + 1])), s += 2 } else s += 2; else s += 4 } return n } function Xr(t, e, n, s) { return new Array(t, !0, !1, e, null, 0, s, n, null, null) } function Kr(t, e) { const n = Lt(e, t); if (Dt(n)) { const t = n[1]; 80 & n[2] ? Er(t, n, t.template, n[8]) : n[5] > 0 && Zr(n) } } function Zr(t) { for (let n = As(t); null !== n; n = Rs(n))for (let t = 10; t < n.length; t++) { const e = n[t]; if (1024 & e[2]) { const t = e[1]; Er(t, e, t.template, e[8]) } else e[5] > 0 && Zr(e) } const e = t[1].components; if (null !== e) for (let n = 0; n < e.length; n++) { const s = Lt(e[n], t); Dt(s) && s[5] > 0 && Zr(s) } } function Yr(t, e) { const n = Lt(e, t), s = n[1]; !function (t, e) { for (let n = e.length; n < t.blueprint.length; n++)e.push(t.blueprint[n]) }(s, n), xr(s, n, n[8]) } function Qr(t, e) { return t[13] ? t[14][4] = e : t[13] = e, t[14] = e, e } function Jr(t) { for (; t;) { t[2] |= 64; const e = js(t); if (0 != (512 & t[2]) && !e) return t; t = e } return null } function ti(t, e, n) { const s = e[10]; s.begin && s.begin(); try { Er(t, e, t.template, n) } catch (r) { throw oi(e, r), r } finally { s.end && s.end() } } function ei(t) { !function (t) { for (let e = 0; e < t.components.length; e++) { const n = t.components[e], s = It(n), r = s[1]; Tr(r, s, r.template, n) } }(t[8]) } function ni(t, e, n) { re(0), e(t, n) } const si = (() => Promise.resolve(null))(); function ri(t) { return t[7] || (t[7] = []) } function ii(t) { return t.cleanup || (t.cleanup = []) } function oi(t, e) { const n = t[9], s = n ? n.get(ws, null) : null; s && s.handleError(e) } function ai(t, e, n, s, r) { for (let i = 0; i < n.length;) { const o = n[i++], a = n[i++], c = e[o], l = t.data[o]; null !== l.setInput ? l.setInput(c, r, s, a) : c[a] = r } } function ci(t, e, n) { const s = kt(e, t); !function (t, e, n) { xt(t) ? t.setValue(e, n) : e.textContent = n }(t[11], s, n) } function li(t, e, n) { let s = n ? t.styles : null, r = n ? t.classes : null, i = 0; if (null !== e) for (let o = 0; o < e.length; o++) { const t = e[o]; "number" == typeof t ? i = t : 1 == i ? r = h(r, t) : 2 == i && (s = h(s, t + ": " + e[++o] + ";")) } n ? t.styles = s : t.stylesWithoutHost = s, n ? t.classes = r : t.classesWithoutHost = r } const ui = new en("INJECTOR", -1); class hi { get(t, e = pn) { if (e === pn) { const e = new Error(`NullInjectorError: No provider for ${u(t)}!`); throw e.name = "NullInjectorError", e } return e } } const di = new en("Set Injector scope."), pi = {}, fi = {}, gi = []; let mi; function bi() { return void 0 === mi && (mi = new hi), mi } function _i(t, e = null, n = null, s) { return new vi(t, n, e || bi(), s) } class vi { constructor(t, e, n, s = null) { this.parent = n, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const r = []; e && on(e, n => this.processProvider(n, t, e)), on([t], t => this.processInjectorType(t, [], r)), this.records.set(ui, Ci(void 0, this)); const i = this.records.get(di); this.scope = null != i ? i.value : null, this.source = s || ("object" == typeof t ? null : u(t)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(t => t.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(t, e = pn, n = j.Default) { this.assertNotDestroyed(); const s = bn(this); try { if (!(n & j.SkipSelf)) { let e = this.records.get(t); if (void 0 === e) { const n = ("function" == typeof (r = t) || "object" == typeof r && r instanceof en) && C(t); e = n && this.injectableDefInScope(n) ? Ci(yi(t), pi) : null, this.records.set(t, e) } if (null != e) return this.hydrate(t, e) } return (n & j.Self ? bi() : this.parent).get(t, e = n & j.Optional && e === pn ? null : e) } catch (i) { if ("NullInjectorError" === i.name) { if ((i.ngTempTokenPath = i.ngTempTokenPath || []).unshift(u(t)), s) throw i; return function (t, e, n, s) { const r = t.ngTempTokenPath; throw e.__source && r.unshift(e.__source), t.message = function (t, e, n, s = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.substr(2) : t; let r = u(e); if (Array.isArray(e)) r = e.map(u).join(" -> "); else if ("object" == typeof e) { let t = []; for (let n in e) if (e.hasOwnProperty(n)) { let s = e[n]; t.push(n + ":" + ("string" == typeof s ? JSON.stringify(s) : u(s))) } r = `{${t.join(", ")}}` } return `${n}${s ? "(" + s + ")" : ""}[${r}]: ${t.replace(fn, "\n  ")}` }("\n" + t.message, r, n, s), t.ngTokenPath = r, t.ngTempTokenPath = null, t }(i, t, "R3InjectorError", this.source) } throw i } finally { bn(s) } var r } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(t => this.get(t)) } toString() { const t = []; return this.records.forEach((e, n) => t.push(u(n))), `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new Error("Injector has already been destroyed.") } processInjectorType(t, e, n) { if (!(t = f(t))) return !1; let s = S(t); const r = null == s && t.ngModule || void 0, i = void 0 === r ? t : r, o = -1 !== n.indexOf(i); if (void 0 !== r && (s = S(r)), null == s) return !1; if (null != s.imports && !o) { let t; n.push(i); try { on(s.imports, s => { this.processInjectorType(s, e, n) && (void 0 === t && (t = []), t.push(s)) }) } finally { } if (void 0 !== t) for (let e = 0; e < t.length; e++) { const { ngModule: n, providers: s } = t[e]; on(s, t => this.processProvider(t, n, s || gi)) } } this.injectorDefTypes.add(i); const a = gt(i) || (() => new i); this.records.set(i, Ci(a, pi)); const c = s.providers; if (null != c && !o) { const e = t; on(c, t => this.processProvider(t, e, c)) } return void 0 !== r && void 0 !== t.providers } processProvider(t, e, n) { let s = Si(t = f(t)) ? t : f(t && t.provide); const r = function (t, e, n) { return Oi(t) ? Ci(void 0, t.useValue) : Ci(wi(t), pi) }(t); if (Si(t) || !0 !== t.multi) this.records.get(s); else { let e = this.records.get(s); e || (e = Ci(void 0, pi, !0), e.factory = () => wn(e.multi), this.records.set(s, e)), s = t, e.multi.push(t) } this.records.set(s, r) } hydrate(t, e) { var n; return e.value === pi && (e.value = fi, e.value = e.factory()), "object" == typeof e.value && e.value && null !== (n = e.value) && "object" == typeof n && "function" == typeof n.ngOnDestroy && this.onDestroy.add(e.value), e.value } injectableDefInScope(t) { return !!t.providedIn && ("string" == typeof t.providedIn ? "any" === t.providedIn || t.providedIn === this.scope : this.injectorDefTypes.has(t.providedIn)) } } function yi(t) { const e = C(t), n = null !== e ? e.factory : gt(t); if (null !== n) return n; if (t instanceof en) throw new Error(`Token ${u(t)} is missing a \u0275prov definition.`); if (t instanceof Function) return function (t) { const e = t.length; if (e > 0) { const n = ln(e, "?"); throw new Error(`Can't resolve all parameters for ${u(t)}: (${n.join(", ")}).`) } const n = function (t) { const e = t && (t[x] || t[T]); if (e) { const n = function (t) { if (t.hasOwnProperty("name")) return t.name; const e = ("" + t).match(/^function\s*([^\s(]+)/); return null === e ? "" : e[1] }(t); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), e } return null }(t); return null !== n ? () => n.factory(t) : () => new t }(t); throw new Error("unreachable") } function wi(t, e, n) { let s; if (Si(t)) { const e = f(t); return gt(e) || yi(e) } if (Oi(t)) s = () => f(t.useValue); else if ((r = t) && r.useFactory) s = () => t.useFactory(...wn(t.deps || [])); else if (function (t) { return !(!t || !t.useExisting) }(t)) s = () => vn(f(t.useExisting)); else { const e = f(t && (t.useClass || t.provide)); if (!function (t) { return !!t.deps }(t)) return gt(e) || yi(e); s = () => new e(...wn(t.deps)) } var r; return s } function Ci(t, e, n = !1) { return { factory: t, value: e, multi: n ? [] : void 0 } } function Oi(t) { return null !== t && "object" == typeof t && gn in t } function Si(t) { return "function" == typeof t } const xi = function (t, e, n) { return function (t, e = null, n = null, s) { const r = _i(t, e, n, s); return r._resolveInjectorDefTypes(), r }({ name: n }, e, t, n) }; let Ei = (() => { class t { static create(t, e) { return Array.isArray(t) ? xi(t, e, "") : xi(t.providers, t.parent, t.name || "") } } return t.THROW_IF_NOT_FOUND = pn, t.NULL = new hi, t.\u0275prov = y({ token: t, providedIn: "any", factory: () => vn(ui) }), t.__NG_ELEMENT_ID__ = -1, t })(); function Ti(t, e) { be(It(t)[1], $t()) } function ki(t) { let e = Object.getPrototypeOf(t.type.prototype).constructor, n = !0; const s = [t]; for (; e;) { let r; if (ft(t)) r = e.\u0275cmp || e.\u0275dir; else { if (e.\u0275cmp) throw new Error("Directives cannot inherit Components"); r = e.\u0275dir } if (r) { if (n) { s.push(r); const e = t; e.inputs = ji(t.inputs), e.declaredInputs = ji(t.declaredInputs), e.outputs = ji(t.outputs); const n = r.hostBindings; n && Li(t, n); const i = r.viewQuery, o = r.contentQueries; if (i && Ai(t, i), o && Ri(t, o), l(t.inputs, r.inputs), l(t.declaredInputs, r.declaredInputs), l(t.outputs, r.outputs), ft(r) && r.data.animation) { const e = t.data; e.animation = (e.animation || []).concat(r.data.animation) } } const e = r.features; if (e) for (let s = 0; s < e.length; s++) { const r = e[s]; r && r.ngInherit && r(t), r === ki && (n = !1) } } e = Object.getPrototypeOf(e) } !function (t) { let e = 0, n = null; for (let s = t.length - 1; s >= 0; s--) { const r = t[s]; r.hostVars = e += r.hostVars, r.hostAttrs = Te(r.hostAttrs, n = Te(n, r.hostAttrs)) } }(s) } function ji(t) { return t === U ? {} : t === z ? [] : t } function Ai(t, e) { const n = t.viewQuery; t.viewQuery = n ? (t, s) => { e(t, s), n(t, s) } : e } function Ri(t, e) { const n = t.contentQueries; t.contentQueries = n ? (t, s, r) => { e(t, s, r), n(t, s, r) } : e } function Li(t, e) { const n = t.hostBindings; t.hostBindings = n ? (t, s) => { e(t, s), n(t, s) } : e } let Ii = null; function Pi() { if (!Ii) { const t = B.Symbol; if (t && t.iterator) Ii = t.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const n = t[e]; "entries" !== n && "size" !== n && Map.prototype[n] === Map.prototype.entries && (Ii = n) } } } return Ii } class Di { constructor(t) { this.wrapped = t } static wrap(t) { return new Di(t) } static unwrap(t) { return Di.isWrapped(t) ? t.wrapped : t } static isWrapped(t) { return t instanceof Di } } function Mi(t) { return !!Ni(t) && (Array.isArray(t) || !(t instanceof Map) && Pi() in t) } function Ni(t) { return null !== t && ("function" == typeof t || "object" == typeof t) } function Fi(t, e, n) { return t[e] = n } function Vi(t, e, n) { return !Object.is(t[e], n) && (t[e] = n, !0) } function Bi(t, e, n, s) { const r = Vi(t, e, n); return Vi(t, e + 1, s) || r } function Ui(t, e, n, s, r) { const i = Bi(t, e, n, s); return Vi(t, e + 2, r) || i } function Hi(t, e, n, s) { const r = Ut(); return Vi(r, Jt(), e) && (Ht(), Wr(ge(), r, t, e, n, s)), Hi } function zi(t, e, n, s) { return Vi(t, Jt(), n) ? e + b(n) + s : dr } function $i(t, e, n, s, r, i) { const o = Bi(t, Qt(), n, r); return te(2), o ? e + b(n) + s + b(r) + i : dr } function Wi(t, e, n, s, r, i) { const o = Ut(), a = zi(o, e, n, s); return a !== dr && Wr(ge(), o, t, a, r, i), Wi } function qi(t, e, n, s, r, i, o, a) { const c = Ut(), l = $i(c, e, n, s, r, i); return l !== dr && Wr(ge(), c, t, l, o, a), qi } function Gi(t, e, n, s, r, i, o, a) { const c = Ut(), l = Ht(), u = t + 20, h = l.firstCreatePass ? function (t, e, n, s, r, i, o, a, c) { const l = e.consts, u = Or(e, t, 4, o || null, Mt(l, a)); Nr(e, n, u, Mt(l, c)), be(e, u); const h = u.tViews = Ir(2, u, s, r, i, e.directiveRegistry, e.pipeRegistry, null, e.schemas, l); return null !== e.queries && (e.queries.template(e, u), h.queries = e.queries.embeddedTView(u)), u }(u, l, c, e, n, s, r, i, o) : l.data[u]; qt(h, !1); const d = c[11].createComment(""); qs(l, c, d, h), Cs(d, c), Qr(c, c[u] = Xr(d, c, d, h)), pt(h) && Ar(l, c, h), null != o && Rr(c, h, a) } function Xi(t) { return Rt(Vt.lFrame.contextLView, 20 + t) } function Ki(t, e = j.Default) { const n = Ut(); return null === n ? vn(t, e) : He($t(), n, f(t), e) } function Zi(t, e, n) { const s = Ut(); return Vi(s, Jt(), e) && Mr(Ht(), ge(), s, t, e, s[11], n, !1), Zi } function Yi(t, e, n, s, r) { const i = r ? "class" : "style"; ai(t, n, e.inputs[i], i, s) } function Qi(t, e, n, s) { const r = Ut(), i = Ht(), o = 20 + t, a = r[11], c = r[o] = Ps(a, e, Vt.lFrame.currentNamespace), l = i.firstCreatePass ? function (t, e, n, s, r, i, o) { const a = e.consts, c = Or(e, t, 2, r, Mt(a, i)); return Nr(e, n, c, Mt(a, o)), null !== c.attrs && li(c, c.attrs, !1), null !== c.mergedAttrs && li(c, c.mergedAttrs, !0), null !== e.queries && e.queries.elementStart(e, c), c }(o, i, r, 0, e, n, s) : i.data[o]; qt(l, !0); const u = l.mergedAttrs; null !== u && Se(a, c, u); const h = l.classes; null !== h && tr(a, c, h); const d = l.styles; null !== d && Js(a, c, d), 64 != (64 & l.flags) && qs(i, r, c, l), 0 === Vt.lFrame.elementDepthCount && Cs(c, r), Vt.lFrame.elementDepthCount++, pt(l) && (Ar(i, r, l), jr(i, l, r)), null !== s && Rr(r, l) } function Ji() { let t = $t(); Gt() ? Xt() : (t = t.parent, qt(t, !1)); const e = t; Vt.lFrame.elementDepthCount--; const n = Ht(); n.firstCreatePass && (be(n, t), ht(t) && n.queries.elementEnd(t)), null != e.classesWithoutHost && function (t) { return 0 != (16 & t.flags) }(e) && Yi(n, e, Ut(), e.classesWithoutHost, !0), null != e.stylesWithoutHost && function (t) { return 0 != (32 & t.flags) }(e) && Yi(n, e, Ut(), e.stylesWithoutHost, !1) } function to(t, e, n, s) { Qi(t, e, n, s), Ji() } function eo(t, e, n) { const s = Ut(), r = Ht(), i = t + 20, o = r.firstCreatePass ? function (t, e, n, s, r) { const i = e.consts, o = Mt(i, s), a = Or(e, t, 8, "ng-container", o); return null !== o && li(a, o, !0), Nr(e, n, a, Mt(i, r)), null !== e.queries && e.queries.elementStart(e, a), a }(i, r, s, e, n) : r.data[i]; qt(o, !0); const a = s[i] = s[11].createComment(""); qs(r, s, a, o), Cs(a, s), pt(o) && (Ar(r, s, o), jr(r, o, s)), null != n && Rr(s, o) } function no() { let t = $t(); const e = Ht(); Gt() ? Xt() : (t = t.parent, qt(t, !1)), e.firstCreatePass && (be(e, t), ht(t) && e.queries.elementEnd(t)) } function so(t, e, n) { eo(t, e, n), no() } function ro() { return Ut() } function io(t) { return !!t && "function" == typeof t.then } function oo(t) { return !!t && "function" == typeof t.subscribe } const ao = oo; function co(t, e, n = !1, s) { const r = Ut(), i = Ht(), o = $t(); return function (t, e, n, s, r, i, o = !1, a) { const c = pt(s), l = t.firstCreatePass && ii(t), u = ri(e); let h = !0; if (3 & s.type) { const d = jt(s, e), p = a ? a(d) : U, f = p.target || d, g = u.length, m = a ? t => a(Tt(t[s.index])).target : s.index; if (xt(n)) { let o = null; if (!a && c && (o = function (t, e, n, s) { const r = t.cleanup; if (null != r) for (let i = 0; i < r.length - 1; i += 2) { const t = r[i]; if (t === n && r[i + 1] === s) { const t = e[7], n = r[i + 2]; return t.length > n ? t[n] : null } "string" == typeof t && (i += 2) } return null }(t, e, r, s.index)), null !== o) (o.__ngLastListenerFn__ || o).__ngNextListenerFn__ = i, o.__ngLastListenerFn__ = i, h = !1; else { i = uo(s, e, 0, i, !1); const t = n.listen(p.name || f, r, i); u.push(i, t), l && l.push(r, m, g, g + 1) } } else i = uo(s, e, 0, i, !0), f.addEventListener(r, i, o), u.push(i), l && l.push(r, m, g, o) } else i = uo(s, e, 0, i, !1); const d = s.outputs; let p; if (h && null !== d && (p = d[r])) { const t = p.length; if (t) for (let n = 0; n < t; n += 2) { const t = e[p[n]][p[n + 1]].subscribe(i), o = u.length; u.push(i, t), l && l.push(r, s.index, o, -(o + 1)) } } }(i, r, r[11], o, t, e, n, s), co } function lo(t, e, n, s) { try { return !1 !== n(s) } catch (r) { return oi(t, r), !1 } } function uo(t, e, n, s, r) { return function n(i) { if (i === Function) return s; const o = 2 & t.flags ? Lt(t.index, e) : e; 0 == (32 & e[2]) && Jr(o); let a = lo(e, 0, s, i), c = n.__ngNextListenerFn__; for (; c;)a = lo(e, 0, c, i) && a, c = c.__ngNextListenerFn__; return r && !1 === a && (i.preventDefault(), i.returnValue = !1), a } } function ho(t = 1) { return function (t) { return (Vt.lFrame.contextLView = function (t, e) { for (; t > 0;)e = e[15], t--; return e }(t, Vt.lFrame.contextLView))[8] }(t) } function po(t, e) { let n = null; const s = function (t) { const e = t.attrs; if (null != e) { const t = e.indexOf(5); if (0 == (1 & t)) return e[t + 1] } return null }(t); for (let r = 0; r < e.length; r++) { const i = e[r]; if ("*" !== i) { if (null === s ? cr(t, i, !0) : lr(s, i)) return r } else n = r } return n } function fo(t) { const e = Ut()[16][6]; if (!e.projection) { const n = e.projection = ln(t ? t.length : 1, null), s = n.slice(); let r = e.child; for (; null !== r;) { const e = t ? po(r, t) : 0; null !== e && (s[e] ? s[e].projectionNext = r : n[e] = r, s[e] = r), r = r.next } } } function go(t, e = 0, n) { const s = Ut(), r = Ht(), i = Or(r, 20 + t, 16, null, n || null); null === i.projection && (i.projection = e), Xt(), 64 != (64 & i.flags) && function (t, e, n) { Qs(e[11], 0, e, n, Vs(t, n, e), $s(n.parent || e[6], n, e)) }(r, s, i) } function mo(t, e, n) { return bo(t, "", e, "", n), mo } function bo(t, e, n, s, r) { const i = Ut(), o = zi(i, e, n, s); return o !== dr && Mr(Ht(), ge(), i, t, o, i[11], r, !1), bo } function _o(t, e, n, s, r, i, o) { const a = Ut(), c = $i(a, e, n, s, r, i); return c !== dr && Mr(Ht(), ge(), a, t, c, a[11], o, !1), _o } function vo(t, e, n, s, r) { const i = t[n + 1], o = null === e; let a = s ? mr(i) : _r(i), c = !1; for (; 0 !== a && (!1 === c || o);) { const n = t[a + 1]; yo(t[a], e) && (c = !0, t[a + 1] = s ? yr(n) : br(n)), a = s ? mr(n) : _r(n) } c && (t[n + 1] = s ? br(i) : yr(i)) } function yo(t, e) { return null === t || null == e || (Array.isArray(t) ? t[1] : t) === e || !(!Array.isArray(t) || "string" != typeof e) && dn(t, e) >= 0 } const wo = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function Co(t) { return t.substring(wo.key, wo.keyEnd) } function Oo(t, e) { const n = wo.textEnd; return n === e ? -1 : (e = wo.keyEnd = function (t, e, n) { for (; e < n && t.charCodeAt(e) > 32;)e++; return e }(t, wo.key = e, n), So(t, e, n)) } function So(t, e, n) { for (; e < n && t.charCodeAt(e) <= 32;)e++; return e } function xo(t, e, n) { return jo(t, e, n, !1), xo } function Eo(t, e) { return jo(t, e, null, !0), Eo } function To(t) { Ao(un, ko, t, !0) } function ko(t, e) { for (let n = function (t) { return function (t) { wo.key = 0, wo.keyEnd = 0, wo.value = 0, wo.valueEnd = 0, wo.textEnd = t.length }(t), Oo(t, So(t, 0, wo.textEnd)) }(e); n >= 0; n = Oo(e, n))un(t, Co(e), !0) } function jo(t, e, n, s) { const r = Ut(), i = Ht(), o = te(2); i.firstUpdatePass && Lo(i, t, o, s), e !== dr && Vi(r, o, e) && Do(i, i.data[pe()], r, r[11], t, r[o + 1] = function (t, e) { return null == t || ("string" == typeof e ? t += e : "object" == typeof t && (t = u(Nn(t)))), t }(e, n), s, o) } function Ao(t, e, n, s) { const r = Ht(), i = te(2); r.firstUpdatePass && Lo(r, null, i, s); const o = Ut(); if (n !== dr && Vi(o, i, n)) { const a = r.data[pe()]; if (Fo(a, s) && !Ro(r, i)) { let t = s ? a.classesWithoutHost : a.stylesWithoutHost; null !== t && (n = h(t, n || "")), Yi(r, a, o, n, s) } else !function (t, e, n, s, r, i, o, a) { r === dr && (r = H); let c = 0, l = 0, u = 0 < r.length ? r[0] : null, h = 0 < i.length ? i[0] : null; for (; null !== u || null !== h;) { const d = c < r.length ? r[c + 1] : void 0, p = l < i.length ? i[l + 1] : void 0; let f, g = null; u === h ? (c += 2, l += 2, d !== p && (g = h, f = p)) : null === h || null !== u && u < h ? (c += 2, g = u) : (l += 2, g = h, f = p), null !== g && Do(t, e, n, s, g, f, o, a), u = c < r.length ? r[c] : null, h = l < i.length ? i[l] : null } }(r, a, o, o[11], o[i + 1], o[i + 1] = function (t, e, n) { if (null == n || "" === n) return H; const s = [], r = Nn(n); if (Array.isArray(r)) for (let i = 0; i < r.length; i++)t(s, r[i], !0); else if ("object" == typeof r) for (const i in r) r.hasOwnProperty(i) && t(s, i, r[i]); else "string" == typeof r && e(s, r); return s }(t, e, n), s, i) } } function Ro(t, e) { return e >= t.expandoStartIndex } function Lo(t, e, n, s) { const r = t.data; if (null === r[n + 1]) { const i = r[pe()], o = Ro(t, n); Fo(i, s) && null === e && !o && (e = !1), e = function (t, e, n, s) { const r = function (t) { const e = Vt.lFrame.currentDirectiveIndex; return -1 === e ? null : t[e] }(t); let i = s ? e.residualClasses : e.residualStyles; if (null === r) 0 === (s ? e.classBindings : e.styleBindings) && (n = Po(n = Io(null, t, e, n, s), e.attrs, s), i = null); else { const o = e.directiveStylingLast; if (-1 === o || t[o] !== r) if (n = Io(r, t, e, n, s), null === i) { let n = function (t, e, n) { const s = n ? e.classBindings : e.styleBindings; if (0 !== _r(s)) return t[mr(s)] }(t, e, s); void 0 !== n && Array.isArray(n) && (n = Io(null, t, e, n[1], s), n = Po(n, e.attrs, s), function (t, e, n, s) { t[mr(n ? e.classBindings : e.styleBindings)] = s }(t, e, s, n)) } else i = function (t, e, n) { let s; const r = e.directiveEnd; for (let i = 1 + e.directiveStylingLast; i < r; i++)s = Po(s, t[i].hostAttrs, n); return Po(s, e.attrs, n) }(t, e, s) } return void 0 !== i && (s ? e.residualClasses = i : e.residualStyles = i), n }(r, i, e, s), function (t, e, n, s, r, i) { let o = i ? e.classBindings : e.styleBindings, a = mr(o), c = _r(o); t[s] = n; let l, u = !1; if (Array.isArray(n)) { const t = n; l = t[1], (null === l || dn(t, l) > 0) && (u = !0) } else l = n; if (r) if (0 !== c) { const e = mr(t[a + 1]); t[s + 1] = gr(e, a), 0 !== e && (t[e + 1] = vr(t[e + 1], s)), t[a + 1] = 131071 & t[a + 1] | s << 17 } else t[s + 1] = gr(a, 0), 0 !== a && (t[a + 1] = vr(t[a + 1], s)), a = s; else t[s + 1] = gr(c, 0), 0 === a ? a = s : t[c + 1] = vr(t[c + 1], s), c = s; u && (t[s + 1] = br(t[s + 1])), vo(t, l, s, !0), vo(t, l, s, !1), function (t, e, n, s, r) { const i = r ? t.residualClasses : t.residualStyles; null != i && "string" == typeof e && dn(i, e) >= 0 && (n[s + 1] = yr(n[s + 1])) }(e, l, t, s, i), o = gr(a, c), i ? e.classBindings = o : e.styleBindings = o }(r, i, e, n, o, s) } } function Io(t, e, n, s, r) { let i = null; const o = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < o && (i = e[a], s = Po(s, i.hostAttrs, r), i !== t);)a++; return null !== t && (n.directiveStylingLast = a), s } function Po(t, e, n) { const s = n ? 1 : 2; let r = -1; if (null !== e) for (let i = 0; i < e.length; i++) { const o = e[i]; "number" == typeof o ? r = o : r === s && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), un(t, o, !!n || e[++i])) } return void 0 === t ? null : t } function Do(t, e, n, s, r, i, o, a) { if (!(3 & e.type)) return; const c = t.data, l = c[a + 1]; No(1 == (1 & l) ? Mo(c, e, n, r, _r(l), o) : void 0) || (No(i) || 2 == (2 & l) && (i = Mo(c, null, n, r, a, o)), function (t, e, n, s, r) { const i = xt(t); if (e) r ? i ? t.addClass(n, s) : n.classList.add(s) : i ? t.removeClass(n, s) : n.classList.remove(s); else { let e = -1 === s.indexOf("-") ? void 0 : Ts.DashCase; if (null == r) i ? t.removeStyle(n, s, e) : n.style.removeProperty(s); else { const o = "string" == typeof r && r.endsWith("!important"); o && (r = r.slice(0, -10), e |= Ts.Important), i ? t.setStyle(n, s, r, e) : n.style.setProperty(s, r, o ? "important" : "") } } }(s, o, kt(pe(), n), r, i)) } function Mo(t, e, n, s, r, i) { const o = null === e; let a; for (; r > 0;) { const e = t[r], i = Array.isArray(e), c = i ? e[1] : e, l = null === c; let u = n[r + 1]; u === dr && (u = l ? H : void 0); let h = l ? hn(u, s) : c === s ? u : void 0; if (i && !No(h) && (h = hn(e, s)), No(h) && (a = h, o)) return a; const d = t[r + 1]; r = o ? mr(d) : _r(d) } if (null !== e) { let t = i ? e.residualClasses : e.residualStyles; null != t && (a = hn(t, s)) } return a } function No(t) { return void 0 !== t } function Fo(t, e) { return 0 != (t.flags & (e ? 16 : 32)) } function Vo(t, e = "") { const n = Ut(), s = Ht(), r = t + 20, i = s.firstCreatePass ? Or(s, r, 1, e, null) : s.data[r], o = n[r] = function (t, e) { return xt(t) ? t.createText(e) : t.createTextNode(e) }(n[11], e); qs(s, n, o, i), qt(i, !1) } function Bo(t) { return Uo("", t, ""), Bo } function Uo(t, e, n) { const s = Ut(), r = zi(s, t, e, n); return r !== dr && ci(s, pe(), r), Uo } function Ho(t, e, n, s, r) { const i = Ut(), o = $i(i, t, e, n, s, r); return o !== dr && ci(i, pe(), o), Ho } function zo(t, e, n, s, r, i, o) { const a = Ut(), c = function (t, e, n, s, r, i, o, a) { const c = Ui(t, Qt(), n, r, o); return te(3), c ? e + b(n) + s + b(r) + i + b(o) + a : dr }(a, t, e, n, s, r, i, o); return c !== dr && ci(a, pe(), c), zo } function $o(t, e, n) { Ao(un, ko, zi(Ut(), t, e, n), !0) } function Wo(t, e, n, s, r) { Ao(un, ko, $i(Ut(), t, e, n, s, r), !0) } function qo(t, e, n) { const s = Ut(); return Vi(s, Jt(), e) && Mr(Ht(), ge(), s, t, e, s[11], n, !0), qo } const Go = void 0; var Xo = ["en", [["a", "p"], ["AM", "PM"], Go], [["AM", "PM"], Go, Go], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], Go, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], Go, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", Go, "{1} 'at' {0}", Go], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function (t) { let e = Math.floor(Math.abs(t)), n = t.toString().replace(/^[^.]*\.?/, "").length; return 1 === e && 0 === n ? 1 : 5 }]; let Ko = {}; function Zo(t, e, n) { "string" != typeof e && (n = e, e = t[ea.LocaleId]), e = e.toLowerCase().replace(/_/g, "-"), Ko[e] = t, n && (Ko[e][ea.ExtraData] = n) } function Yo(t) { const e = function (t) { return t.toLowerCase().replace(/_/g, "-") }(t); let n = ta(e); if (n) return n; const s = e.split("-")[0]; if (n = ta(s), n) return n; if ("en" === s) return Xo; throw new Error(`Missing locale data for the locale "${t}".`) } function Qo(t) { return Yo(t)[ea.CurrencyCode] || null } function Jo(t) { return Yo(t)[ea.PluralCase] } function ta(t) { return t in Ko || (Ko[t] = B.ng && B.ng.common && B.ng.common.locales && B.ng.common.locales[t]), Ko[t] } var ea = function (t) { return t[t.LocaleId = 0] = "LocaleId", t[t.DayPeriodsFormat = 1] = "DayPeriodsFormat", t[t.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", t[t.DaysFormat = 3] = "DaysFormat", t[t.DaysStandalone = 4] = "DaysStandalone", t[t.MonthsFormat = 5] = "MonthsFormat", t[t.MonthsStandalone = 6] = "MonthsStandalone", t[t.Eras = 7] = "Eras", t[t.FirstDayOfWeek = 8] = "FirstDayOfWeek", t[t.WeekendRange = 9] = "WeekendRange", t[t.DateFormat = 10] = "DateFormat", t[t.TimeFormat = 11] = "TimeFormat", t[t.DateTimeFormat = 12] = "DateTimeFormat", t[t.NumberSymbols = 13] = "NumberSymbols", t[t.NumberFormats = 14] = "NumberFormats", t[t.CurrencyCode = 15] = "CurrencyCode", t[t.CurrencySymbol = 16] = "CurrencySymbol", t[t.CurrencyName = 17] = "CurrencyName", t[t.Currencies = 18] = "Currencies", t[t.Directionality = 19] = "Directionality", t[t.PluralCase = 20] = "PluralCase", t[t.ExtraData = 21] = "ExtraData", t }({}); let na = "en-US"; function sa(t) { var e, n; n = "Expected localeId to be defined", null == (e = t) && function (t, e, n, s) { throw new Error(`ASSERTION ERROR: ${t} [Expected=> null != ${e} <=Actual]`) }(n, e), "string" == typeof t && (na = t.toLowerCase().replace(/_/g, "-")) } function ra(t, e, n, s, r) { if (t = f(t), Array.isArray(t)) for (let i = 0; i < t.length; i++)ra(t[i], e, n, s, r); else { const i = Ht(), o = Ut(); let a = Si(t) ? t : f(t.provide), c = wi(t); const l = $t(), u = 1048575 & l.providerIndexes, h = l.directiveStart, d = l.providerIndexes >> 20; if (Si(t) || !t.multi) { const s = new Oe(c, r, Ki), p = aa(a, e, r ? u : u + d, h); -1 === p ? (Ve(De(l, o), i, a), ia(i, t, e.length), e.push(a), l.directiveStart++, l.directiveEnd++, r && (l.providerIndexes += 1048576), n.push(s), o.push(s)) : (n[p] = s, o[p] = s) } else { const p = aa(a, e, u + d, h), f = aa(a, e, u, u + d), g = p >= 0 && n[p], m = f >= 0 && n[f]; if (r && !m || !r && !g) { Ve(De(l, o), i, a); const u = function (t, e, n, s, r) { const i = new Oe(t, n, Ki); return i.multi = [], i.index = e, i.componentProviders = 0, oa(i, r, s && !n), i }(r ? la : ca, n.length, r, s, c); !r && m && (n[f].providerFactory = u), ia(i, t, e.length, 0), e.push(a), l.directiveStart++, l.directiveEnd++, r && (l.providerIndexes += 1048576), n.push(u), o.push(u) } else ia(i, t, p > -1 ? p : f, oa(n[r ? f : p], c, !r && s)); !r && s && m && n[f].componentProviders++ } } } function ia(t, e, n, s) { const r = Si(e); if (r || e.useClass) { const i = (e.useClass || e).prototype.ngOnDestroy; if (i) { const o = t.destroyHooks || (t.destroyHooks = []); if (!r && e.multi) { const t = o.indexOf(n); -1 === t ? o.push(n, [s, i]) : o[t + 1].push(s, i) } else o.push(n, i) } } } function oa(t, e, n) { return n && t.componentProviders++, t.multi.push(e) - 1 } function aa(t, e, n, s) { for (let r = n; r < s; r++)if (e[r] === t) return r; return -1 } function ca(t, e, n, s) { return ua(this.multi, []) } function la(t, e, n, s) { const r = this.multi; let i; if (this.providerFactory) { const t = this.providerFactory.componentProviders, e = Ge(n, n[1], this.providerFactory.index, s); i = e.slice(0, t), ua(r, i); for (let n = t; n < e.length; n++)i.push(e[n]) } else i = [], ua(r, i); return i } function ua(t, e) { for (let n = 0; n < t.length; n++)e.push((0, t[n])()); return e } function ha(t, e = []) { return n => { n.providersResolver = (n, s) => function (t, e, n) { const s = Ht(); if (s.firstCreatePass) { const r = ft(t); ra(n, s.data, s.blueprint, r, !0), ra(e, s.data, s.blueprint, r, !1) } }(n, s ? s(t) : t, e) } } class da { } class pa { resolveComponentFactory(t) { throw function (t) { const e = Error(`No component factory found for ${u(t)}. Did you add it to @NgModule.entryComponents?`); return e.ngComponent = t, e }(t) } } let fa = (() => { class t { } return t.NULL = new pa, t })(); function ga(...t) { } function ma(t, e) { return new _a(jt(t, e)) } const ba = function () { return ma($t(), Ut()) }; let _a = (() => { class t { constructor(t) { this.nativeElement = t } } return t.__NG_ELEMENT_ID__ = ba, t })(); function va(t) { return t instanceof _a ? t.nativeElement : t } class ya { } let wa = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => Ca(), t })(); const Ca = function () { const t = Ut(), e = Lt($t().index, t); return function (t) { return t[11] }(lt(e) ? e : t) }; let Oa = (() => { class t { } return t.\u0275prov = y({ token: t, providedIn: "root", factory: () => null }), t })(); class Sa { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const xa = new Sa("11.2.12"); class Ea { constructor() { } supports(t) { return Mi(t) } create(t) { return new ka(t) } } const Ta = (t, e) => e; class ka { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || Ta } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next)t(e) } forEachOperation(t) { let e = this._itHead, n = this._removalsHead, s = 0, r = null; for (; e || n;) { const i = !n || e && e.currentIndex < La(n, s, r) ? e : n, o = La(i, s, r), a = i.currentIndex; if (i === n) s--, n = n._nextRemoved; else if (e = e._next, null == i.previousIndex) s++; else { r || (r = []); const t = o - s, e = a - s; if (t != e) { for (let n = 0; n < t; n++) { const s = n < r.length ? r[n] : r[n] = 0, i = s + n; e <= i && i < t && (r[n] = s + 1) } r[i.previousIndex] = e - t } } o !== a && t(i, o, a) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)t(e) } diff(t) { if (null == t && (t = []), !Mi(t)) throw new Error(`Error trying to diff '${u(t)}'. Only arrays and iterables are allowed`); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e, n, s, r = this._itHead, i = !1; if (Array.isArray(t)) { this.length = t.length; for (let e = 0; e < this.length; e++)n = t[e], s = this._trackByFn(e, n), null !== r && Object.is(r.trackById, s) ? (i && (r = this._verifyReinsertion(r, n, s, e)), Object.is(r.item, n) || this._addIdentityChange(r, n)) : (r = this._mismatch(r, n, s, e), i = !0), r = r._next } else e = 0, function (t, e) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++)e(t[n]); else { const n = t[Pi()](); let s; for (; !(s = n.next()).done;)e(s.value) } }(t, t => { s = this._trackByFn(e, t), null !== r && Object.is(r.trackById, s) ? (i && (r = this._verifyReinsertion(r, t, s, e)), Object.is(r.item, t) || this._addIdentityChange(r, t)) : (r = this._mismatch(r, t, s, e), i = !0), r = r._next, e++ }), this.length = e; return this._truncate(r), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, n, s) { let r; return null === t ? r = this._itTail : (r = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, r, s)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(n, s)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, r, s)) : t = this._addAfter(new ja(e, n), r, s), t } _verifyReinsertion(t, e, n, s) { let r = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null); return null !== r ? t = this._reinsertAfter(r, t._prev, s) : t.currentIndex != s && (t.currentIndex = s, this._addToMoves(t, s)), t } _truncate(t) { for (; null !== t;) { const e = t._next; this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, n) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const s = t._prevRemoved, r = t._nextRemoved; return null === s ? this._removalsHead = r : s._nextRemoved = r, null === r ? this._removalsTail = s : r._prevRemoved = s, this._insertAfter(t, e, n), this._addToMoves(t, n), t } _moveAfter(t, e, n) { return this._unlink(t), this._insertAfter(t, e, n), this._addToMoves(t, n), t } _addAfter(t, e, n) { return this._insertAfter(t, e, n), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, n) { const s = null === e ? this._itHead : e._next; return t._next = s, t._prev = e, null === s ? this._itTail = t : s._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new Ra), this._linkedRecords.put(t), t.currentIndex = n, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev, n = t._next; return null === e ? this._itHead = n : e._next = n, null === n ? this._itTail = e : n._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new Ra), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class ja { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class Aa { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let n; for (n = this._head; null !== n; n = n._nextDup)if ((null === e || e <= n.currentIndex) && Object.is(n.trackById, t)) return n; return null } remove(t) { const e = t._prevDup, n = t._nextDup; return null === e ? this._head = n : e._nextDup = n, null === n ? this._tail = e : n._prevDup = e, null === this._head } } class Ra { constructor() { this.map = new Map } put(t) { const e = t.trackById; let n = this.map.get(e); n || (n = new Aa, this.map.set(e, n)), n.add(t) } get(t, e) { const n = this.map.get(t); return n ? n.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function La(t, e, n) { const s = t.previousIndex; if (null === s) return s; let r = 0; return n && s < n.length && (r = n[s]), s + e + r } class Ia { constructor() { } supports(t) { return t instanceof Map || Ni(t) } create() { return new Pa } } class Pa { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next)t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } diff(t) { if (t) { if (!(t instanceof Map || Ni(t))) throw new Error(`Error trying to diff '${u(t)}'. Only maps and objects are allowed`) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (t, n) => { if (e && e.key === n) this._maybeAddToChanges(e, t), this._appendAfter = e, e = e._next; else { const s = this._getOrCreateRecordForKey(n, t); e = this._insertBeforeOrAppend(e, s) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let t = e; null !== t; t = t._nextRemoved)t === this._mapHead && (this._mapHead = null), this._records.delete(t.key), t._nextRemoved = t._next, t.previousValue = t.currentValue, t.currentValue = null, t._prev = null, t._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const n = t._prev; return e._next = t, e._prev = n, t._prev = e, n && (n._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const n = this._records.get(t); this._maybeAddToChanges(n, e); const s = n._prev, r = n._next; return s && (s._next = r), r && (r._prev = s), n._next = null, n._prev = null, n } const n = new Da(t); return this._records.set(t, n), n.currentValue = e, this._addToAdditions(n), n } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { Object.is(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(n => e(t[n], n)) } } class Da { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function Ma() { return new Na([new Ea]) } let Na = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (null != n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => t.create(e, n || Ma()), deps: [[t, new En, new Sn]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (null != e) return e; throw new Error(`Cannot find a differ supporting object '${t}' of type '${n = t, n.name || typeof n}'`); var n } } return t.\u0275prov = y({ token: t, providedIn: "root", factory: Ma }), t })(); function Fa() { return new Va([new Ia]) } let Va = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => t.create(e, n || Fa()), deps: [[t, new En, new Sn]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (e) return e; throw new Error(`Cannot find a differ supporting object '${t}'`) } } return t.\u0275prov = y({ token: t, providedIn: "root", factory: Fa }), t })(); function Ba(t, e, n, s, r = !1) { for (; null !== n;) { const i = e[n.index]; if (null !== i && s.push(Tt(i)), ut(i)) for (let t = 10; t < i.length; t++) { const e = i[t], n = e[1].firstChild; null !== n && Ba(e[1], e, n, s) } const o = n.type; if (8 & o) Ba(t, e, n.child, s); else if (32 & o) { const t = ks(n, e); let r; for (; r = t();)s.push(r) } else if (16 & o) { const t = Xs(e, n); if (Array.isArray(t)) s.push(...t); else { const n = js(e[16]); Ba(n[1], n, t, s, !0) } } n = r ? n.projectionNext : n.next } return s } class Ua { constructor(t, e) { this._lView = t, this._cdRefInjectingView = e, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const t = this._lView, e = t[1]; return Ba(e, t, e.firstChild, []) } get context() { return this._lView[8] } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[3]; if (ut(t)) { const e = t[8], n = e ? e.indexOf(this) : -1; n > -1 && (Ms(t, n), cn(e, n)) } this._attachedToViewContainer = !1 } Ns(this._lView[1], this._lView) } onDestroy(t) { Pr(this._lView[1], this._lView, null, t) } markForCheck() { Jr(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { ti(this._lView[1], this._lView, this.context) } checkNoChanges() { !function (t, e, n) { Zt(!0); try { ti(t, e, n) } finally { Zt(!1) } }(this._lView[1], this._lView, this.context) } attachToViewContainerRef() { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._attachedToViewContainer = !0 } detachFromAppRef() { var t; this._appRef = null, Ys(this._lView[1], t = this._lView, t[11], 2, null, null) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = t } } class Ha extends Ua { constructor(t) { super(t), this._view = t } detectChanges() { ei(this._view) } checkNoChanges() { !function (t) { Zt(!0); try { ei(t) } finally { Zt(!1) } }(this._view) } get context() { return null } } const za = Wa; let $a = (() => { class t { } return t.__NG_ELEMENT_ID__ = za, t.__ChangeDetectorRef__ = !0, t })(); function Wa(t = !1) { return function (t, e, n) { if (!n && dt(t)) { const n = Lt(t.index, e); return new Ua(n, n) } return 47 & t.type ? new Ua(e[16], e) : null }($t(), Ut(), t) } const qa = [new Ia], Ga = new Na([new Ea]), Xa = new Va(qa), Ka = function () { return Ja($t(), Ut()) }; let Za = (() => { class t { } return t.__NG_ELEMENT_ID__ = Ka, t })(); const Ya = Za, Qa = class extends Ya { constructor(t, e, n) { super(), this._declarationLView = t, this._declarationTContainer = e, this.elementRef = n } createEmbeddedView(t) { const e = this._declarationTContainer.tViews, n = Cr(this._declarationLView, e, t, 16, null, e.declTNode, null, null, null, null); n[17] = this._declarationLView[this._declarationTContainer.index]; const s = this._declarationLView[19]; return null !== s && (n[19] = s.createEmbeddedView(e)), xr(e, n, t), new Ua(n) } }; function Ja(t, e) { return 4 & t.type ? new Qa(e, t, ma(t, e)) : null } class tc { } class ec { } const nc = function () { return cc($t(), Ut()) }; let sc = (() => { class t { } return t.__NG_ELEMENT_ID__ = nc, t })(); const rc = sc, ic = class extends rc { constructor(t, e, n) { super(), this._lContainer = t, this._hostTNode = e, this._hostLView = n } get element() { return ma(this._hostTNode, this._hostLView) } get injector() { return new Ze(this._hostTNode, this._hostLView) } get parentInjector() { const t = Fe(this._hostTNode, this._hostLView); if (je(t)) { const e = Re(t, this._hostLView), n = Ae(t); return new Ze(e[1].data[n + 8], e) } return new Ze(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const e = oc(this._lContainer); return null !== e && e[t] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(t, e, n) { const s = t.createEmbeddedView(e || {}); return this.insert(s, n), s } createComponent(t, e, n, s, r) { const i = n || this.parentInjector; if (!r && null == t.ngModule && i) { const t = i.get(tc, null); t && (r = t) } const o = t.create(i, s, void 0, r); return this.insert(o.hostView, e), o } insert(t, e) { const n = t._lView, s = n[1]; if (ut(n[3])) { const e = this.indexOf(t); if (-1 !== e) this.detach(e); else { const e = n[3], s = new ic(e, e[6], e[3]); s.detach(s.indexOf(t)) } } const r = this._adjustIndex(e), i = this._lContainer; !function (t, e, n, s) { const r = 10 + s, i = n.length; s > 0 && (n[r - 1][4] = e), s < i - 10 ? (e[4] = n[r], an(n, 10 + s, e)) : (n.push(e), e[4] = null), e[3] = n; const o = e[17]; null !== o && n !== o && function (t, e) { const n = t[9]; e[16] !== e[3][3][16] && (t[2] = !0), null === n ? t[9] = [e] : n.push(e) }(o, e); const a = e[19]; null !== a && a.insertView(t), e[2] |= 128 }(s, n, i, r); const o = Ks(r, i), a = n[11], c = zs(a, i[7]); return null !== c && function (t, e, n, s, r, i) { s[0] = r, s[6] = e, Ys(t, s, n, 1, r, i) }(s, i[6], a, n, c, o), t.attachToViewContainerRef(), an(ac(i), r, t), t } move(t, e) { return this.insert(t, e) } indexOf(t) { const e = oc(this._lContainer); return null !== e ? e.indexOf(t) : -1 } remove(t) { const e = this._adjustIndex(t, -1), n = Ms(this._lContainer, e); n && (cn(ac(this._lContainer), e), Ns(n[1], n)) } detach(t) { const e = this._adjustIndex(t, -1), n = Ms(this._lContainer, e); return n && null != cn(ac(this._lContainer), e) ? new Ua(n) : null } _adjustIndex(t, e = 0) { return null == t ? this.length + e : t } }; function oc(t) { return t[8] } function ac(t) { return t[8] || (t[8] = []) } function cc(t, e) { let n; const s = e[t.index]; if (ut(s)) n = s; else { let r; if (8 & t.type) r = Tt(s); else { const n = e[11]; r = n.createComment(""); const s = jt(t, e); Bs(n, zs(n, s), r, function (t, e) { return xt(t) ? t.nextSibling(e) : e.nextSibling }(n, s), !1) } e[t.index] = n = Xr(s, e, r, t), Qr(e, n) } return new ic(n, t, e) } const lc = {}; class uc extends fa { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const e = at(t); return new pc(e, this.ngModule) } } function hc(t) { const e = []; for (let n in t) t.hasOwnProperty(n) && e.push({ propName: t[n], templateName: n }); return e } const dc = new en("SCHEDULER_TOKEN", { providedIn: "root", factory: () => Os }); class pc extends da { constructor(t, e) { super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = t.selectors.map(hr).join(","), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!e } get inputs() { return hc(this.componentDef.inputs) } get outputs() { return hc(this.componentDef.outputs) } create(t, e, n, s) { const r = (s = s || this.ngModule) ? function (t, e) { return { get: (n, s, r) => { const i = t.get(n, lc, r); return i !== lc || s === lc ? i : e.get(n, s, r) } } }(t, s.injector) : t, i = r.get(ya, Et), o = r.get(Oa, null), a = i.createRenderer(null, this.componentDef), c = this.componentDef.selectors[0][0] || "div", l = n ? function (t, e, n) { if (xt(t)) return t.selectRootElement(e, n === D.ShadowDom); let s = "string" == typeof e ? t.querySelector(e) : e; return s.textContent = "", s }(a, n, this.componentDef.encapsulation) : Ps(i.createRenderer(null, this.componentDef), c, function (t) { const e = t.toLowerCase(); return "svg" === e ? "http://www.w3.org/2000/svg" : "math" === e ? "http://www.w3.org/1998/MathML/" : null }(c)), u = this.componentDef.onPush ? 576 : 528, h = { components: [], scheduler: Os, clean: si, playerHandler: null, flags: 0 }, d = Ir(0, null, null, 1, 0, null, null, null, null, null), p = Cr(null, d, h, u, null, null, i, a, o, r); let f, g; ae(p); try { const t = function (t, e, n, s, r, i) { const o = n[1]; n[20] = t; const a = Or(o, 20, 2, "#host", null), c = a.mergedAttrs = e.hostAttrs; null !== c && (li(a, c, !0), null !== t && (Se(r, t, c), null !== a.classes && tr(r, t, a.classes), null !== a.styles && Js(r, t, a.styles))); const l = s.createRenderer(t, e), u = Cr(n, Lr(e), null, e.onPush ? 64 : 16, n[20], a, s, l, null, null); return o.firstCreatePass && (Ve(De(a, n), o, e.type), Br(o, a), Hr(a, n.length, 1)), Qr(n, u), n[20] = u }(l, this.componentDef, p, i, a); if (l) if (n) Se(a, l, ["ng-version", xa.full]); else { const { attrs: t, classes: e } = function (t) { const e = [], n = []; let s = 1, r = 2; for (; s < t.length;) { let i = t[s]; if ("string" == typeof i) 2 === r ? "" !== i && e.push(i, t[++s]) : 8 === r && n.push(i); else { if (!or(r)) break; r = i } s++ } return { attrs: e, classes: n } }(this.componentDef.selectors[0]); t && Se(a, l, t), e && e.length > 0 && tr(a, l, e.join(" ")) } if (g = At(d, 20), void 0 !== e) { const t = g.projection = []; for (let n = 0; n < this.ngContentSelectors.length; n++) { const s = e[n]; t.push(null != s ? Array.from(s) : null) } } f = function (t, e, n, s, r) { const i = n[1], o = function (t, e, n) { const s = $t(); t.firstCreatePass && (n.providersResolver && n.providersResolver(n), zr(t, s, e, Sr(t, e, 1, null), n)); const r = Ge(e, t, s.directiveStart, s); Cs(r, e); const i = jt(s, e); return i && Cs(i, e), r }(i, n, e); if (s.components.push(o), t[8] = o, r && r.forEach(t => t(o, e)), e.contentQueries) { const t = $t(); e.contentQueries(1, o, t.directiveStart) } const a = $t(); return !i.firstCreatePass || null === e.hostBindings && null === e.hostAttrs || (fe(a.index), Fr(n[1], a, 0, a.directiveStart, a.directiveEnd, e), Vr(e, o)), o }(t, this.componentDef, p, h, [Ti]), xr(d, p, null) } finally { de() } return new fc(this.componentType, f, ma(g, p), p, g) } } class fc extends class { }{ constructor(t, e, n, s, r) { super(), this.location = n, this._rootLView = s, this._tNode = r, this.instance = e, this.hostView = this.changeDetectorRef = new Ha(s), this.componentType = t } get injector() { return new Ze(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } const gc = new Map; class mc extends tc { constructor(t, e) { super(), this._parent = e, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new uc(this); const n = ct(t), s = t[X] || null; s && sa(s), this._bootstrapComponents = Es(n.bootstrap), this._r3Injector = _i(t, e, [{ provide: tc, useValue: this }, { provide: fa, useValue: this.componentFactoryResolver }], u(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t) } get(t, e = Ei.THROW_IF_NOT_FOUND, n = j.Default) { return t === Ei || t === tc || t === ui ? this : this._r3Injector.get(t, e, n) } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(t => t()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class bc extends ec { constructor(t) { super(), this.moduleType = t, null !== ct(t) && function (t) { const e = new Set; !function t(n) { const s = ct(n, !0), r = s.id; null !== r && (function (t, e, n) { if (e && e !== n) throw new Error(`Duplicate module registered for ${t} - ${u(e)} vs ${u(e.name)}`) }(r, gc.get(r), n), gc.set(r, n)); const i = Es(s.imports); for (const o of i) e.has(o) || (e.add(o), t(o)) }(t) }(t) } create(t) { return new mc(this.moduleType, t) } } function _c(t, e, n) { const s = Yt() + t, r = Ut(); return r[s] === dr ? Fi(r, s, n ? e.call(n) : e()) : function (t, e) { return t[e] }(r, s) } function vc(t, e, n, s) { return Sc(Ut(), Yt(), t, e, n, s) } function yc(t, e, n, s, r) { return xc(Ut(), Yt(), t, e, n, s, r) } function wc(t, e, n, s, r, i) { return Ec(Ut(), Yt(), t, e, n, s, r, i) } function Cc(t, e, n, s, r, i, o) { return function (t, e, n, s, r, i, o, a, c) { const l = e + n; return function (t, e, n, s, r, i) { const o = Bi(t, e, n, s); return Bi(t, e + 2, r, i) || o }(t, l, r, i, o, a) ? Fi(t, l + 4, c ? s.call(c, r, i, o, a) : s(r, i, o, a)) : Oc(t, l + 4) }(Ut(), Yt(), t, e, n, s, r, i, o) } function Oc(t, e) { const n = t[e]; return n === dr ? void 0 : n } function Sc(t, e, n, s, r, i) { const o = e + n; return Vi(t, o, r) ? Fi(t, o + 1, i ? s.call(i, r) : s(r)) : Oc(t, o + 1) } function xc(t, e, n, s, r, i, o) { const a = e + n; return Bi(t, a, r, i) ? Fi(t, a + 2, o ? s.call(o, r, i) : s(r, i)) : Oc(t, a + 2) } function Ec(t, e, n, s, r, i, o, a) { const c = e + n; return Ui(t, c, r, i, o) ? Fi(t, c + 3, a ? s.call(a, r, i, o) : s(r, i, o)) : Oc(t, c + 3) } function Tc(t, e) { const n = Ht(); let s; const r = t + 20; n.firstCreatePass ? (s = function (t, e) { if (e) for (let n = e.length - 1; n >= 0; n--) { const s = e[n]; if (t === s.name) return s } throw new m("302", `The pipe '${t}' could not be found!`) }(e, n.pipeRegistry), n.data[r] = s, s.onDestroy && (n.destroyHooks || (n.destroyHooks = [])).push(r, s.onDestroy)) : s = n.data[r]; const i = s.factory || (s.factory = gt(s.type)), o = R(Ki); try { const t = Ie(!1), e = i(); return Ie(t), function (t, e, n, s) { n >= t.data.length && (t.data[n] = null, t.blueprint[n] = null), e[n] = s }(n, Ut(), r, e), e } finally { R(o) } } function kc(t, e, n) { const s = t + 20, r = Ut(), i = Rt(r, s); return Lc(r, Rc(r, s) ? Sc(r, Yt(), e, i.transform, n, i) : i.transform(n)) } function jc(t, e, n, s) { const r = t + 20, i = Ut(), o = Rt(i, r); return Lc(i, Rc(i, r) ? xc(i, Yt(), e, o.transform, n, s, o) : o.transform(n, s)) } function Ac(t, e, n, s, r) { const i = t + 20, o = Ut(), a = Rt(o, i); return Lc(o, Rc(o, i) ? Ec(o, Yt(), e, a.transform, n, s, r, a) : a.transform(n, s, r)) } function Rc(t, e) { return t[1].data[e].pure } function Lc(t, e) { return Di.isWrapped(e) && (e = Di.unwrap(e), t[Qt()] = dr), e } function Ic(t) { return e => { setTimeout(t, void 0, e) } } const Pc = class extends s.a { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, n) { var s, i, o; let a = t, c = e || (() => null), l = n; if (t && "object" == typeof t) { const e = t; a = null === (s = e.next) || void 0 === s ? void 0 : s.bind(e), c = null === (i = e.error) || void 0 === i ? void 0 : i.bind(e), l = null === (o = e.complete) || void 0 === o ? void 0 : o.bind(e) } this.__isAsync && (c = Ic(c), a && (a = Ic(a)), l && (l = Ic(l))); const u = super.subscribe({ next: a, error: c, complete: l }); return t instanceof r.a && t.add(u), u } }; function Dc() { return this._results[Pi()]() } class Mc { constructor(t = !1) { this._emitDistinctChangesOnly = t, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const e = Pi(), n = Mc.prototype; n[e] || (n[e] = Dc) } get changes() { return this._changes || (this._changes = new Pc) } get(t) { return this._results[t] } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t, e) { this.dirty = !1; const n = rn(t); (this._changesDetected = !function (t, e, n) { if (t.length !== e.length) return !1; for (let s = 0; s < t.length; s++) { let r = t[s], i = e[s]; if (n && (r = n(r), i = n(i)), i !== r) return !1 } return !0 }(this._results, n, e)) && (this._results = n, this.length = n.length, this.last = n[this.length - 1], this.first = n[0]) } notifyOnChanges() { !this._changes || !this._changesDetected && this._emitDistinctChangesOnly || this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } class Nc { constructor(t) { this.queryList = t, this.matches = null } clone() { return new Nc(this.queryList) } setDirty() { this.queryList.setDirty() } } class Fc { constructor(t = []) { this.queries = t } createEmbeddedView(t) { const e = t.queries; if (null !== e) { const n = null !== t.contentQueries ? t.contentQueries[0] : e.length, s = []; for (let t = 0; t < n; t++) { const n = e.getByIndex(t); s.push(this.queries[n.indexInDeclarationView].clone()) } return new Fc(s) } return null } insertView(t) { this.dirtyQueriesWithMatches(t) } detachView(t) { this.dirtyQueriesWithMatches(t) } dirtyQueriesWithMatches(t) { for (let e = 0; e < this.queries.length; e++)null !== Qc(t, e).matches && this.queries[e].setDirty() } } class Vc { constructor(t, e, n = null) { this.predicate = t, this.flags = e, this.read = n } } class Bc { constructor(t = []) { this.queries = t } elementStart(t, e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].elementStart(t, e) } elementEnd(t) { for (let e = 0; e < this.queries.length; e++)this.queries[e].elementEnd(t) } embeddedTView(t) { let e = null; for (let n = 0; n < this.length; n++) { const s = null !== e ? e.length : 0, r = this.getByIndex(n).embeddedTView(t, s); r && (r.indexInDeclarationView = n, null !== e ? e.push(r) : e = [r]) } return null !== e ? new Bc(e) : null } template(t, e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].template(t, e) } getByIndex(t) { return this.queries[t] } get length() { return this.queries.length } track(t) { this.queries.push(t) } } class Uc { constructor(t, e = -1) { this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e } elementStart(t, e) { this.isApplyingToNode(e) && this.matchTNode(t, e) } elementEnd(t) { this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1) } template(t, e) { this.elementStart(t, e) } embeddedTView(t, e) { return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, e), new Uc(this.metadata)) : null } isApplyingToNode(t) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const e = this._declarationNodeIndex; let n = t.parent; for (; null !== n && 8 & n.type && n.index !== e;)n = n.parent; return e === (null !== n ? n.index : -1) } return this._appliesToNextNode } matchTNode(t, e) { const n = this.metadata.predicate; if (Array.isArray(n)) for (let s = 0; s < n.length; s++) { const r = n[s]; this.matchTNodeWithReadOption(t, e, Hc(e, r)), this.matchTNodeWithReadOption(t, e, qe(e, t, r, !1, !1)) } else n === Za ? 4 & e.type && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, qe(e, t, n, !1, !1)) } matchTNodeWithReadOption(t, e, n) { if (null !== n) { const s = this.metadata.read; if (null !== s) if (s === _a || s === sc || s === Za && 4 & e.type) this.addMatch(e.index, -2); else { const n = qe(e, t, s, !1, !1); null !== n && this.addMatch(e.index, n) } else this.addMatch(e.index, n) } } addMatch(t, e) { null === this.matches ? this.matches = [t, e] : this.matches.push(t, e) } } function Hc(t, e) { const n = t.localNames; if (null !== n) for (let s = 0; s < n.length; s += 2)if (n[s] === e) return n[s + 1]; return null } function zc(t, e, n, s) { return -1 === n ? function (t, e) { return 11 & t.type ? ma(t, e) : 4 & t.type ? Ja(t, e) : null }(e, t) : -2 === n ? function (t, e, n) { return n === _a ? ma(e, t) : n === Za ? Ja(e, t) : n === sc ? cc(e, t) : void 0 }(t, e, s) : Ge(t, t[1], n, e) } function $c(t, e, n, s) { const r = e[19].queries[s]; if (null === r.matches) { const s = t.data, i = n.matches, o = []; for (let t = 0; t < i.length; t += 2) { const r = i[t]; o.push(r < 0 ? null : zc(e, s[r], i[t + 1], n.metadata.read)) } r.matches = o } return r.matches } function Wc(t, e, n, s) { const r = t.queries.getByIndex(n), i = r.matches; if (null !== i) { const o = $c(t, e, r, n); for (let t = 0; t < i.length; t += 2) { const n = i[t]; if (n > 0) s.push(o[t / 2]); else { const r = i[t + 1], o = e[-n]; for (let t = 10; t < o.length; t++) { const e = o[t]; e[17] === e[3] && Wc(e[1], e, r, s) } if (null !== o[9]) { const t = o[9]; for (let e = 0; e < t.length; e++) { const n = t[e]; Wc(n[1], n, r, s) } } } } } return s } function qc(t) { const e = Ut(), n = Ht(), s = se(); re(s + 1); const r = Qc(n, s); if (t.dirty && Pt(e) === (2 == (2 & r.metadata.flags))) { if (null === r.matches) t.reset([]); else { const i = r.crossesNgTemplate ? Wc(n, e, s, []) : $c(n, e, r, s); t.reset(i, va), t.notifyOnChanges() } return !0 } return !1 } function Gc(t, e, n) { const s = Ht(); s.firstCreatePass && (Yc(s, new Vc(t, e, n), -1), 2 == (2 & e) && (s.staticViewQueries = !0)), Zc(s, Ut(), e) } function Xc(t, e, n, s) { const r = Ht(); if (r.firstCreatePass) { const i = $t(); Yc(r, new Vc(e, n, s), i.index), function (t, e) { const n = t.contentQueries || (t.contentQueries = []); e !== (n.length ? n[n.length - 1] : -1) && n.push(t.queries.length - 1, e) }(r, t), 2 == (2 & n) && (r.staticContentQueries = !0) } Zc(r, Ut(), n) } function Kc() { return t = Ut(), e = se(), t[19].queries[e].queryList; var t, e } function Zc(t, e, n) { const s = new Mc(4 == (4 & n)); Pr(t, e, s, s.destroy), null === e[19] && (e[19] = new Fc), e[19].queries.push(new Nc(s)) } function Yc(t, e, n) { null === t.queries && (t.queries = new Bc), t.queries.track(new Uc(e, n)) } function Qc(t, e) { return t.queries.getByIndex(e) } function Jc(t, e) { return Ja(t, e) } function tl(t = j.Default) { const e = Wa(!0); if (null != e || t & j.Optional) return e; v("ChangeDetectorRef") } const el = new en("Application Initializer"); let nl = (() => { class t { constructor(t) { this.appInits = t, this.resolve = ga, this.reject = ga, this.initialized = !1, this.done = !1, this.donePromise = new Promise((t, e) => { this.resolve = t, this.reject = e }) } runInitializers() { if (this.initialized) return; const t = [], e = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let n = 0; n < this.appInits.length; n++) { const e = this.appInits[n](); io(e) && t.push(e) } Promise.all(t).then(() => { e() }).catch(t => { this.reject(t) }), 0 === t.length && e(), this.initialized = !0 } } return t.\u0275fac = function (e) { return new (e || t)(vn(el, 8)) }, t.\u0275prov = y({ token: t, factory: t.\u0275fac }), t })(); const sl = new en("AppId"), rl = { provide: sl, useFactory: function () { return `${il()}${il()}${il()}` }, deps: [] }; function il() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const ol = new en("Platform Initializer"), al = new en("Platform ID"), cl = new en("appBootstrapListener"); let ll = (() => { class t { log(t) { console.log(t) } warn(t) { console.warn(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = y({ token: t, factory: t.\u0275fac }), t })(); const ul = new en("LocaleId"), hl = new en("DefaultCurrencyCode"); class dl { constructor(t, e) { this.ngModuleFactory = t, this.componentFactories = e } } const pl = function (t) { return new bc(t) }, fl = pl, gl = function (t) { return Promise.resolve(pl(t)) }, ml = function (t) { const e = pl(t), n = Es(ct(t).declarations).reduce((t, e) => { const n = at(e); return n && t.push(new pc(n)), t }, []); return new dl(e, n) }, bl = ml, _l = function (t) { return Promise.resolve(ml(t)) }; let vl = (() => { class t { constructor() { this.compileModuleSync = fl, this.compileModuleAsync = gl, this.compileModuleAndAllComponentsSync = bl, this.compileModuleAndAllComponentsAsync = _l } clearCache() { } clearCacheFor(t) { } getModuleId(t) { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = y({ token: t, factory: t.\u0275fac }), t })(); const yl = (() => Promise.resolve(0))(); function wl(t) { "undefined" == typeof Zone ? yl.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class Cl { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: e = !1, shouldCoalesceRunChangeDetection: n = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Pc(!1), this.onMicrotaskEmpty = new Pc(!1), this.onStable = new Pc(!1), this.onError = new Pc(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(), this._nesting = 0, this._outer = this._inner = Zone.current, Zone.TaskTrackingZoneSpec && (this._inner = this._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (this._inner = this._inner.fork(Zone.longStackTraceZoneSpec)), this.shouldCoalesceEventChangeDetection = !n && e, this.shouldCoalesceRunChangeDetection = n, this.lastRequestAnimationFrameId = -1, this.nativeRequestAnimationFrame = function () { let t = B.requestAnimationFrame, e = B.cancelAnimationFrame; if ("undefined" != typeof Zone && t && e) { const n = t[Zone.__symbol__("OriginalDelegate")]; n && (t = n); const s = e[Zone.__symbol__("OriginalDelegate")]; s && (e = s) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: e } }().nativeRequestAnimationFrame, function (t) { const e = () => { !function (t) { -1 === t.lastRequestAnimationFrameId && (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(B, () => { t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { t.lastRequestAnimationFrameId = -1, xl(t), Sl(t) }, void 0, () => { }, () => { })), t.fakeTopEventTask.invoke() }), xl(t)) }(t) }; t._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, s, r, i, o, a) => { try { return El(t), n.invokeTask(r, i, o, a) } finally { (t.shouldCoalesceEventChangeDetection && "eventTask" === i.type || t.shouldCoalesceRunChangeDetection) && e(), Tl(t) } }, onInvoke: (n, s, r, i, o, a, c) => { try { return El(t), n.invoke(r, i, o, a, c) } finally { t.shouldCoalesceRunChangeDetection && e(), Tl(t) } }, onHasTask: (e, n, s, r) => { e.hasTask(s, r), n === s && ("microTask" == r.change ? (t._hasPendingMicrotasks = r.microTask, xl(t), Sl(t)) : "macroTask" == r.change && (t.hasPendingMacrotasks = r.macroTask)) }, onHandleError: (e, n, s, r) => (e.handleError(s, r), t.runOutsideAngular(() => t.onError.emit(r)), !1) }) }(this) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Cl.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Cl.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, e, n) { return this._inner.run(t, e, n) } runTask(t, e, n, s) { const r = this._inner, i = r.scheduleEventTask("NgZoneEvent: " + s, t, Ol, ga, ga); try { return r.runTask(i, e, n) } finally { r.cancelTask(i) } } runGuarded(t, e, n) { return this._inner.runGuarded(t, e, n) } runOutsideAngular(t) { return this._outer.run(t) } } const Ol = {}; function Sl(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function xl(t) { t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && -1 !== t.lastRequestAnimationFrameId) } function El(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function Tl(t) { t._nesting--, Sl(t) } class kl { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Pc, this.onMicrotaskEmpty = new Pc, this.onStable = new Pc, this.onError = new Pc } run(t, e, n) { return t.apply(e, n) } runGuarded(t, e, n) { return t.apply(e, n) } runOutsideAngular(t) { return t() } runTask(t, e, n, s) { return t.apply(e, n) } } let jl = (() => { class t { constructor(t) { this._ngZone = t, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), t.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Cl.assertNotInAngularZone(), wl(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) wl(() => { for (; 0 !== this._callbacks.length;) { let t = this._callbacks.pop(); clearTimeout(t.timeoutId), t.doneCb(this._didWork) } this._didWork = !1 }); else { let t = this.getPendingTasks(); this._callbacks = this._callbacks.filter(e => !e.updateCb || !e.updateCb(t) || (clearTimeout(e.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({ source: t.source, creationLocation: t.creationLocation, data: t.data })) : [] } addCallback(t, e, n) { let s = -1; e && e > 0 && (s = setTimeout(() => { this._callbacks = this._callbacks.filter(t => t.timeoutId !== s), t(this._didWork, this.getPendingTasks()) }, e)), this._callbacks.push({ doneCb: t, timeoutId: s, updateCb: n }) } whenStable(t, e, n) { if (n && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?'); this.addCallback(t, e, n), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(t, e, n) { return [] } } return t.\u0275fac = function (e) { return new (e || t)(vn(Cl)) }, t.\u0275prov = y({ token: t, factory: t.\u0275fac }), t })(), Al = (() => { class t { constructor() { this._applications = new Map, Pl.addToWindow(this) } registerApplication(t, e) { this._applications.set(t, e) } unregisterApplication(t) { this._applications.delete(t) } unregisterAllApplications() { this._applications.clear() } getTestability(t) { return this._applications.get(t) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(t, e = !0) { return Pl.findTestabilityInTree(this, t, e) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = y({ token: t, factory: t.\u0275fac }), t })(); class Rl { addToWindow(t) { } findTestabilityInTree(t, e, n) { return null } } function Ll(t) { Pl = t } let Il, Pl = new Rl, Dl = !0, Ml = !1; function Nl() { return Ml = !0, Dl } function Fl() { if (Ml) throw new Error("Cannot enable prod mode after platform setup."); Dl = !1 } const Vl = new en("AllowMultipleToken"); class Bl { constructor(t, e) { this.name = t, this.token = e } } function Ul(t, e, n = []) { const s = `Platform: ${e}`, r = new en(s); return (e = []) => { let i = Hl(); if (!i || i.injector.get(Vl, !1)) if (t) t(n.concat(e).concat({ provide: r, useValue: !0 })); else { const t = n.concat(e).concat({ provide: r, useValue: !0 }, { provide: di, useValue: "platform" }); !function (t) { if (Il && !Il.destroyed && !Il.injector.get(Vl, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one."); Il = t.get(zl); const e = t.get(ol, null); e && e.forEach(t => t()) }(Ei.create({ providers: t, name: s })) } return function (t) { const e = Hl(); if (!e) throw new Error("No platform exists!"); if (!e.injector.get(t, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return e }(r) } } function Hl() { return Il && !Il.destroyed ? Il : null } let zl = (() => { class t { constructor(t) { this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(t, e) { const n = function (t, e) { let n; return n = "noop" === t ? new kl : ("zone.js" === t ? void 0 : t) || new Cl({ enableLongStackTrace: Nl(), shouldCoalesceEventChangeDetection: !!(null == e ? void 0 : e.ngZoneEventCoalescing), shouldCoalesceRunChangeDetection: !!(null == e ? void 0 : e.ngZoneRunCoalescing) }), n }(e ? e.ngZone : void 0, { ngZoneEventCoalescing: e && e.ngZoneEventCoalescing || !1, ngZoneRunCoalescing: e && e.ngZoneRunCoalescing || !1 }), s = [{ provide: Cl, useValue: n }]; return n.run(() => { const e = Ei.create({ providers: s, parent: this.injector, name: t.moduleType.name }), r = t.create(e), i = r.injector.get(ws, null); if (!i) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return n.runOutsideAngular(() => { const t = n.onError.subscribe({ next: t => { i.handleError(t) } }); r.onDestroy(() => { ql(this._modules, r), t.unsubscribe() }) }), function (t, e, n) { try { const s = n(); return io(s) ? s.catch(n => { throw e.runOutsideAngular(() => t.handleError(n)), n }) : s } catch (s) { throw e.runOutsideAngular(() => t.handleError(s)), s } }(i, n, () => { const t = r.injector.get(nl); return t.runInitializers(), t.donePromise.then(() => (sa(r.injector.get(ul, "en-US") || "en-US"), this._moduleDoBootstrap(r), r)) }) }) } bootstrapModule(t, e = []) { const n = $l({}, e); return function (t, e, n) { const s = new bc(n); return Promise.resolve(s) }(0, 0, t).then(t => this.bootstrapModuleFactory(t, n)) } _moduleDoBootstrap(t) { const e = t.injector.get(Wl); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(t => e.bootstrap(t)); else { if (!t.instance.ngDoBootstrap) throw new Error(`The module ${u(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`); t.instance.ngDoBootstrap(e) } this._modules.push(t) } onDestroy(t) { this._destroyListeners.push(t) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!"); this._modules.slice().forEach(t => t.destroy()), this._destroyListeners.forEach(t => t()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return t.\u0275fac = function (e) { return new (e || t)(vn(Ei)) }, t.\u0275prov = y({ token: t, factory: t.\u0275fac }), t })(); function $l(t, e) { return Array.isArray(e) ? e.reduce($l, t) : Object.assign(Object.assign({}, t), e) } let Wl = (() => { class t { constructor(t, e, n, s, r) { this._zone = t, this._injector = e, this._exceptionHandler = n, this._componentFactoryResolver = s, this._initStatus = r, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const c = new i.a(t => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { t.next(this._stable), t.complete() }) }), l = new i.a(t => { let e; this._zone.runOutsideAngular(() => { e = this._zone.onStable.subscribe(() => { Cl.assertNotInAngularZone(), wl(() => { this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, t.next(!0)) }) }) }); const n = this._zone.onUnstable.subscribe(() => { Cl.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { t.next(!1) })) }); return () => { e.unsubscribe(), n.unsubscribe() } }); this.isStable = Object(o.a)(c, l.pipe(Object(a.a)())) } bootstrap(t, e) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let n; n = t instanceof da ? t : this._componentFactoryResolver.resolveComponentFactory(t), this.componentTypes.push(n.componentType); const s = n.isBoundToModule ? void 0 : this._injector.get(tc), r = n.create(Ei.NULL, [], e || n.selector, s), i = r.location.nativeElement, o = r.injector.get(jl, null), a = o && r.injector.get(Al); return o && a && a.registerApplication(i, o), r.onDestroy(() => { this.detachView(r.hostView), ql(this.components, r), a && a.unregisterApplication(i) }), this._loadComponent(r), r } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); try { this._runningTick = !0; for (let t of this._views) t.detectChanges() } catch (t) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(t)) } finally { this._runningTick = !1 } } attachView(t) { const e = t; this._views.push(e), e.attachToAppRef(this) } detachView(t) { const e = t; ql(this._views, e), e.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t), this._injector.get(cl, []).concat(this._bootstrapListeners).forEach(e => e(t)) } ngOnDestroy() { this._views.slice().forEach(t => t.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } get viewCount() { return this._views.length } } return t.\u0275fac = function (e) { return new (e || t)(vn(Cl), vn(Ei), vn(ws), vn(fa), vn(nl)) }, t.\u0275prov = y({ token: t, factory: t.\u0275fac }), t })(); function ql(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } class Gl { } class Xl { } const Kl = { factoryPathPrefix: "", factoryPathSuffix: ".ngfactory" }; let Zl = (() => { class t { constructor(t, e) { this._compiler = t, this._config = e || Kl } load(t) { return this.loadAndCompile(t) } loadAndCompile(t) { let [e, s] = t.split("#"); return void 0 === s && (s = "default"), n("zn8P")(e).then(t => t[s]).then(t => Yl(t, e, s)).then(t => this._compiler.compileModuleAsync(t)) } loadFactory(t) { let [e, s] = t.split("#"), r = "NgFactory"; return void 0 === s && (s = "default", r = ""), n("zn8P")(this._config.factoryPathPrefix + e + this._config.factoryPathSuffix).then(t => t[s + r]).then(t => Yl(t, e, s)) } } return t.\u0275fac = function (e) { return new (e || t)(vn(vl), vn(Xl, 8)) }, t.\u0275prov = y({ token: t, factory: t.\u0275fac }), t })(); function Yl(t, e, n) { if (!t) throw new Error(`Cannot find '${n}' in '${e}'`); return t } const Ql = function (t) { return null }, Jl = Ul(null, "core", [{ provide: al, useValue: "unknown" }, { provide: zl, deps: [Ei] }, { provide: Al, deps: [] }, { provide: ll, deps: [] }]), tu = [{ provide: Wl, useClass: Wl, deps: [Cl, Ei, ws, fa, nl] }, { provide: dc, deps: [Cl], useFactory: function (t) { let e = []; return t.onStable.subscribe(() => { for (; e.length;)e.pop()() }), function (t) { e.push(t) } } }, { provide: nl, useClass: nl, deps: [[new Sn, el]] }, { provide: vl, useClass: vl, deps: [] }, rl, { provide: Na, useFactory: function () { return Ga }, deps: [] }, { provide: Va, useFactory: function () { return Xa }, deps: [] }, { provide: ul, useFactory: function (t) { return sa(t = t || "undefined" != typeof $localize && $localize.locale || "en-US"), t }, deps: [[new On(ul), new Sn, new En]] }, { provide: hl, useValue: "USD" }]; let eu = (() => { class t { constructor(t) { } } return t.\u0275fac = function (e) { return new (e || t)(vn(Wl)) }, t.\u0275mod = nt({ type: t }), t.\u0275inj = w({ providers: tu }), t })() }, gRHU: function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }); var s = n("2fFW"), r = n("NJ4a"); const i = { closed: !0, next(t) { }, error(t) { if (s.a.useDeprecatedSynchronousErrorHandling) throw t; Object(r.a)(t) }, complete() { } } }, gnMq: function (t, e, n) { "use strict"; n.d(e, "a", function () { return Qi }), n.d(e, "b", function () { return Zi }), n.d(e, "c", function () { return ca }), n.d(e, "d", function () { return tl }), n.d(e, "e", function () { return Qc }), n.d(e, "f", function () { return Jc }), n.d(e, "g", function () { return Ca }), n.d(e, "h", function () { return na }), n.d(e, "i", function () { return Ac }), n.d(e, "j", function () { return Oo }), n.d(e, "k", function () { return xa }), n.d(e, "l", function () { return Aa }), n.d(e, "m", function () { return Zo }), n.d(e, "n", function () { return qa }), n.d(e, "o", function () { return da }), n.d(e, "p", function () { return Yc }), n.d(e, "q", function () { return hc }), n.d(e, "r", function () { return ea }), n.d(e, "s", function () { return ta }), n.d(e, "t", function () { return Ra }), n.d(e, "u", function () { return Sa }), n.d(e, "v", function () { return Oa }), n.d(e, "w", function () { return Lc }), n.d(e, "x", function () { return Ia }), n.d(e, "y", function () { return Wa }), n.d(e, "z", function () { return ba }), n.d(e, "A", function () { return _a }), n.d(e, "B", function () { return qc }), n.d(e, "C", function () { return Wc }), n.d(e, "D", function () { return sl }), n.d(e, "E", function () { return Za }), n.d(e, "F", function () { return Ka }), n.d(e, "G", function () { return cc }), n.d(e, "H", function () { return lc }), n.d(e, "I", function () { return ec }), n.d(e, "J", function () { return Kc }), n.d(e, "K", function () { return Ja }), n.d(e, "L", function () { return tc }), n.d(e, "M", function () { return oc }), n.d(e, "N", function () { return uc }), n.d(e, "O", function () { return pc }), n.d(e, "P", function () { return fc }), n.d(e, "Q", function () { return Xc }), n.d(e, "R", function () { return nc }), n.d(e, "S", function () { return ic }), n.d(e, "T", function () { return Gc }), n.d(e, "U", function () { return vc }), n.d(e, "V", function () { return $c }), n.d(e, "W", function () { return ua }), n.d(e, "X", function () { return oa }), n.d(e, "Y", function () { return sa }); var s = n("ofXK"), r = n("fXoL"), i = n("XNiG"), o = n("quSY"), a = n("LRne"), c = n("vkgz"), l = n("Kj3r"), u = n("pLZG"), h = n("lJxs"), d = n("IzEk"); function p(t) { return null != t && "false" != `${t}` } function f(t) { return Array.isArray(t) ? t : [t] } function g(t) { return null == t ? "" : "string" == typeof t ? t : `${t}px` } function m(t) { return t instanceof r.l ? t.nativeElement : t } let b; try { b = "undefined" != typeof Intl && Intl.v8BreakIterator } catch (rl) { b = !1 } let _, v = (() => { class t { constructor(t) { this._platformId = t, this.isBrowser = this._platformId ? Object(s.y)(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !b) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(r.C)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(r.C)) }, token: t, providedIn: "root" }), t })(), y = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.Pb({ type: t }), t.\u0275inj = r.Ob({}), t })(); function w() { if (null == _) { if ("object" != typeof document || !document || "function" != typeof Element || !Element) return _ = !1, _; if ("scrollBehavior" in document.documentElement.style) _ = !0; else { const t = Element.prototype.scrollTo; _ = !!t && !/\{\s*\[native code\]\s*\}/.test(t.toString()) } } return _ } var C = n("HDdC"); let O = (() => { class t { create(t) { return "undefined" == typeof MutationObserver ? null : new MutationObserver(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(), S = (() => { class t { constructor(t) { this._mutationObserverFactory = t, this._observedElements = new Map } ngOnDestroy() { this._observedElements.forEach((t, e) => this._cleanupObserver(e)) } observe(t) { const e = m(t); return new C.a(t => { const n = this._observeElement(e).subscribe(t); return () => { n.unsubscribe(), this._unobserveElement(e) } }) } _observeElement(t) { if (this._observedElements.has(t)) this._observedElements.get(t).count++; else { const e = new i.a, n = this._mutationObserverFactory.create(t => e.next(t)); n && n.observe(t, { characterData: !0, childList: !0, subtree: !0 }), this._observedElements.set(t, { observer: n, stream: e, count: 1 }) } return this._observedElements.get(t).stream } _unobserveElement(t) { this._observedElements.has(t) && (this._observedElements.get(t).count--, this._observedElements.get(t).count || this._cleanupObserver(t)) } _cleanupObserver(t) { if (this._observedElements.has(t)) { const { observer: e, stream: n } = this._observedElements.get(t); e && e.disconnect(), n.complete(), this._observedElements.delete(t) } } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(O)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(O)) }, token: t, providedIn: "root" }), t })(), x = (() => { class t { constructor(t, e, n) { this._contentObserver = t, this._elementRef = e, this._ngZone = n, this.event = new r.n, this._disabled = !1, this._currentSubscription = null } get disabled() { return this._disabled } set disabled(t) { this._disabled = p(t), this._disabled ? this._unsubscribe() : this._subscribe() } get debounce() { return this._debounce } set debounce(t) { this._debounce = function (t, e = 0) { return function (t) { return !isNaN(parseFloat(t)) && !isNaN(Number(t)) }(t) ? Number(t) : e }(t), this._subscribe() } ngAfterContentInit() { this._currentSubscription || this.disabled || this._subscribe() } ngOnDestroy() { this._unsubscribe() } _subscribe() { this._unsubscribe(); const t = this._contentObserver.observe(this._elementRef); this._ngZone.runOutsideAngular(() => { this._currentSubscription = (this.debounce ? t.pipe(Object(l.a)(this.debounce)) : t).subscribe(this.event) }) } _unsubscribe() { var t; null === (t = this._currentSubscription) || void 0 === t || t.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(S), r.Rb(r.l), r.Rb(r.A)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["", "cdkObserveContent", ""]], inputs: { disabled: ["cdkObserveContentDisabled", "disabled"], debounce: "debounce" }, outputs: { event: "cdkObserveContent" }, exportAs: ["cdkObserveContent"] }), t })(), E = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.Pb({ type: t }), t.\u0275inj = r.Ob({ providers: [O] }), t })(), T = (() => { class t { constructor(t) { this._platform = t } isDisabled(t) { return t.hasAttribute("disabled") } isVisible(t) { return function (t) { return !!(t.offsetWidth || t.offsetHeight || "function" == typeof t.getClientRects && t.getClientRects().length) }(t) && "visible" === getComputedStyle(t).visibility } isTabbable(t) { if (!this._platform.isBrowser) return !1; const e = function (t) { try { return t.frameElement } catch (rl) { return null } }((n = t).ownerDocument && n.ownerDocument.defaultView || window); var n; if (e) { if (-1 === j(e)) return !1; if (!this.isVisible(e)) return !1 } let s = t.nodeName.toLowerCase(), r = j(t); return t.hasAttribute("contenteditable") ? -1 !== r : "iframe" !== s && "object" !== s && !(this._platform.WEBKIT && this._platform.IOS && !function (t) { let e = t.nodeName.toLowerCase(), n = "input" === e && t.type; return "text" === n || "password" === n || "select" === e || "textarea" === e }(t)) && ("audio" === s ? !!t.hasAttribute("controls") && -1 !== r : "video" === s ? -1 !== r && (null !== r || this._platform.FIREFOX || t.hasAttribute("controls")) : t.tabIndex >= 0) } isFocusable(t, e) { return function (t) { return !function (t) { return function (t) { return "input" == t.nodeName.toLowerCase() }(t) && "hidden" == t.type }(t) && (function (t) { let e = t.nodeName.toLowerCase(); return "input" === e || "select" === e || "button" === e || "textarea" === e }(t) || function (t) { return function (t) { return "a" == t.nodeName.toLowerCase() }(t) && t.hasAttribute("href") }(t) || t.hasAttribute("contenteditable") || k(t)) }(t) && !this.isDisabled(t) && ((null == e ? void 0 : e.ignoreVisibility) || this.isVisible(t)) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(v)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(v)) }, token: t, providedIn: "root" }), t })(); function k(t) { if (!t.hasAttribute("tabindex") || void 0 === t.tabIndex) return !1; let e = t.getAttribute("tabindex"); return "-32768" != e && !(!e || isNaN(parseInt(e, 10))) } function j(t) { if (!k(t)) return null; const e = parseInt(t.getAttribute("tabindex") || "", 10); return isNaN(e) ? -1 : e } class A { constructor(t, e, n, s, r = !1) { this._element = t, this._checker = e, this._ngZone = n, this._document = s, this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, r || this.attachAnchors() } get enabled() { return this._enabled } set enabled(t) { this._enabled = t, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } destroy() { const t = this._startAnchor, e = this._endAnchor; t && (t.removeEventListener("focus", this.startAnchorListener), t.parentNode && t.parentNode.removeChild(t)), e && (e.removeEventListener("focus", this.endAnchorListener), e.parentNode && e.parentNode.removeChild(e)), this._startAnchor = this._endAnchor = null, this._hasAttached = !1 } attachAnchors() { return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => { this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener)) }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = !0), this._hasAttached) } focusInitialElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusInitialElement())) }) } focusFirstTabbableElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusFirstTabbableElement())) }) } focusLastTabbableElementWhenReady() { return new Promise(t => { this._executeOnStable(() => t(this.focusLastTabbableElement())) }) } _getRegionBoundary(t) { let e = this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`); for (let n = 0; n < e.length; n++)e[n].hasAttribute(`cdk-focus-${t}`) ? console.warn(`Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`, e[n]) : e[n].hasAttribute(`cdk-focus-region-${t}`) && console.warn(`Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`, e[n]); return "start" == t ? e.length ? e[0] : this._getFirstTabbableElement(this._element) : e.length ? e[e.length - 1] : this._getLastTabbableElement(this._element) } focusInitialElement() { const t = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]"); if (t) { if (t.hasAttribute("cdk-focus-initial") && console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0", t), !this._checker.isFocusable(t)) { const e = this._getFirstTabbableElement(t); return null == e || e.focus(), !!e } return t.focus(), !0 } return this.focusFirstTabbableElement() } focusFirstTabbableElement() { const t = this._getRegionBoundary("start"); return t && t.focus(), !!t } focusLastTabbableElement() { const t = this._getRegionBoundary("end"); return t && t.focus(), !!t } hasAttached() { return this._hasAttached } _getFirstTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let n = 0; n < e.length; n++) { let t = e[n].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(e[n]) : null; if (t) return t } return null } _getLastTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let n = e.length - 1; n >= 0; n--) { let t = e[n].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(e[n]) : null; if (t) return t } return null } _createAnchor() { const t = this._document.createElement("div"); return this._toggleAnchorTabIndex(this._enabled, t), t.classList.add("cdk-visually-hidden"), t.classList.add("cdk-focus-trap-anchor"), t.setAttribute("aria-hidden", "true"), t } _toggleAnchorTabIndex(t, e) { t ? e.setAttribute("tabindex", "0") : e.removeAttribute("tabindex") } toggleAnchors(t) { this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } _executeOnStable(t) { this._ngZone.isStable ? t() : this._ngZone.onStable.pipe(Object(d.a)(1)).subscribe(t) } } let R = (() => { class t { constructor(t, e, n) { this._checker = t, this._ngZone = e, this._document = n } create(t, e = !1) { return new A(t, this._checker, this._ngZone, this._document, e) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(T), r.bc(r.A), r.bc(s.e)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(T), Object(r.bc)(r.A), Object(r.bc)(s.e)) }, token: t, providedIn: "root" }), t })(), L = (() => { class t { constructor(t, e, n) { this._elementRef = t, this._focusTrapFactory = e, this._previouslyFocusedElement = null, this._document = n, this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, !0) } get enabled() { return this.focusTrap.enabled } set enabled(t) { this.focusTrap.enabled = p(t) } get autoCapture() { return this._autoCapture } set autoCapture(t) { this._autoCapture = p(t) } ngOnDestroy() { this.focusTrap.destroy(), this._previouslyFocusedElement && (this._previouslyFocusedElement.focus(), this._previouslyFocusedElement = null) } ngAfterContentInit() { this.focusTrap.attachAnchors(), this.autoCapture && this._captureFocus() } ngDoCheck() { this.focusTrap.hasAttached() || this.focusTrap.attachAnchors() } ngOnChanges(t) { const e = t.autoCapture; e && !e.firstChange && this.autoCapture && this.focusTrap.hasAttached() && this._captureFocus() } _captureFocus() { this._previouslyFocusedElement = this._document.activeElement, this.focusTrap.focusInitialElementWhenReady() } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.l), r.Rb(R), r.Rb(s.e)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["", "cdkTrapFocus", ""]], inputs: { enabled: ["cdkTrapFocus", "enabled"], autoCapture: ["cdkTrapFocusAutoCapture", "autoCapture"] }, exportAs: ["cdkTrapFocus"], features: [r.Ab] }), t })(); "undefined" != typeof Element && Element; let I = (() => { class t { constructor(t, e) { this._platform = t, this._document = e } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const t = this._document.createElement("div"); t.style.backgroundColor = "rgb(1,2,3)", t.style.position = "absolute", this._document.body.appendChild(t); const e = this._document.defaultView || window, n = e && e.getComputedStyle ? e.getComputedStyle(t) : null, s = (n && n.backgroundColor || "").replace(/ /g, ""); switch (this._document.body.removeChild(t), s) { case "rgb(0,0,0)": return 2; case "rgb(255,255,255)": return 1 }return 0 } _applyBodyHighContrastModeCssClasses() { if (this._platform.isBrowser && this._document.body) { const t = this._document.body.classList; t.remove("cdk-high-contrast-active"), t.remove("cdk-high-contrast-black-on-white"), t.remove("cdk-high-contrast-white-on-black"); const e = this.getHighContrastMode(); 1 === e ? (t.add("cdk-high-contrast-active"), t.add("cdk-high-contrast-black-on-white")) : 2 === e && (t.add("cdk-high-contrast-active"), t.add("cdk-high-contrast-white-on-black")) } } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(v), r.bc(s.e)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(v), Object(r.bc)(s.e)) }, token: t, providedIn: "root" }), t })(), P = (() => { class t { constructor(t) { t._applyBodyHighContrastModeCssClasses() } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(I)) }, t.\u0275mod = r.Pb({ type: t }), t.\u0275inj = r.Ob({ imports: [[y, E]] }), t })(); var D = n("DH7j"), M = n("n6bG"); function N(t, e, n, s) { return Object(M.a)(n) && (s = n, n = void 0), s ? N(t, e, n).pipe(Object(h.a)(t => Object(D.a)(t) ? s(...t) : s(t))) : new C.a(s => { F(t, e, function (t) { s.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : t) }, s, n) }) } function F(t, e, n, s, r) { let i; if (function (t) { return t && "function" == typeof t.addEventListener && "function" == typeof t.removeEventListener }(t)) { const s = t; t.addEventListener(e, n, r), i = () => s.removeEventListener(e, n, r) } else if (function (t) { return t && "function" == typeof t.on && "function" == typeof t.off }(t)) { const s = t; t.on(e, n), i = () => s.off(e, n) } else if (function (t) { return t && "function" == typeof t.addListener && "function" == typeof t.removeListener }(t)) { const s = t; t.addListener(e, n), i = () => s.removeListener(e, n) } else { if (!t || !t.length) throw new TypeError("Invalid event target"); for (let i = 0, o = t.length; i < o; i++)F(t[i], e, n, s, r) } s.add(i) } n("3N8a"), n("IjjT"); var V = n("7+OI"), B = n("/uUt"), U = n("D0XW"), H = n("zx2A"); class z { constructor(t) { this.durationSelector = t } call(t, e) { return e.subscribe(new $(t, this.durationSelector)) } } class $ extends H.b { constructor(t, e) { super(t), this.durationSelector = e, this.hasValue = !1 } _next(t) { if (this.value = t, this.hasValue = !0, !this.throttled) { let n; try { const { durationSelector: e } = this; n = e(t) } catch (e) { return this.destination.error(e) } const s = Object(H.c)(n, new H.a(this)); !s || s.closed ? this.clearThrottle() : this.add(this.throttled = s) } } clearThrottle() { const { value: t, hasValue: e, throttled: n } = this; n && (this.remove(n), this.throttled = void 0, n.unsubscribe()), e && (this.value = void 0, this.hasValue = !1, this.destination.next(t)) } notifyNext() { this.clearThrottle() } notifyComplete() { this.clearThrottle() } } function W(t) { return !Object(D.a)(t) && t - parseFloat(t) + 1 >= 0 } var q = n("z+Ro"); function G(t = 0, e, n) { let s = -1; return W(e) ? s = Number(e) < 1 ? 1 : Number(e) : Object(q.a)(e) && (n = e), Object(q.a)(n) || (n = U.a), new C.a(e => { const r = W(t) ? t : +t - n.now(); return n.schedule(X, r, { index: 0, period: s, subscriber: e }) }) } function X(t) { const { index: e, period: n, subscriber: s } = t; if (s.next(e), !s.closed) { if (-1 === n) return s.complete(); t.index = e + 1, this.schedule(t, n) } } function K(t, e = U.a) { return n = () => G(t, e), function (t) { return t.lift(new z(n)) }; var n } var Z = n("1G5W"), Y = n("JX91"); n("7o/Q"); var Q = n("eIep"), J = n("UXun"); const tt = new r.r("cdk-dir-doc", { providedIn: "root", factory: function () { return Object(r.W)(s.e) } }); let et = (() => { class t { constructor(t) { if (this.value = "ltr", this.change = new r.n, t) { const e = t.documentElement ? t.documentElement.dir : null, n = (t.body ? t.body.dir : null) || e; this.value = "ltr" === n || "rtl" === n ? n : "ltr" } } ngOnDestroy() { this.change.complete() } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(tt, 8)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(tt, 8)) }, token: t, providedIn: "root" }), t })(), nt = (() => { class t { constructor() { this._dir = "ltr", this._isInitialized = !1, this.change = new r.n } get dir() { return this._dir } set dir(t) { const e = this._dir, n = t ? t.toLowerCase() : t; this._rawDir = t, this._dir = "ltr" === n || "rtl" === n ? n : "ltr", e !== this._dir && this._isInitialized && this.change.emit(this._dir) } get value() { return this.dir } ngAfterContentInit() { this._isInitialized = !0 } ngOnDestroy() { this.change.complete() } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = r.Mb({ type: t, selectors: [["", "dir", ""]], hostVars: 1, hostBindings: function (t, e) { 2 & t && r.Db("dir", e._rawDir) }, inputs: { dir: "dir" }, outputs: { change: "dirChange" }, exportAs: ["dir"], features: [r.Bb([{ provide: et, useExisting: t }])] }), t })(), st = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.Pb({ type: t }), t.\u0275inj = r.Ob({}), t })(), rt = (() => { class t { constructor(t, e, n) { this._ngZone = t, this._platform = e, this._scrolled = new i.a, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map, this._document = n } register(t) { this.scrollContainers.has(t) || this.scrollContainers.set(t, t.elementScrolled().subscribe(() => this._scrolled.next(t))) } deregister(t) { const e = this.scrollContainers.get(t); e && (e.unsubscribe(), this.scrollContainers.delete(t)) } scrolled(t = 20) { return this._platform.isBrowser ? new C.a(e => { this._globalSubscription || this._addGlobalListener(); const n = t > 0 ? this._scrolled.pipe(K(t)).subscribe(e) : this._scrolled.subscribe(e); return this._scrolledCount++, () => { n.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener() } }) : Object(a.a)() } ngOnDestroy() { this._removeGlobalListener(), this.scrollContainers.forEach((t, e) => this.deregister(e)), this._scrolled.complete() } ancestorScrolled(t, e) { const n = this.getAncestorScrollContainers(t); return this.scrolled(e).pipe(Object(u.a)(t => !t || n.indexOf(t) > -1)) } getAncestorScrollContainers(t) { const e = []; return this.scrollContainers.forEach((n, s) => { this._scrollableContainsElement(s, t) && e.push(s) }), e } _getWindow() { return this._document.defaultView || window } _scrollableContainsElement(t, e) { let n = m(e), s = t.getElementRef().nativeElement; do { if (n == s) return !0 } while (n = n.parentElement); return !1 } _addGlobalListener() { this._globalSubscription = this._ngZone.runOutsideAngular(() => N(this._getWindow().document, "scroll").subscribe(() => this._scrolled.next())) } _removeGlobalListener() { this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(r.A), r.bc(v), r.bc(s.e, 8)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(r.A), Object(r.bc)(v), Object(r.bc)(s.e, 8)) }, token: t, providedIn: "root" }), t })(), it = (() => { class t { constructor(t, e, n) { this._platform = t, this._change = new i.a, this._changeListener = t => { this._change.next(t) }, this._document = n, e.runOutsideAngular(() => { if (t.isBrowser) { const t = this._getWindow(); t.addEventListener("resize", this._changeListener), t.addEventListener("orientationchange", this._changeListener) } this.change().subscribe(() => this._updateViewportSize()) }) } ngOnDestroy() { if (this._platform.isBrowser) { const t = this._getWindow(); t.removeEventListener("resize", this._changeListener), t.removeEventListener("orientationchange", this._changeListener) } this._change.complete() } getViewportSize() { this._viewportSize || this._updateViewportSize(); const t = { width: this._viewportSize.width, height: this._viewportSize.height }; return this._platform.isBrowser || (this._viewportSize = null), t } getViewportRect() { const t = this.getViewportScrollPosition(), { width: e, height: n } = this.getViewportSize(); return { top: t.top, left: t.left, bottom: t.top + n, right: t.left + e, height: n, width: e } } getViewportScrollPosition() { if (!this._platform.isBrowser) return { top: 0, left: 0 }; const t = this._document, e = this._getWindow(), n = t.documentElement, s = n.getBoundingClientRect(); return { top: -s.top || t.body.scrollTop || e.scrollY || n.scrollTop || 0, left: -s.left || t.body.scrollLeft || e.scrollX || n.scrollLeft || 0 } } change(t = 20) { return t > 0 ? this._change.pipe(K(t)) : this._change } _getWindow() { return this._document.defaultView || window } _updateViewportSize() { const t = this._getWindow(); this._viewportSize = this._platform.isBrowser ? { width: t.innerWidth, height: t.innerHeight } : { width: 0, height: 0 } } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(v), r.bc(r.A), r.bc(s.e, 8)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(v), Object(r.bc)(r.A), Object(r.bc)(s.e, 8)) }, token: t, providedIn: "root" }), t })(), ot = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.Pb({ type: t }), t.\u0275inj = r.Ob({}), t })(), at = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.Pb({ type: t }), t.\u0275inj = r.Ob({ imports: [[st, y, ot], st, ot] }), t })(); class ct { attach(t) { return this._attachedHost = t, t.attach(this) } detach() { let t = this._attachedHost; null != t && (this._attachedHost = null, t.detach()) } get isAttached() { return null != this._attachedHost } setAttachedHost(t) { this._attachedHost = t } } class lt extends ct { constructor(t, e, n, s) { super(), this.component = t, this.viewContainerRef = e, this.injector = n, this.componentFactoryResolver = s } } class ut extends ct { constructor(t, e, n) { super(), this.templateRef = t, this.viewContainerRef = e, this.context = n } get origin() { return this.templateRef.elementRef } attach(t, e = this.context) { return this.context = e, super.attach(t) } detach() { return this.context = void 0, super.detach() } } class ht extends ct { constructor(t) { super(), this.element = t instanceof r.l ? t.nativeElement : t } } class dt extends class { constructor() { this._isDisposed = !1, this.attachDomPortal = null } hasAttached() { return !!this._attachedPortal } attach(t) { return t instanceof lt ? (this._attachedPortal = t, this.attachComponentPortal(t)) : t instanceof ut ? (this._attachedPortal = t, this.attachTemplatePortal(t)) : this.attachDomPortal && t instanceof ht ? (this._attachedPortal = t, this.attachDomPortal(t)) : void 0 } detach() { this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn() } dispose() { this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0 } setDisposeFn(t) { this._disposeFn = t } _invokeDisposeFn() { this._disposeFn && (this._disposeFn(), this._disposeFn = null) } }{ constructor(t, e, n, s, r) { super(), this.outletElement = t, this._componentFactoryResolver = e, this._appRef = n, this._defaultInjector = s, this.attachDomPortal = t => { const e = t.element, n = this._document.createComment("dom-portal"); e.parentNode.insertBefore(n, e), this.outletElement.appendChild(e), this._attachedPortal = t, super.setDisposeFn(() => { n.parentNode && n.parentNode.replaceChild(e, n) }) }, this._document = r } attachComponentPortal(t) { const e = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component); let n; return t.viewContainerRef ? (n = t.viewContainerRef.createComponent(e, t.viewContainerRef.length, t.injector || t.viewContainerRef.injector), this.setDisposeFn(() => n.destroy())) : (n = e.create(t.injector || this._defaultInjector), this._appRef.attachView(n.hostView), this.setDisposeFn(() => { this._appRef.detachView(n.hostView), n.destroy() })), this.outletElement.appendChild(this._getComponentRootNode(n)), this._attachedPortal = t, n } attachTemplatePortal(t) { let e = t.viewContainerRef, n = e.createEmbeddedView(t.templateRef, t.context); return n.rootNodes.forEach(t => this.outletElement.appendChild(t)), n.detectChanges(), this.setDisposeFn(() => { let t = e.indexOf(n); -1 !== t && e.remove(t) }), this._attachedPortal = t, n } dispose() { super.dispose(), null != this.outletElement.parentNode && this.outletElement.parentNode.removeChild(this.outletElement) } _getComponentRootNode(t) { return t.hostView.rootNodes[0] } } let pt = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.Pb({ type: t }), t.\u0275inj = r.Ob({}), t })(); var ft = n("VRyK"); const gt = w(); class mt { constructor(t, e) { this._viewportRuler = t, this._previousHTMLStyles = { top: "", left: "" }, this._isEnabled = !1, this._document = e } attach() { } enable() { if (this._canBeEnabled()) { const t = this._document.documentElement; this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = t.style.left || "", this._previousHTMLStyles.top = t.style.top || "", t.style.left = g(-this._previousScrollPosition.left), t.style.top = g(-this._previousScrollPosition.top), t.classList.add("cdk-global-scrollblock"), this._isEnabled = !0 } } disable() { if (this._isEnabled) { const t = this._document.documentElement, e = t.style, n = this._document.body.style, s = e.scrollBehavior || "", r = n.scrollBehavior || ""; this._isEnabled = !1, e.left = this._previousHTMLStyles.left, e.top = this._previousHTMLStyles.top, t.classList.remove("cdk-global-scrollblock"), gt && (e.scrollBehavior = n.scrollBehavior = "auto"), window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), gt && (e.scrollBehavior = s, n.scrollBehavior = r) } } _canBeEnabled() { if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1; const t = this._document.body, e = this._viewportRuler.getViewportSize(); return t.scrollHeight > e.height || t.scrollWidth > e.width } } class bt { constructor(t, e, n, s) { this._scrollDispatcher = t, this._ngZone = e, this._viewportRuler = n, this._config = s, this._scrollSubscription = null, this._detach = () => { this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach()) } } attach(t) { this._overlayRef = t } enable() { if (this._scrollSubscription) return; const t = this._scrollDispatcher.scrolled(0); this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = t.subscribe(() => { const t = this._viewportRuler.getViewportScrollPosition().top; Math.abs(t - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition() })) : this._scrollSubscription = t.subscribe(this._detach) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } class _t { enable() { } disable() { } attach() { } } function vt(t, e) { return e.some(e => t.bottom < e.top || t.top > e.bottom || t.right < e.left || t.left > e.right) } function yt(t, e) { return e.some(e => t.top < e.top || t.bottom > e.bottom || t.left < e.left || t.right > e.right) } class wt { constructor(t, e, n, s) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = n, this._config = s, this._scrollSubscription = null } attach(t) { this._overlayRef = t } enable() { this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => { if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) { const t = this._overlayRef.overlayElement.getBoundingClientRect(), { width: e, height: n } = this._viewportRuler.getViewportSize(); vt(t, [{ width: e, height: n, bottom: n, right: e, top: 0, left: 0 }]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach())) } })) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } let Ct = (() => { class t { constructor(t, e, n, s) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = n, this.noop = () => new _t, this.close = t => new bt(this._scrollDispatcher, this._ngZone, this._viewportRuler, t), this.block = () => new mt(this._viewportRuler, this._document), this.reposition = t => new wt(this._scrollDispatcher, this._viewportRuler, this._ngZone, t), this._document = s } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(rt), r.bc(it), r.bc(r.A), r.bc(s.e)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(rt), Object(r.bc)(it), Object(r.bc)(r.A), Object(r.bc)(s.e)) }, token: t, providedIn: "root" }), t })(); class Ot { constructor(t) { if (this.scrollStrategy = new _t, this.panelClass = "", this.hasBackdrop = !1, this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, t) { const e = Object.keys(t); for (const n of e) void 0 !== t[n] && (this[n] = t[n]) } } } class St { constructor(t, e, n, s, r) { this.offsetX = n, this.offsetY = s, this.panelClass = r, this.originX = t.originX, this.originY = t.originY, this.overlayX = e.overlayX, this.overlayY = e.overlayY } } class xt { constructor(t, e) { this.connectionPair = t, this.scrollableViewProperties = e } } let Et = (() => { class t { constructor(t) { this._attachedOverlays = [], this._document = t } ngOnDestroy() { this.detach() } add(t) { this.remove(t), this._attachedOverlays.push(t) } remove(t) { const e = this._attachedOverlays.indexOf(t); e > -1 && this._attachedOverlays.splice(e, 1), 0 === this._attachedOverlays.length && this.detach() } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(s.e)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(s.e)) }, token: t, providedIn: "root" }), t })(), Tt = (() => { class t extends Et { constructor(t) { super(t), this._keydownListener = t => { const e = this._attachedOverlays; for (let n = e.length - 1; n > -1; n--)if (e[n]._keydownEvents.observers.length > 0) { e[n]._keydownEvents.next(t); break } } } add(t) { super.add(t), this._isAttached || (this._document.body.addEventListener("keydown", this._keydownListener), this._isAttached = !0) } detach() { this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), this._isAttached = !1) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(s.e)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(s.e)) }, token: t, providedIn: "root" }), t })(), kt = (() => { class t extends Et { constructor(t, e) { super(t), this._platform = e, this._cursorStyleIsSet = !1, this._clickListener = t => { const e = t.composedPath ? t.composedPath()[0] : t.target, n = this._attachedOverlays.slice(); for (let s = n.length - 1; s > -1; s--) { const r = n[s]; if (!(r._outsidePointerEvents.observers.length < 1) && r.hasAttached()) { if (r.overlayElement.contains(e)) break; r._outsidePointerEvents.next(t) } } } } add(t) { super.add(t), this._isAttached || (this._document.body.addEventListener("click", this._clickListener, !0), this._document.body.addEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && !this._cursorStyleIsSet && (this._cursorOriginalValue = this._document.body.style.cursor, this._document.body.style.cursor = "pointer", this._cursorStyleIsSet = !0), this._isAttached = !0) } detach() { this._isAttached && (this._document.body.removeEventListener("click", this._clickListener, !0), this._document.body.removeEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && this._cursorStyleIsSet && (this._document.body.style.cursor = this._cursorOriginalValue, this._cursorStyleIsSet = !1), this._isAttached = !1) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(s.e), r.bc(v)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(s.e), Object(r.bc)(v)) }, token: t, providedIn: "root" }), t })(); const jt = !("undefined" == typeof window || !window || !window.__karma__ && !window.jasmine); let At = (() => { class t { constructor(t, e) { this._platform = e, this._document = t } ngOnDestroy() { const t = this._containerElement; t && t.parentNode && t.parentNode.removeChild(t) } getContainerElement() { return this._containerElement || this._createContainer(), this._containerElement } _createContainer() { if (this._platform.isBrowser || jt) { const t = this._document.querySelectorAll('.cdk-overlay-container[platform="server"], .cdk-overlay-container[platform="test"]'); for (let e = 0; e < t.length; e++)t[e].parentNode.removeChild(t[e]) } const t = this._document.createElement("div"); t.classList.add("cdk-overlay-container"), jt ? t.setAttribute("platform", "test") : this._platform.isBrowser || t.setAttribute("platform", "server"), this._document.body.appendChild(t), this._containerElement = t } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(s.e), r.bc(v)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(s.e), Object(r.bc)(v)) }, token: t, providedIn: "root" }), t })(); class Rt { constructor(t, e, n, s, r, a, c, l, u) { this._portalOutlet = t, this._host = e, this._pane = n, this._config = s, this._ngZone = r, this._keyboardDispatcher = a, this._document = c, this._location = l, this._outsideClickDispatcher = u, this._backdropElement = null, this._backdropClick = new i.a, this._attachments = new i.a, this._detachments = new i.a, this._locationChanges = o.a.EMPTY, this._backdropClickHandler = t => this._backdropClick.next(t), this._keydownEvents = new i.a, this._outsidePointerEvents = new i.a, s.scrollStrategy && (this._scrollStrategy = s.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = s.positionStrategy } get overlayElement() { return this._pane } get backdropElement() { return this._backdropElement } get hostElement() { return this._host } attach(t) { let e = this._portalOutlet.attach(t); return !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host), this._positionStrategy && this._positionStrategy.attach(this), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.pipe(Object(d.a)(1)).subscribe(() => { this.hasAttached() && this.updatePosition() }), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && (this._locationChanges = this._location.subscribe(() => this.dispose())), this._outsideClickDispatcher.add(this), e } detach() { if (!this.hasAttached()) return; this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable(); const t = this._portalOutlet.detach(); return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), this._locationChanges.unsubscribe(), this._outsideClickDispatcher.remove(this), t } dispose() { const t = this.hasAttached(); this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this.detachBackdrop(), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._outsidePointerEvents.complete(), this._outsideClickDispatcher.remove(this), this._host && this._host.parentNode && (this._host.parentNode.removeChild(this._host), this._host = null), this._previousHostParent = this._pane = null, t && this._detachments.next(), this._detachments.complete() } hasAttached() { return this._portalOutlet.hasAttached() } backdropClick() { return this._backdropClick } attachments() { return this._attachments } detachments() { return this._detachments } keydownEvents() { return this._keydownEvents } outsidePointerEvents() { return this._outsidePointerEvents } getConfig() { return this._config } updatePosition() { this._positionStrategy && this._positionStrategy.apply() } updatePositionStrategy(t) { t !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = t, this.hasAttached() && (t.attach(this), this.updatePosition())) } updateSize(t) { this._config = Object.assign(Object.assign({}, this._config), t), this._updateElementSize() } setDirection(t) { this._config = Object.assign(Object.assign({}, this._config), { direction: t }), this._updateElementDirection() } addPanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !0) } removePanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !1) } getDirection() { const t = this._config.direction; return t ? "string" == typeof t ? t : t.value : "ltr" } updateScrollStrategy(t) { t !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = t, this.hasAttached() && (t.attach(this), t.enable())) } _updateElementDirection() { this._host.setAttribute("dir", this.getDirection()) } _updateElementSize() { if (!this._pane) return; const t = this._pane.style; t.width = g(this._config.width), t.height = g(this._config.height), t.minWidth = g(this._config.minWidth), t.minHeight = g(this._config.minHeight), t.maxWidth = g(this._config.maxWidth), t.maxHeight = g(this._config.maxHeight) } _togglePointerEvents(t) { this._pane.style.pointerEvents = t ? "" : "none" } _attachBackdrop() { this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => { this._backdropElement && this._backdropElement.classList.add("cdk-overlay-backdrop-showing") }) }) : this._backdropElement.classList.add("cdk-overlay-backdrop-showing") } _updateStackingOrder() { this._host.nextSibling && this._host.parentNode.appendChild(this._host) } detachBackdrop() { let t, e = this._backdropElement; if (!e) return; let n = () => { e && (e.removeEventListener("click", this._backdropClickHandler), e.removeEventListener("transitionend", n), e.parentNode && e.parentNode.removeChild(e)), this._backdropElement == e && (this._backdropElement = null), this._config.backdropClass && this._toggleClasses(e, this._config.backdropClass, !1), clearTimeout(t) }; e.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => { e.addEventListener("transitionend", n) }), e.style.pointerEvents = "none", t = this._ngZone.runOutsideAngular(() => setTimeout(n, 500)) } _toggleClasses(t, e, n) { const s = t.classList; f(e).forEach(t => { t && (n ? s.add(t) : s.remove(t)) }) } _detachContentWhenStable() { this._ngZone.runOutsideAngular(() => { const t = this._ngZone.onStable.pipe(Object(Z.a)(Object(ft.a)(this._attachments, this._detachments))).subscribe(() => { this._pane && this._host && 0 !== this._pane.children.length || (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._previousHostParent.removeChild(this._host)), t.unsubscribe()) }) }) } _disposeScrollStrategy() { const t = this._scrollStrategy; t && (t.disable(), t.detach && t.detach()) } } const Lt = /([A-Za-z%]+)$/; class It { constructor(t, e, n, s, r) { this._viewportRuler = e, this._document = n, this._platform = s, this._overlayContainer = r, this._lastBoundingBoxSize = { width: 0, height: 0 }, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], this._positionChanges = new i.a, this._resizeSubscription = o.a.EMPTY, this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges, this.setOrigin(t) } get positions() { return this._preferredPositions } attach(t) { this._validatePositions(), t.hostElement.classList.add("cdk-overlay-connected-position-bounding-box"), this._overlayRef = t, this._boundingBox = t.hostElement, this._pane = t.overlayElement, this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => { this._isInitialRender = !0, this.apply() }) } apply() { if (this._isDisposed || !this._platform.isBrowser) return; if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition(); this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(); const t = this._originRect, e = this._overlayRect, n = this._viewportRect, s = []; let r; for (let i of this._preferredPositions) { let o = this._getOriginPoint(t, i), a = this._getOverlayPoint(o, e, i), c = this._getOverlayFit(a, e, n, i); if (c.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(i, o); this._canFitWithFlexibleDimensions(c, a, n) ? s.push({ position: i, origin: o, overlayRect: e, boundingBoxRect: this._calculateBoundingBoxRect(o, i) }) : (!r || r.overlayFit.visibleArea < c.visibleArea) && (r = { overlayFit: c, overlayPoint: a, originPoint: o, position: i, overlayRect: e }) } if (s.length) { let t = null, e = -1; for (const n of s) { const s = n.boundingBoxRect.width * n.boundingBoxRect.height * (n.position.weight || 1); s > e && (e = s, t = n) } return this._isPushed = !1, void this._applyPosition(t.position, t.origin) } if (this._canPush) return this._isPushed = !0, void this._applyPosition(r.position, r.originPoint); this._applyPosition(r.position, r.originPoint) } detach() { this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe() } dispose() { this._isDisposed || (this._boundingBox && Pt(this._boundingBox.style, { top: "", left: "", right: "", bottom: "", height: "", width: "", alignItems: "", justifyContent: "" }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove("cdk-overlay-connected-position-bounding-box"), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = !0) } reapplyLastPosition() { if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) { this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect(); const t = this._lastPosition || this._preferredPositions[0], e = this._getOriginPoint(this._originRect, t); this._applyPosition(t, e) } } withScrollableContainers(t) { return this._scrollables = t, this } withPositions(t) { return this._preferredPositions = t, -1 === t.indexOf(this._lastPosition) && (this._lastPosition = null), this._validatePositions(), this } withViewportMargin(t) { return this._viewportMargin = t, this } withFlexibleDimensions(t = !0) { return this._hasFlexibleDimensions = t, this } withGrowAfterOpen(t = !0) { return this._growAfterOpen = t, this } withPush(t = !0) { return this._canPush = t, this } withLockedPosition(t = !0) { return this._positionLocked = t, this } setOrigin(t) { return this._origin = t, this } withDefaultOffsetX(t) { return this._offsetX = t, this } withDefaultOffsetY(t) { return this._offsetY = t, this } withTransformOriginOn(t) { return this._transformOriginSelector = t, this } _getOriginPoint(t, e) { let n, s; if ("center" == e.originX) n = t.left + t.width / 2; else { const s = this._isRtl() ? t.right : t.left, r = this._isRtl() ? t.left : t.right; n = "start" == e.originX ? s : r } return s = "center" == e.originY ? t.top + t.height / 2 : "top" == e.originY ? t.top : t.bottom, { x: n, y: s } } _getOverlayPoint(t, e, n) { let s, r; return s = "center" == n.overlayX ? -e.width / 2 : "start" === n.overlayX ? this._isRtl() ? -e.width : 0 : this._isRtl() ? 0 : -e.width, r = "center" == n.overlayY ? -e.height / 2 : "top" == n.overlayY ? 0 : -e.height, { x: t.x + s, y: t.y + r } } _getOverlayFit(t, e, n, s) { const r = Mt(e); let { x: i, y: o } = t, a = this._getOffset(s, "x"), c = this._getOffset(s, "y"); a && (i += a), c && (o += c); let l = 0 - o, u = o + r.height - n.height, h = this._subtractOverflows(r.width, 0 - i, i + r.width - n.width), d = this._subtractOverflows(r.height, l, u), p = h * d; return { visibleArea: p, isCompletelyWithinViewport: r.width * r.height === p, fitsInViewportVertically: d === r.height, fitsInViewportHorizontally: h == r.width } } _canFitWithFlexibleDimensions(t, e, n) { if (this._hasFlexibleDimensions) { const s = n.bottom - e.y, r = n.right - e.x, i = Dt(this._overlayRef.getConfig().minHeight), o = Dt(this._overlayRef.getConfig().minWidth), a = t.fitsInViewportHorizontally || null != o && o <= r; return (t.fitsInViewportVertically || null != i && i <= s) && a } return !1 } _pushOverlayOnScreen(t, e, n) { if (this._previousPushAmount && this._positionLocked) return { x: t.x + this._previousPushAmount.x, y: t.y + this._previousPushAmount.y }; const s = Mt(e), r = this._viewportRect, i = Math.max(t.x + s.width - r.width, 0), o = Math.max(t.y + s.height - r.height, 0), a = Math.max(r.top - n.top - t.y, 0), c = Math.max(r.left - n.left - t.x, 0); let l = 0, u = 0; return l = s.width <= r.width ? c || -i : t.x < this._viewportMargin ? r.left - n.left - t.x : 0, u = s.height <= r.height ? a || -o : t.y < this._viewportMargin ? r.top - n.top - t.y : 0, this._previousPushAmount = { x: l, y: u }, { x: t.x + l, y: t.y + u } } _applyPosition(t, e) { if (this._setTransformOrigin(t), this._setOverlayElementStyles(e, t), this._setBoundingBoxStyles(e, t), t.panelClass && this._addPanelClasses(t.panelClass), this._lastPosition = t, this._positionChanges.observers.length) { const e = this._getScrollVisibility(), n = new xt(t, e); this._positionChanges.next(n) } this._isInitialRender = !1 } _setTransformOrigin(t) { if (!this._transformOriginSelector) return; const e = this._boundingBox.querySelectorAll(this._transformOriginSelector); let n, s = t.overlayY; n = "center" === t.overlayX ? "center" : this._isRtl() ? "start" === t.overlayX ? "right" : "left" : "start" === t.overlayX ? "left" : "right"; for (let r = 0; r < e.length; r++)e[r].style.transformOrigin = `${n} ${s}` } _calculateBoundingBoxRect(t, e) { const n = this._viewportRect, s = this._isRtl(); let r, i, o, a, c, l; if ("top" === e.overlayY) i = t.y, r = n.height - i + this._viewportMargin; else if ("bottom" === e.overlayY) o = n.height - t.y + 2 * this._viewportMargin, r = n.height - o + this._viewportMargin; else { const e = Math.min(n.bottom - t.y + n.top, t.y), s = this._lastBoundingBoxSize.height; r = 2 * e, i = t.y - e, r > s && !this._isInitialRender && !this._growAfterOpen && (i = t.y - s / 2) } if ("end" === e.overlayX && !s || "start" === e.overlayX && s) l = n.width - t.x + this._viewportMargin, a = t.x - this._viewportMargin; else if ("start" === e.overlayX && !s || "end" === e.overlayX && s) c = t.x, a = n.right - t.x; else { const e = Math.min(n.right - t.x + n.left, t.x), s = this._lastBoundingBoxSize.width; a = 2 * e, c = t.x - e, a > s && !this._isInitialRender && !this._growAfterOpen && (c = t.x - s / 2) } return { top: i, left: c, bottom: o, right: l, width: a, height: r } } _setBoundingBoxStyles(t, e) { const n = this._calculateBoundingBoxRect(t, e); this._isInitialRender || this._growAfterOpen || (n.height = Math.min(n.height, this._lastBoundingBoxSize.height), n.width = Math.min(n.width, this._lastBoundingBoxSize.width)); const s = {}; if (this._hasExactPosition()) s.top = s.left = "0", s.bottom = s.right = s.maxHeight = s.maxWidth = "", s.width = s.height = "100%"; else { const t = this._overlayRef.getConfig().maxHeight, r = this._overlayRef.getConfig().maxWidth; s.height = g(n.height), s.top = g(n.top), s.bottom = g(n.bottom), s.width = g(n.width), s.left = g(n.left), s.right = g(n.right), s.alignItems = "center" === e.overlayX ? "center" : "end" === e.overlayX ? "flex-end" : "flex-start", s.justifyContent = "center" === e.overlayY ? "center" : "bottom" === e.overlayY ? "flex-end" : "flex-start", t && (s.maxHeight = g(t)), r && (s.maxWidth = g(r)) } this._lastBoundingBoxSize = n, Pt(this._boundingBox.style, s) } _resetBoundingBoxStyles() { Pt(this._boundingBox.style, { top: "0", left: "0", right: "0", bottom: "0", height: "", width: "", alignItems: "", justifyContent: "" }) } _resetOverlayElementStyles() { Pt(this._pane.style, { top: "", left: "", bottom: "", right: "", position: "", transform: "" }) } _setOverlayElementStyles(t, e) { const n = {}, s = this._hasExactPosition(), r = this._hasFlexibleDimensions, i = this._overlayRef.getConfig(); if (s) { const s = this._viewportRuler.getViewportScrollPosition(); Pt(n, this._getExactOverlayY(e, t, s)), Pt(n, this._getExactOverlayX(e, t, s)) } else n.position = "static"; let o = "", a = this._getOffset(e, "x"), c = this._getOffset(e, "y"); a && (o += `translateX(${a}px) `), c && (o += `translateY(${c}px)`), n.transform = o.trim(), i.maxHeight && (s ? n.maxHeight = g(i.maxHeight) : r && (n.maxHeight = "")), i.maxWidth && (s ? n.maxWidth = g(i.maxWidth) : r && (n.maxWidth = "")), Pt(this._pane.style, n) } _getExactOverlayY(t, e, n) { let s = { top: "", bottom: "" }, r = this._getOverlayPoint(e, this._overlayRect, t); this._isPushed && (r = this._pushOverlayOnScreen(r, this._overlayRect, n)); let i = this._overlayContainer.getContainerElement().getBoundingClientRect().top; return r.y -= i, "bottom" === t.overlayY ? s.bottom = this._document.documentElement.clientHeight - (r.y + this._overlayRect.height) + "px" : s.top = g(r.y), s } _getExactOverlayX(t, e, n) { let s, r = { left: "", right: "" }, i = this._getOverlayPoint(e, this._overlayRect, t); return this._isPushed && (i = this._pushOverlayOnScreen(i, this._overlayRect, n)), s = this._isRtl() ? "end" === t.overlayX ? "left" : "right" : "end" === t.overlayX ? "right" : "left", "right" === s ? r.right = this._document.documentElement.clientWidth - (i.x + this._overlayRect.width) + "px" : r.left = g(i.x), r } _getScrollVisibility() { const t = this._getOriginRect(), e = this._pane.getBoundingClientRect(), n = this._scrollables.map(t => t.getElementRef().nativeElement.getBoundingClientRect()); return { isOriginClipped: yt(t, n), isOriginOutsideView: vt(t, n), isOverlayClipped: yt(e, n), isOverlayOutsideView: vt(e, n) } } _subtractOverflows(t, ...e) { return e.reduce((t, e) => t - Math.max(e, 0), t) } _getNarrowedViewportRect() { const t = this._document.documentElement.clientWidth, e = this._document.documentElement.clientHeight, n = this._viewportRuler.getViewportScrollPosition(); return { top: n.top + this._viewportMargin, left: n.left + this._viewportMargin, right: n.left + t - this._viewportMargin, bottom: n.top + e - this._viewportMargin, width: t - 2 * this._viewportMargin, height: e - 2 * this._viewportMargin } } _isRtl() { return "rtl" === this._overlayRef.getDirection() } _hasExactPosition() { return !this._hasFlexibleDimensions || this._isPushed } _getOffset(t, e) { return "x" === e ? null == t.offsetX ? this._offsetX : t.offsetX : null == t.offsetY ? this._offsetY : t.offsetY } _validatePositions() { } _addPanelClasses(t) { this._pane && f(t).forEach(t => { "" !== t && -1 === this._appliedPanelClasses.indexOf(t) && (this._appliedPanelClasses.push(t), this._pane.classList.add(t)) }) } _clearPanelClasses() { this._pane && (this._appliedPanelClasses.forEach(t => { this._pane.classList.remove(t) }), this._appliedPanelClasses = []) } _getOriginRect() { const t = this._origin; if (t instanceof r.l) return t.nativeElement.getBoundingClientRect(); if (t instanceof Element) return t.getBoundingClientRect(); const e = t.width || 0, n = t.height || 0; return { top: t.y, bottom: t.y + n, left: t.x, right: t.x + e, height: n, width: e } } } function Pt(t, e) { for (let n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t } function Dt(t) { if ("number" != typeof t && null != t) { const [e, n] = t.split(Lt); return n && "px" !== n ? null : parseFloat(e) } return t || null } function Mt(t) { return { top: Math.floor(t.top), right: Math.floor(t.right), bottom: Math.floor(t.bottom), left: Math.floor(t.left), width: Math.floor(t.width), height: Math.floor(t.height) } } class Nt { constructor(t, e, n, s, r, i, o) { this._preferredPositions = [], this._positionStrategy = new It(n, s, r, i, o).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0), this.withFallbackPosition(t, e), this.onPositionChange = this._positionStrategy.positionChanges } get positions() { return this._preferredPositions } attach(t) { this._overlayRef = t, this._positionStrategy.attach(t), this._direction && (t.setDirection(this._direction), this._direction = null) } dispose() { this._positionStrategy.dispose() } detach() { this._positionStrategy.detach() } apply() { this._positionStrategy.apply() } recalculateLastPosition() { this._positionStrategy.reapplyLastPosition() } withScrollableContainers(t) { this._positionStrategy.withScrollableContainers(t) } withFallbackPosition(t, e, n, s) { const r = new St(t, e, n, s); return this._preferredPositions.push(r), this._positionStrategy.withPositions(this._preferredPositions), this } withDirection(t) { return this._overlayRef ? this._overlayRef.setDirection(t) : this._direction = t, this } withOffsetX(t) { return this._positionStrategy.withDefaultOffsetX(t), this } withOffsetY(t) { return this._positionStrategy.withDefaultOffsetY(t), this } withLockedPosition(t) { return this._positionStrategy.withLockedPosition(t), this } withPositions(t) { return this._preferredPositions = t.slice(), this._positionStrategy.withPositions(this._preferredPositions), this } setOrigin(t) { return this._positionStrategy.setOrigin(t), this } } class Ft { constructor() { this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._leftOffset = "", this._rightOffset = "", this._alignItems = "", this._justifyContent = "", this._width = "", this._height = "" } attach(t) { const e = t.getConfig(); this._overlayRef = t, this._width && !e.width && t.updateSize({ width: this._width }), this._height && !e.height && t.updateSize({ height: this._height }), t.hostElement.classList.add("cdk-global-overlay-wrapper"), this._isDisposed = !1 } top(t = "") { return this._bottomOffset = "", this._topOffset = t, this._alignItems = "flex-start", this } left(t = "") { return this._rightOffset = "", this._leftOffset = t, this._justifyContent = "flex-start", this } bottom(t = "") { return this._topOffset = "", this._bottomOffset = t, this._alignItems = "flex-end", this } right(t = "") { return this._leftOffset = "", this._rightOffset = t, this._justifyContent = "flex-end", this } width(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ width: t }) : this._width = t, this } height(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ height: t }) : this._height = t, this } centerHorizontally(t = "") { return this.left(t), this._justifyContent = "center", this } centerVertically(t = "") { return this.top(t), this._alignItems = "center", this } apply() { if (!this._overlayRef || !this._overlayRef.hasAttached()) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement.style, n = this._overlayRef.getConfig(), { width: s, height: r, maxWidth: i, maxHeight: o } = n, a = !("100%" !== s && "100vw" !== s || i && "100%" !== i && "100vw" !== i), c = !("100%" !== r && "100vh" !== r || o && "100%" !== o && "100vh" !== o); t.position = this._cssPosition, t.marginLeft = a ? "0" : this._leftOffset, t.marginTop = c ? "0" : this._topOffset, t.marginBottom = this._bottomOffset, t.marginRight = this._rightOffset, a ? e.justifyContent = "flex-start" : "center" === this._justifyContent ? e.justifyContent = "center" : "rtl" === this._overlayRef.getConfig().direction ? "flex-start" === this._justifyContent ? e.justifyContent = "flex-end" : "flex-end" === this._justifyContent && (e.justifyContent = "flex-start") : e.justifyContent = this._justifyContent, e.alignItems = c ? "flex-start" : this._alignItems } dispose() { if (this._isDisposed || !this._overlayRef) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement, n = e.style; e.classList.remove("cdk-global-overlay-wrapper"), n.justifyContent = n.alignItems = t.marginTop = t.marginBottom = t.marginLeft = t.marginRight = t.position = "", this._overlayRef = null, this._isDisposed = !0 } } let Vt = (() => { class t { constructor(t, e, n, s) { this._viewportRuler = t, this._document = e, this._platform = n, this._overlayContainer = s } global() { return new Ft } connectedTo(t, e, n) { return new Nt(e, n, t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } flexibleConnectedTo(t) { return new It(t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(it), r.bc(s.e), r.bc(v), r.bc(At)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(it), Object(r.bc)(s.e), Object(r.bc)(v), Object(r.bc)(At)) }, token: t, providedIn: "root" }), t })(), Bt = 0, Ut = (() => { class t { constructor(t, e, n, s, r, i, o, a, c, l, u) { this.scrollStrategies = t, this._overlayContainer = e, this._componentFactoryResolver = n, this._positionBuilder = s, this._keyboardDispatcher = r, this._injector = i, this._ngZone = o, this._document = a, this._directionality = c, this._location = l, this._outsideClickDispatcher = u } create(t) { const e = this._createHostElement(), n = this._createPaneElement(e), s = this._createPortalOutlet(n), r = new Ot(t); return r.direction = r.direction || this._directionality.value, new Rt(s, e, n, r, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher) } position() { return this._positionBuilder } _createPaneElement(t) { const e = this._document.createElement("div"); return e.id = "cdk-overlay-" + Bt++, e.classList.add("cdk-overlay-pane"), t.appendChild(e), e } _createHostElement() { const t = this._document.createElement("div"); return this._overlayContainer.getContainerElement().appendChild(t), t } _createPortalOutlet(t) { return this._appRef || (this._appRef = this._injector.get(r.g)), new dt(t, this._componentFactoryResolver, this._appRef, this._injector, this._document) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(Ct), r.bc(At), r.bc(r.j), r.bc(Vt), r.bc(Tt), r.bc(r.s), r.bc(r.A), r.bc(s.e), r.bc(et), r.bc(s.j), r.bc(kt)) }, t.\u0275prov = r.Nb({ token: t, factory: t.\u0275fac }), t })(); const Ht = { provide: new r.r("cdk-connected-overlay-scroll-strategy"), deps: [Ut], useFactory: function (t) { return () => t.scrollStrategies.reposition() } }; let zt = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.Pb({ type: t }), t.\u0275inj = r.Ob({ providers: [Ut, Ht], imports: [[st, pt, at], at] }), t })(); var $t = n("3Pt+"), Wt = n("mrSG"), qt = n("2Vo4"), Gt = n("itXk"), Xt = n("EY2u"), Kt = (n("jtHE"), n("Cfvw")), Zt = n("3E0/"), Yt = n("GyhO"), Qt = n("SxV6"), Jt = n("nYR2"), te = n("zp1y"), ee = n("bHdf"); function ne(t) { return e => e.lift(new se(t)) } class se { constructor(t) { this.durationSelector = t } call(t, e) { return e.subscribe(new re(t, this.durationSelector)) } } class re extends H.b { constructor(t, e) { super(t), this.durationSelector = e, this.hasValue = !1 } _next(t) { try { const e = this.durationSelector.call(this, t); e && this._tryNext(t, e) } catch (e) { this.destination.error(e) } } _complete() { this.emitValue(), this.destination.complete() } _tryNext(t, e) { let n = this.durationSubscription; this.value = t, this.hasValue = !0, n && (n.unsubscribe(), this.remove(n)), n = Object(H.c)(e, new H.a(this)), n && !n.closed && this.add(this.durationSubscription = n) } notifyNext() { this.emitValue() } notifyComplete() { this.emitValue() } emitValue() { if (this.hasValue) { const t = this.value, e = this.durationSubscription; e && (this.durationSubscription = void 0, e.unsubscribe(), this.remove(e)), this.value = void 0, this.hasValue = !1, super._next(t) } } } function ie(t) { var e = t.getBoundingClientRect(); return { width: e.width, height: e.height, top: e.top, right: e.right, bottom: e.bottom, left: e.left, x: e.left, y: e.top } } function oe(t) { if (null == t) return window; if ("[object Window]" !== t.toString()) { var e = t.ownerDocument; return e && e.defaultView || window } return t } function ae(t) { var e = oe(t); return { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset } } function ce(t) { return t instanceof oe(t).Element || t instanceof Element } function le(t) { return t instanceof oe(t).HTMLElement || t instanceof HTMLElement } function ue(t) { return "undefined" != typeof ShadowRoot && (t instanceof oe(t).ShadowRoot || t instanceof ShadowRoot) } function he(t) { return t ? (t.nodeName || "").toLowerCase() : null } function de(t) { return ((ce(t) ? t.ownerDocument : t.document) || window.document).documentElement } function pe(t) { return ie(de(t)).left + ae(t).scrollLeft } function fe(t) { return oe(t).getComputedStyle(t) } function ge(t) { var e = fe(t); return /auto|scroll|overlay|hidden/.test(e.overflow + e.overflowY + e.overflowX) } function me(t, e, n) { void 0 === n && (n = !1); var s, r, i = de(e), o = ie(t), a = le(e), c = { scrollLeft: 0, scrollTop: 0 }, l = { x: 0, y: 0 }; return (a || !a && !n) && (("body" !== he(e) || ge(i)) && (c = (s = e) !== oe(s) && le(s) ? { scrollLeft: (r = s).scrollLeft, scrollTop: r.scrollTop } : ae(s)), le(e) ? ((l = ie(e)).x += e.clientLeft, l.y += e.clientTop) : i && (l.x = pe(i))), { x: o.left + c.scrollLeft - l.x, y: o.top + c.scrollTop - l.y, width: o.width, height: o.height } } function be(t) { var e = ie(t), n = t.offsetWidth, s = t.offsetHeight; return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - s) <= 1 && (s = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: s } } function _e(t) { return "html" === he(t) ? t : t.assignedSlot || t.parentNode || (ue(t) ? t.host : null) || de(t) } function ve(t) { return ["html", "body", "#document"].indexOf(he(t)) >= 0 ? t.ownerDocument.body : le(t) && ge(t) ? t : ve(_e(t)) } function ye(t, e) { var n; void 0 === e && (e = []); var s = ve(t), r = s === (null == (n = t.ownerDocument) ? void 0 : n.body), i = oe(s), o = r ? [i].concat(i.visualViewport || [], ge(s) ? s : []) : s, a = e.concat(o); return r ? a : a.concat(ye(_e(o))) } function we(t) { return ["table", "td", "th"].indexOf(he(t)) >= 0 } function Ce(t) { return le(t) && "fixed" !== fe(t).position ? t.offsetParent : null } function Oe(t) { for (var e = oe(t), n = Ce(t); n && we(n) && "static" === fe(n).position;)n = Ce(n); return n && ("html" === he(n) || "body" === he(n) && "static" === fe(n).position) ? e : n || function (t) { var e = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox"); if (-1 !== navigator.userAgent.indexOf("Trident") && le(t) && "fixed" === fe(t).position) return null; for (var n = _e(t); le(n) && ["html", "body"].indexOf(he(n)) < 0;) { var s = fe(n); if ("none" !== s.transform || "none" !== s.perspective || "paint" === s.contain || -1 !== ["transform", "perspective"].indexOf(s.willChange) || e && "filter" === s.willChange || e && s.filter && "none" !== s.filter) return n; n = n.parentNode } return null }(t) || e } var Se = "top", xe = "bottom", Ee = "right", Te = "left", ke = [Se, xe, Ee, Te], je = ke.reduce(function (t, e) { return t.concat([e + "-start", e + "-end"]) }, []), Ae = [].concat(ke, ["auto"]).reduce(function (t, e) { return t.concat([e, e + "-start", e + "-end"]) }, []), Re = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"]; function Le(t) { var e = new Map, n = new Set, s = []; function r(t) { n.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach(function (t) { if (!n.has(t)) { var s = e.get(t); s && r(s) } }), s.push(t) } return t.forEach(function (t) { e.set(t.name, t) }), t.forEach(function (t) { n.has(t.name) || r(t) }), s } var Ie = { placement: "bottom", modifiers: [], strategy: "absolute" }; function Pe() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return !e.some(function (t) { return !(t && "function" == typeof t.getBoundingClientRect) }) } function De(t) { void 0 === t && (t = {}); var e = t.defaultModifiers, n = void 0 === e ? [] : e, s = t.defaultOptions, r = void 0 === s ? Ie : s; return function (t, e, s) { void 0 === s && (s = r); var i, o, a = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ie, r), modifiersData: {}, elements: { reference: t, popper: e }, attributes: {}, styles: {} }, c = [], l = !1, u = { state: a, setOptions: function (s) { h(), a.options = Object.assign({}, r, a.options, s), a.scrollParents = { reference: ce(t) ? ye(t) : t.contextElement ? ye(t.contextElement) : [], popper: ye(e) }; var i, o, l = function (t) { var e = Le(t); return Re.reduce(function (t, n) { return t.concat(e.filter(function (t) { return t.phase === n })) }, []) }((i = [].concat(n, a.options.modifiers), o = i.reduce(function (t, e) { var n = t[e.name]; return t[e.name] = n ? Object.assign({}, n, e, { options: Object.assign({}, n.options, e.options), data: Object.assign({}, n.data, e.data) }) : e, t }, {}), Object.keys(o).map(function (t) { return o[t] }))); return a.orderedModifiers = l.filter(function (t) { return t.enabled }), a.orderedModifiers.forEach(function (t) { var e = t.options, n = t.effect; if ("function" == typeof n) { var s = n({ state: a, name: t.name, instance: u, options: void 0 === e ? {} : e }); c.push(s || function () { }) } }), u.update() }, forceUpdate: function () { if (!l) { var t = a.elements, e = t.reference, n = t.popper; if (Pe(e, n)) { a.rects = { reference: me(e, Oe(n), "fixed" === a.options.strategy), popper: be(n) }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach(function (t) { return a.modifiersData[t.name] = Object.assign({}, t.data) }); for (var s = 0; s < a.orderedModifiers.length; s++)if (!0 !== a.reset) { var r = a.orderedModifiers[s], i = r.fn, o = r.options; "function" == typeof i && (a = i({ state: a, options: void 0 === o ? {} : o, name: r.name, instance: u }) || a) } else a.reset = !1, s = -1 } } }, update: (i = function () { return new Promise(function (t) { u.forceUpdate(), t(a) }) }, function () { return o || (o = new Promise(function (t) { Promise.resolve().then(function () { o = void 0, t(i()) }) })), o }), destroy: function () { h(), l = !0 } }; if (!Pe(t, e)) return u; function h() { c.forEach(function (t) { return t() }), c = [] } return u.setOptions(s).then(function (t) { !l && s.onFirstUpdate && s.onFirstUpdate(t) }), u } } var Me = { passive: !0 }; function Ne(t) { return t.split("-")[0] } function Fe(t) { return t.split("-")[1] } function Ve(t) { return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y" } function Be(t) { var e, n = t.reference, s = t.element, r = t.placement, i = r ? Ne(r) : null, o = r ? Fe(r) : null, a = n.x + n.width / 2 - s.width / 2, c = n.y + n.height / 2 - s.height / 2; switch (i) { case Se: e = { x: a, y: n.y - s.height }; break; case xe: e = { x: a, y: n.y + n.height }; break; case Ee: e = { x: n.x + n.width, y: c }; break; case Te: e = { x: n.x - s.width, y: c }; break; default: e = { x: n.x, y: n.y } }var l = i ? Ve(i) : null; if (null != l) { var u = "y" === l ? "height" : "width"; switch (o) { case "start": e[l] = e[l] - (n[u] / 2 - s[u] / 2); break; case "end": e[l] = e[l] + (n[u] / 2 - s[u] / 2) } } return e } var Ue = Math.max, He = Math.min, ze = Math.round, $e = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function We(t) { var e, n = t.popper, s = t.popperRect, r = t.placement, i = t.offsets, o = t.position, a = t.gpuAcceleration, c = t.adaptive, l = t.roundOffsets, u = !0 === l ? function (t) { var e = t.y, n = window.devicePixelRatio || 1; return { x: ze(ze(t.x * n) / n) || 0, y: ze(ze(e * n) / n) || 0 } }(i) : "function" == typeof l ? l(i) : i, h = u.x, d = void 0 === h ? 0 : h, p = u.y, f = void 0 === p ? 0 : p, g = i.hasOwnProperty("x"), m = i.hasOwnProperty("y"), b = Te, _ = Se, v = window; if (c) { var y = Oe(n), w = "clientHeight", C = "clientWidth"; y === oe(n) && "static" !== fe(y = de(n)).position && (w = "scrollHeight", C = "scrollWidth"), y = y, r === Se && (_ = xe, f -= y[w] - s.height, f *= a ? 1 : -1), r === Te && (b = Ee, d -= y[C] - s.width, d *= a ? 1 : -1) } var O, S = Object.assign({ position: o }, c && $e); return Object.assign({}, S, a ? ((O = {})[_] = m ? "0" : "", O[b] = g ? "0" : "", O.transform = (v.devicePixelRatio || 1) < 2 ? "translate(" + d + "px, " + f + "px)" : "translate3d(" + d + "px, " + f + "px, 0)", O) : ((e = {})[_] = m ? f + "px" : "", e[b] = g ? d + "px" : "", e.transform = "", e)) } var qe = { left: "right", right: "left", bottom: "top", top: "bottom" }; function Ge(t) { return t.replace(/left|right|bottom|top/g, function (t) { return qe[t] }) } var Xe = { start: "end", end: "start" }; function Ke(t) { return t.replace(/start|end/g, function (t) { return Xe[t] }) } function Ze(t, e) { var n = e.getRootNode && e.getRootNode(); if (t.contains(e)) return !0; if (n && ue(n)) { var s = e; do { if (s && t.isSameNode(s)) return !0; s = s.parentNode || s.host } while (s) } return !1 } function Ye(t) { return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height }) } function Qe(t, e) { return "viewport" === e ? Ye(function (t) { var e = oe(t), n = de(t), s = e.visualViewport, r = n.clientWidth, i = n.clientHeight, o = 0, a = 0; return s && (r = s.width, i = s.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = s.offsetLeft, a = s.offsetTop)), { width: r, height: i, x: o + pe(t), y: a } }(t)) : le(e) ? function (t) { var e = ie(t); return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e }(e) : Ye(function (t) { var e, n = de(t), s = ae(t), r = null == (e = t.ownerDocument) ? void 0 : e.body, i = Ue(n.scrollWidth, n.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), o = Ue(n.scrollHeight, n.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), a = -s.scrollLeft + pe(t), c = -s.scrollTop; return "rtl" === fe(r || n).direction && (a += Ue(n.clientWidth, r ? r.clientWidth : 0) - i), { width: i, height: o, x: a, y: c } }(de(t))) } function Je(t) { return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, t) } function tn(t, e) { return e.reduce(function (e, n) { return e[n] = t, e }, {}) } function en(t, e) { void 0 === e && (e = {}); var n = e.placement, s = void 0 === n ? t.placement : n, r = e.boundary, i = void 0 === r ? "clippingParents" : r, o = e.rootBoundary, a = void 0 === o ? "viewport" : o, c = e.elementContext, l = void 0 === c ? "popper" : c, u = e.altBoundary, h = void 0 !== u && u, d = e.padding, p = void 0 === d ? 0 : d, f = Je("number" != typeof p ? p : tn(p, ke)), g = t.elements.reference, m = t.rects.popper, b = t.elements[h ? "popper" === l ? "reference" : "popper" : l], _ = function (t, e, n) { var s = "clippingParents" === e ? function (t) { var e = ye(_e(t)), n = ["absolute", "fixed"].indexOf(fe(t).position) >= 0 && le(t) ? Oe(t) : t; return ce(n) ? e.filter(function (t) { return ce(t) && Ze(t, n) && "body" !== he(t) }) : [] }(t) : [].concat(e), r = [].concat(s, [n]), i = r.reduce(function (e, n) { var s = Qe(t, n); return e.top = Ue(s.top, e.top), e.right = He(s.right, e.right), e.bottom = He(s.bottom, e.bottom), e.left = Ue(s.left, e.left), e }, Qe(t, r[0])); return i.width = i.right - i.left, i.height = i.bottom - i.top, i.x = i.left, i.y = i.top, i }(ce(b) ? b : b.contextElement || de(t.elements.popper), i, a), v = ie(g), y = Be({ reference: v, element: m, strategy: "absolute", placement: s }), w = Ye(Object.assign({}, m, y)), C = "popper" === l ? w : v, O = { top: _.top - C.top + f.top, bottom: C.bottom - _.bottom + f.bottom, left: _.left - C.left + f.left, right: C.right - _.right + f.right }, S = t.modifiersData.offset; if ("popper" === l && S) { var x = S[s]; Object.keys(O).forEach(function (t) { var e = [Ee, xe].indexOf(t) >= 0 ? 1 : -1, n = [Se, xe].indexOf(t) >= 0 ? "y" : "x"; O[t] += x[n] * e }) } return O } function nn(t, e, n) { return Ue(t, He(e, n)) } function sn(t, e, n) { return void 0 === n && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x } } function rn(t) { return [Se, Ee, xe, Te].some(function (e) { return t[e] >= 0 }) } var on = De({ defaultModifiers: [{ name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: function (t) { var e = t.state, n = t.instance, s = t.options, r = s.scroll, i = void 0 === r || r, o = s.resize, a = void 0 === o || o, c = oe(e.elements.popper), l = [].concat(e.scrollParents.reference, e.scrollParents.popper); return i && l.forEach(function (t) { t.addEventListener("scroll", n.update, Me) }), a && c.addEventListener("resize", n.update, Me), function () { i && l.forEach(function (t) { t.removeEventListener("scroll", n.update, Me) }), a && c.removeEventListener("resize", n.update, Me) } }, data: {} }, { name: "popperOffsets", enabled: !0, phase: "read", fn: function (t) { var e = t.state; e.modifiersData[t.name] = Be({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement }) }, data: {} }, { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (t) { var e = t.state, n = t.options, s = n.gpuAcceleration, r = void 0 === s || s, i = n.adaptive, o = void 0 === i || i, a = n.roundOffsets, c = void 0 === a || a, l = { placement: Ne(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: r }; null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, We(Object.assign({}, l, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: o, roundOffsets: c })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, We(Object.assign({}, l, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: c })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement }) }, data: {} }, { name: "applyStyles", enabled: !0, phase: "write", fn: function (t) { var e = t.state; Object.keys(e.elements).forEach(function (t) { var n = e.styles[t] || {}, s = e.attributes[t] || {}, r = e.elements[t]; le(r) && he(r) && (Object.assign(r.style, n), Object.keys(s).forEach(function (t) { var e = s[t]; !1 === e ? r.removeAttribute(t) : r.setAttribute(t, !0 === e ? "" : e) })) }) }, effect: function (t) { var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function () { Object.keys(e.elements).forEach(function (t) { var s = e.elements[t], r = e.attributes[t] || {}, i = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : n[t]).reduce(function (t, e) { return t[e] = "", t }, {}); le(s) && he(s) && (Object.assign(s.style, i), Object.keys(r).forEach(function (t) { s.removeAttribute(t) })) }) } }, requires: ["computeStyles"] }, { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (t) { var e = t.state, n = t.name, s = t.options.offset, r = void 0 === s ? [0, 0] : s, i = Ae.reduce(function (t, n) { return t[n] = function (t, e, n) { var s = Ne(t), r = [Te, Se].indexOf(s) >= 0 ? -1 : 1, i = "function" == typeof n ? n(Object.assign({}, e, { placement: t })) : n, o = i[0], a = i[1]; return o = o || 0, a = (a || 0) * r, [Te, Ee].indexOf(s) >= 0 ? { x: a, y: o } : { x: o, y: a } }(n, e.rects, r), t }, {}), o = i[e.placement], a = o.y; null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += o.x, e.modifiersData.popperOffsets.y += a), e.modifiersData[n] = i } }, { name: "flip", enabled: !0, phase: "main", fn: function (t) { var e = t.state, n = t.options, s = t.name; if (!e.modifiersData[s]._skip) { for (var r = n.mainAxis, i = void 0 === r || r, o = n.altAxis, a = void 0 === o || o, c = n.fallbackPlacements, l = n.padding, u = n.boundary, h = n.rootBoundary, d = n.altBoundary, p = n.flipVariations, f = void 0 === p || p, g = n.allowedAutoPlacements, m = e.options.placement, b = Ne(m), _ = c || (b !== m && f ? function (t) { if ("auto" === Ne(t)) return []; var e = Ge(t); return [Ke(t), e, Ke(e)] }(m) : [Ge(m)]), v = [m].concat(_).reduce(function (t, n) { return t.concat("auto" === Ne(n) ? function (t, e) { void 0 === e && (e = {}); var n = e.boundary, s = e.rootBoundary, r = e.padding, i = e.flipVariations, o = e.allowedAutoPlacements, a = void 0 === o ? Ae : o, c = Fe(e.placement), l = c ? i ? je : je.filter(function (t) { return Fe(t) === c }) : ke, u = l.filter(function (t) { return a.indexOf(t) >= 0 }); 0 === u.length && (u = l); var h = u.reduce(function (e, i) { return e[i] = en(t, { placement: i, boundary: n, rootBoundary: s, padding: r })[Ne(i)], e }, {}); return Object.keys(h).sort(function (t, e) { return h[t] - h[e] }) }(e, { placement: n, boundary: u, rootBoundary: h, padding: l, flipVariations: f, allowedAutoPlacements: g }) : n) }, []), y = e.rects.reference, w = e.rects.popper, C = new Map, O = !0, S = v[0], x = 0; x < v.length; x++) { var E = v[x], T = Ne(E), k = "start" === Fe(E), j = [Se, xe].indexOf(T) >= 0, A = j ? "width" : "height", R = en(e, { placement: E, boundary: u, rootBoundary: h, altBoundary: d, padding: l }), L = j ? k ? Ee : Te : k ? xe : Se; y[A] > w[A] && (L = Ge(L)); var I = Ge(L), P = []; if (i && P.push(R[T] <= 0), a && P.push(R[L] <= 0, R[I] <= 0), P.every(function (t) { return t })) { S = E, O = !1; break } C.set(E, P) } if (O) for (var D = function (t) { var e = v.find(function (e) { var n = C.get(e); if (n) return n.slice(0, t).every(function (t) { return t }) }); if (e) return S = e, "break" }, M = f ? 3 : 1; M > 0 && "break" !== D(M); M--); e.placement !== S && (e.modifiersData[s]._skip = !0, e.placement = S, e.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }, { name: "preventOverflow", enabled: !0, phase: "main", fn: function (t) { var e = t.state, n = t.options, s = t.name, r = n.mainAxis, i = void 0 === r || r, o = n.altAxis, a = void 0 !== o && o, c = n.tether, l = void 0 === c || c, u = n.tetherOffset, h = void 0 === u ? 0 : u, d = en(e, { boundary: n.boundary, rootBoundary: n.rootBoundary, padding: n.padding, altBoundary: n.altBoundary }), p = Ne(e.placement), f = Fe(e.placement), g = !f, m = Ve(p), b = "x" === m ? "y" : "x", _ = e.modifiersData.popperOffsets, v = e.rects.reference, y = e.rects.popper, w = "function" == typeof h ? h(Object.assign({}, e.rects, { placement: e.placement })) : h, C = { x: 0, y: 0 }; if (_) { if (i || a) { var O = "y" === m ? Se : Te, S = "y" === m ? xe : Ee, x = "y" === m ? "height" : "width", E = _[m], T = _[m] + d[O], k = _[m] - d[S], j = l ? -y[x] / 2 : 0, A = "start" === f ? v[x] : y[x], R = "start" === f ? -y[x] : -v[x], L = e.elements.arrow, I = l && L ? be(L) : { width: 0, height: 0 }, P = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, D = P[O], M = P[S], N = nn(0, v[x], I[x]), F = g ? v[x] / 2 - j - N - D - w : A - N - D - w, V = g ? -v[x] / 2 + j + N + M + w : R + N + M + w, B = e.elements.arrow && Oe(e.elements.arrow), U = e.modifiersData.offset ? e.modifiersData.offset[e.placement][m] : 0, H = _[m] + F - U - (B ? "y" === m ? B.clientTop || 0 : B.clientLeft || 0 : 0), z = _[m] + V - U; if (i) { var $ = nn(l ? He(T, H) : T, E, l ? Ue(k, z) : k); _[m] = $, C[m] = $ - E } if (a) { var W = _[b], q = W + d["x" === m ? Se : Te], G = W - d["x" === m ? xe : Ee], X = nn(l ? He(q, H) : q, W, l ? Ue(G, z) : G); _[b] = X, C[b] = X - W } } e.modifiersData[s] = C } }, requiresIfExists: ["offset"] }, { name: "arrow", enabled: !0, phase: "main", fn: function (t) { var e, n = t.state, s = t.name, r = t.options, i = n.elements.arrow, o = n.modifiersData.popperOffsets, a = Ne(n.placement), c = Ve(a), l = [Te, Ee].indexOf(a) >= 0 ? "height" : "width"; if (i && o) { var u = function (t, e) { return Je("number" != typeof (t = "function" == typeof t ? t(Object.assign({}, e.rects, { placement: e.placement })) : t) ? t : tn(t, ke)) }(r.padding, n), h = be(i), d = "y" === c ? Se : Te, p = "y" === c ? xe : Ee, f = n.rects.reference[l] + n.rects.reference[c] - o[c] - n.rects.popper[l], g = o[c] - n.rects.reference[c], m = Oe(i), b = m ? "y" === c ? m.clientHeight || 0 : m.clientWidth || 0 : 0, _ = b / 2 - h[l] / 2 + (f / 2 - g / 2), v = nn(u[d], _, b - h[l] - u[p]); n.modifiersData[s] = ((e = {})[c] = v, e.centerOffset = v - _, e) } }, effect: function (t) { var e = t.state, n = t.options.element, s = void 0 === n ? "[data-popper-arrow]" : n; null != s && ("string" != typeof s || (s = e.elements.popper.querySelector(s))) && Ze(e.elements.popper, s) && (e.elements.arrow = s) }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }, { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (t) { var e = t.state, n = t.name, s = e.rects.reference, r = e.rects.popper, i = e.modifiersData.preventOverflow, o = en(e, { elementContext: "reference" }), a = en(e, { altBoundary: !0 }), c = sn(o, s), l = sn(a, r, i), u = rn(c), h = rn(l); e.modifiersData[n] = { referenceClippingOffsets: c, popperEscapeOffsets: l, isReferenceHidden: u, hasPopperEscaped: h }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": h }) } }] }); function an(t) { if (null === t || !0 === t || !1 === t) return NaN; var e = Number(t); return isNaN(e) ? e : e < 0 ? Math.ceil(e) : Math.floor(e) } var cn = n("jIYg"), ln = { dateTimeDelimiter: /[T ]/, timeZoneDelimiter: /[Z ]/i, timezone: /([Z+-].*)$/ }, un = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, hn = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, dn = /^([+-])(\d{2})(?::?(\d{2}))?$/; function pn(t) { var e, n = {}, s = t.split(ln.dateTimeDelimiter); if (s.length > 2) return n; if (/:/.test(s[0]) ? (n.date = null, e = s[0]) : (n.date = s[0], e = s[1], ln.timeZoneDelimiter.test(n.date) && (n.date = t.split(ln.timeZoneDelimiter)[0], e = t.substr(n.date.length, t.length))), e) { var r = ln.timezone.exec(e); r ? (n.time = e.replace(r[1], ""), n.timezone = r[1]) : n.time = e } return n } function fn(t, e) { var n = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + e) + "})|(\\d{2}|[+-]\\d{" + (2 + e) + "})$)"), s = t.match(n); if (!s) return { year: null }; var r = s[1] && parseInt(s[1]), i = s[2] && parseInt(s[2]); return { year: null == i ? r : 100 * i, restDateString: t.slice((s[1] || s[2]).length) } } function gn(t, e) { if (null === e) return null; var n = t.match(un); if (!n) return null; var s = !!n[4], r = mn(n[1]), i = mn(n[2]) - 1, o = mn(n[3]), a = mn(n[4]), c = mn(n[5]) - 1; if (s) return function (t, e, n) { return e >= 1 && e <= 53 && n >= 0 && n <= 6 }(0, a, c) ? function (t, e, n) { var s = new Date(0); s.setUTCFullYear(t, 0, 4); var r = 7 * (e - 1) + n + 1 - (s.getUTCDay() || 7); return s.setUTCDate(s.getUTCDate() + r), s }(e, a, c) : new Date(NaN); var l = new Date(0); return function (t, e, n) { return e >= 0 && e <= 11 && n >= 1 && n <= (yn[e] || (wn(t) ? 29 : 28)) }(e, i, o) && function (t, e) { return e >= 1 && e <= (wn(t) ? 366 : 365) }(e, r) ? (l.setUTCFullYear(e, i, Math.max(r, o)), l) : new Date(NaN) } function mn(t) { return t ? parseInt(t) : 1 } function bn(t) { var e = t.match(hn); if (!e) return null; var n = _n(e[1]), s = _n(e[2]), r = _n(e[3]); return function (t, e, n) { return 24 === t ? 0 === e && 0 === n : n >= 0 && n < 60 && e >= 0 && e < 60 && t >= 0 && t < 25 }(n, s, r) ? 36e5 * n + 6e4 * s + 1e3 * r : NaN } function _n(t) { return t && parseFloat(t.replace(",", ".")) || 0 } function vn(t) { if ("Z" === t) return 0; var e = t.match(dn); if (!e) return 0; var n = "+" === e[1] ? -1 : 1, s = parseInt(e[2]), r = e[3] && parseInt(e[3]) || 0; return function (t, e) { return e >= 0 && e <= 59 }(0, r) ? n * (36e5 * s + 6e4 * r) : NaN } var yn = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; function wn(t) { return t % 400 == 0 || t % 4 == 0 && t % 100 } function Cn(t) { return function (e) { var n = e || {}, s = n.width ? String(n.width) : t.defaultWidth; return t.formats[s] || t.formats[t.defaultWidth] } } function On(t) { return function (e, n) { var s, r = n || {}; if ("formatting" === (r.context ? String(r.context) : "standalone") && t.formattingValues) { var i = t.defaultFormattingWidth || t.defaultWidth, o = r.width ? String(r.width) : i; s = t.formattingValues[o] || t.formattingValues[i] } else { var a = t.defaultWidth, c = r.width ? String(r.width) : t.defaultWidth; s = t.values[c] || t.values[a] } return s[t.argumentCallback ? t.argumentCallback(e) : e] } } function Sn(t) { return function (e, n) { var s = String(e), r = n || {}, i = r.width, o = s.match(i && t.matchPatterns[i] || t.matchPatterns[t.defaultMatchWidth]); if (!o) return null; var a, c = o[0], l = i && t.parsePatterns[i] || t.parsePatterns[t.defaultParseWidth]; return a = "[object Array]" === Object.prototype.toString.call(l) ? function (t, e) { for (var n = 0; n < t.length; n++)if (t[n].test(c)) return n }(l) : function (t, e) { for (var n in t) if (t.hasOwnProperty(n) && t[n].test(c)) return n }(l), a = t.valueCallback ? t.valueCallback(a) : a, { value: a = r.valueCallback ? r.valueCallback(a) : a, rest: s.slice(c.length) } } } n("/Tr7"), n("Se/U"), n("jKzE"), n("piIK"), Cn({ formats: { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, defaultWidth: "full" }), Cn({ formats: { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, defaultWidth: "full" }), Cn({ formats: { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, defaultWidth: "full" }), On({ values: { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, defaultWidth: "wide" }), On({ values: { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] }, defaultWidth: "wide", argumentCallback: function (t) { return Number(t) - 1 } }), On({ values: { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, defaultWidth: "wide" }), On({ values: { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, defaultWidth: "wide" }), On({ values: { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" } }, defaultWidth: "wide", formattingValues: { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" } }, defaultFormattingWidth: "wide" }), Sn({ matchPatterns: { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i }, defaultMatchWidth: "wide", parsePatterns: { any: [/^b/i, /^(a|c)/i] }, defaultParseWidth: "any" }), Sn({ matchPatterns: { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i }, defaultMatchWidth: "wide", parsePatterns: { any: [/1/i, /2/i, /3/i, /4/i] }, defaultParseWidth: "any", valueCallback: function (t) { return t + 1 } }), Sn({ matchPatterns: { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i }, defaultMatchWidth: "wide", parsePatterns: { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] }, defaultParseWidth: "any" }), Sn({ matchPatterns: { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i }, defaultMatchWidth: "wide", parsePatterns: { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] }, defaultParseWidth: "any" }), Sn({ matchPatterns: { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i }, defaultMatchWidth: "any", parsePatterns: { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } }, defaultParseWidth: "any" }); var xn = n("zP0r"); const En = new Set; let Tn, kn = (() => { class t { constructor(t) { this._platform = t, this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : jn } matchMedia(t) { return this._platform.WEBKIT && function (t) { if (!En.has(t)) try { Tn || (Tn = document.createElement("style"), Tn.setAttribute("type", "text/css"), document.head.appendChild(Tn)), Tn.sheet && (Tn.sheet.insertRule(`@media ${t} {.fx-query-test{ }}`, 0), En.add(t)) } catch (e) { console.error(e) } }(t), this._matchMedia(t) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(v)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(v)) }, token: t, providedIn: "root" }), t })(); function jn(t) { return { matches: "all" === t || "" === t, media: t, addListener: () => { }, removeListener: () => { } } } let An = (() => { class t { constructor(t, e) { this._mediaMatcher = t, this._zone = e, this._queries = new Map, this._destroySubject = new i.a } ngOnDestroy() { this._destroySubject.next(), this._destroySubject.complete() } isMatched(t) { return Rn(f(t)).some(t => this._registerQuery(t).mql.matches) } observe(t) { const e = Rn(f(t)).map(t => this._registerQuery(t).observable); let n = Object(Gt.a)(e); return n = Object(Yt.a)(n.pipe(Object(d.a)(1)), n.pipe(Object(xn.a)(1), Object(l.a)(0))), n.pipe(Object(h.a)(t => { const e = { matches: !1, breakpoints: {} }; return t.forEach(({ matches: t, query: n }) => { e.matches = e.matches || t, e.breakpoints[n] = t }), e })) } _registerQuery(t) { if (this._queries.has(t)) return this._queries.get(t); const e = this._mediaMatcher.matchMedia(t), n = { observable: new C.a(t => { const n = e => this._zone.run(() => t.next(e)); return e.addListener(n), () => { e.removeListener(n) } }).pipe(Object(Y.a)(e), Object(h.a)(({ matches: e }) => ({ query: t, matches: e })), Object(Z.a)(this._destroySubject)), mql: e }; return this._queries.set(t, n), n } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(kn), r.bc(r.A)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(kn), Object(r.bc)(r.A)) }, token: t, providedIn: "root" }), t })(); function Rn(t) { return t.map(t => t.split(",")).reduce((t, e) => t.concat(e)).map(t => t.trim()) } var Ln = n("sYmb"), In = n("tyNb"), Pn = n("R0Ic"), Dn = n("jhN1"); const Mn = ["*"]; function Nn(t, e) { if (1 & t && (r.Sb(0, "img", 11), r.ic(1, "stripHtml")), 2 & t) { const t = r.hc(2); r.oc("src", t.imageUrl, r.Dc)("alt", r.jc(1, 4, t.imageAlt))("srcset", t.imageSrcSet, r.Dc)("ngClass", t.imageClass) } } function Fn(t, e) { if (1 & t && r.Sb(0, "ptrn-icon", 12), 2 & t) { const t = r.hc(2); r.oc("icon", t.icon)("size", t.iconSize)("cssClass", t.iconClass) } } function Vn(t, e) { if (1 & t && (r.Xb(0, "div", 8), r.Gc(1, Nn, 2, 6, "img", 9), r.Gc(2, Fn, 1, 3, "ptrn-icon", 10), r.Wb()), 2 & t) { const t = r.hc(); r.Cb(1), r.oc("ngIf", !!t.imageUrl), r.Cb(1), r.oc("ngIf", !!t.icon) } } function Bn(t, e) { if (1 & t && r.Sb(0, "span", 13), 2 & t) { const t = r.hc(); r.oc("id", t.headingId)("innerHTML", t.label, r.Cc) } } function Un(t, e) { 1 & t && r.Tb(0) } function Hn(t, e) { if (1 & t && (r.Vb(0), r.Xb(1, "section", 14), r.Gc(2, Un, 1, 0, "ng-container", 15), r.Wb(), r.Ub()), 2 & t) { const t = r.hc(); r.Cb(1), r.oc("ngClass", t.cssClass), r.Cb(1), r.oc("ngTemplateOutlet", t.groupContentTemplate || null) } } const zn = [[["ptrn-accordion-group-header"]]], $n = ["ptrn-accordion-group-header"]; function Wn(t, e) { if (1 & t) { const t = r.Yb(); r.Xb(0, "ptrn-action-buttons"), r.Xb(1, "ptrn-button", 6), r.ec("action", function () { return r.Bc(t), r.hc(2).toggleAll(!0) }), r.Sb(2, "span", 7), r.Wb(), r.Xb(3, "ptrn-button", 8), r.ec("action", function () { return r.Bc(t), r.hc(2).toggleAll(!1) }), r.Sb(4, "span", 7), r.Wb(), r.Wb() } if (2 & t) { const t = r.hc(2); r.Cb(1), r.oc("isAction", !0), r.Cb(1), r.oc("innerHTML", t.labelExpandAll, r.Cc), r.Cb(1), r.oc("isAction", !0), r.Cb(1), r.oc("innerHTML", t.labelCollapseAll, r.Cc) } } function qn(t, e) { if (1 & t && (r.Xb(0, "header", 3), r.Xb(1, "div", 4), r.mc(2, 1), r.Wb(), r.Gc(3, Wn, 5, 4, "ptrn-action-buttons", 5), r.Wb()), 2 & t) { const t = r.hc(); r.Cb(3), r.oc("ngIf", t.shouldShowHeaderActions) } } const Gn = ["*", [["ptrn-accordion-heading"]]], Xn = ["*", "ptrn-accordion-heading"]; function Kn(t, e) { 1 & t && (r.mc(0), r.mc(1, 1)) } const Zn = function (t) { return { $implicit: t } }; function Yn(t, e) { if (1 & t && r.Tb(0, 6), 2 & t) { const t = r.hc(2); r.oc("ngTemplateOutlet", t.readOnlyTemplate.template)("ngTemplateOutletContext", r.tc(2, Zn, t)) } } function Qn(t, e) { 1 & t && r.Tb(0) } function Jn(t, e) { if (1 & t && (r.Xb(0, "div", 7), r.Gc(1, Qn, 1, 0, "ng-container", 8), r.Wb()), 2 & t) { r.hc(2); const t = r.yc(1); r.Cb(1), r.oc("ngTemplateOutlet", t) } } function ts(t, e) { if (1 & t && (r.Vb(0), r.Gc(1, Yn, 1, 4, "ng-container", 4), r.Gc(2, Jn, 2, 1, "div", 5), r.Ub()), 2 & t) { const t = r.hc(), e = r.yc(5); r.Cb(1), r.oc("ngIf", t.readOnlyTemplate)("ngIfElse", e), r.Cb(1), r.oc("ngIf", t.hasWarnings) } } function es(t, e) { if (1 & t && r.Sb(0, "dt", 12), 2 & t) { const t = r.hc(2); r.oc("innerHTML", t.readOnlyLabel, r.Cc) } } function ns(t, e) { 1 & t && r.Tb(0) } function ss(t, e) { if (1 & t && (r.Xb(0, "div", 7), r.Gc(1, ns, 1, 0, "ng-container", 8), r.Wb()), 2 & t) { r.hc(2); const t = r.yc(1); r.Cb(1), r.oc("ngTemplateOutlet", t) } } const rs = function (t) { return { "data__value--empty": t } }; function is(t, e) { if (1 & t && (r.Xb(0, "dl", 9), r.Gc(1, es, 1, 1, "dt", 10), r.Sb(2, "dd", 11), r.Gc(3, ss, 2, 1, "div", 5), r.Wb()), 2 & t) { const t = r.hc(); r.Cb(1), r.oc("ngIf", t.label || t.inlineLabel), r.Cb(1), r.oc("ngClass", r.tc(4, rs, !t.hasValue))("innerHTML", t.hasValue ? t.display : t.emptyLabel, r.Cc), r.Cb(1), r.oc("ngIf", t.hasWarnings) } } function os(t, e) { 1 & t && (r.Xb(0, "span"), r.Ic(1, "\xa0"), r.Wb()) } function as(t, e) { if (1 & t && r.Sb(0, "span", 18), 2 & t) { const t = r.hc(3); r.oc("innerHTML", t.optionalText, r.Cc) } } function cs(t, e) { if (1 & t && (r.Xb(0, "label", 14), r.ic(1, "async"), r.Sb(2, "span", 15), r.Gc(3, os, 2, 0, "span", 16), r.Gc(4, as, 1, 1, "span", 17), r.Wb()), 2 & t) { const t = r.hc(2); r.Jb("field__label--hasFocus", r.jc(1, 6, t.focused$)), r.oc("for", t.path), r.Cb(2), r.oc("innerHTML", t.labelValue, r.Cc), r.Cb(1), r.oc("ngIf", t.isOptional), r.Cb(1), r.oc("ngIf", t.isOptional) } } function ls(t, e) { 1 & t && r.Tb(0) } function us(t, e) { if (1 & t && (r.Gc(0, cs, 5, 8, "label", 13), r.mc(1, 2), r.Xb(2, "div", 7), r.mc(3, 3), r.mc(4, 4), r.Gc(5, ls, 1, 0, "ng-container", 8), r.Wb()), 2 & t) { const t = r.hc(), e = r.yc(1); r.oc("ngIf", t.labelValue), r.Cb(5), r.oc("ngTemplateOutlet", e) } } const hs = [[["ptrn-field-warning"]], [["ptrn-form-warning"]], "*", [["ptrn-field-error"]], [["ptrn-form-error"]]], ds = ["ptrn-field-warning", "ptrn-form-warning", "*", "ptrn-field-error", "ptrn-form-error"], ps = ["message"], fs = ["msg"], gs = ["*", [["ptrn-summary-message"]]], ms = ["*", "ptrn-summary-message"], bs = [[["ptrn-button"]]], _s = ["ptrn-button"], vs = ["iconContent"], ys = function () { return {} }, ws = ["buttonElement"]; function Cs(t, e) { 1 & t && r.Tb(0) } function Os(t, e) { if (1 & t) { const t = r.Yb(); r.Xb(0, "button", 5, 6), r.ec("click", function (e) { return r.Bc(t), r.hc().onClick(e) }), r.Gc(2, Cs, 1, 0, "ng-container", 7), r.Wb() } if (2 & t) { const t = r.hc(), e = r.yc(4); r.Hb("button ", t.cssClass, ""), r.Jb("button--has-icon", t.hasIcon && "iconOnly" !== t.responsiveBehavior && !t.iconOnly)("button--has-icon@medium-up", t.hasIcon && "iconOnly" === t.responsiveBehavior)("button--primary", t.isPrimary)("button--action", t.showAsAction)("button--loading", t._isBusyValue)("button--disabled", t.isDisabled)("button--icon-only", t.iconOnly)("button--icon-only@small", "iconOnly" === t.responsiveBehavior)("button--text-only@small", "textOnly" === t.responsiveBehavior), r.oc("type", t.isPrimary ? "submit" : "button")("ngClass", t.cssClass)("disabled", t.isDisabled || t._isBusyValue), r.Cb(2), r.oc("ngTemplateOutlet", e) } } function Ss(t, e) { 1 & t && r.Tb(0) } function xs(t, e) { if (1 & t && (r.Xb(0, "a", 8), r.Gc(1, Ss, 1, 0, "ng-container", 7), r.Wb()), 2 & t) { const t = r.hc(), e = r.yc(4); r.Hb("button ", t.cssClass, ""), r.Jb("button--has-icon", t.hasIcon && "iconOnly" !== t.responsiveBehavior && !t.iconOnly)("button--has-icon@medium-up", t.hasIcon && "iconOnly" === t.responsiveBehavior)("button--primary", t.isPrimary)("button--action", t.showAsAction)("button--loading", t._isBusyValue)("button--disabled", t.isDisabled)("button--icon-only", t.iconOnly)("button--icon-only@small", "iconOnly" === t.responsiveBehavior)("button--text-only@small", "textOnly" === t.responsiveBehavior), r.oc("ptrnLink", t.link)("target", t.linkTarget)("ngClass", t.cssClass)("isDisabled", t.isDisabled || t._isBusyValue), r.Cb(1), r.oc("ngTemplateOutlet", e) } } function Es(t, e) { if (1 & t && (r.Xb(0, "div", 12), r.Sb(1, "ptrn-spinner", 13), r.Wb()), 2 & t) { const t = r.hc(2); r.Cb(1), r.oc("size", t.iconSize)("thickness", 2) } } function Ts(t, e) { if (1 & t && r.Tb(0, 15), 2 & t) { r.hc(3); const t = r.yc(6); r.oc("ngTemplateOutlet", t) } } function ks(t, e) { if (1 & t && (r.Vb(0), r.Gc(1, Ts, 1, 1, "ng-container", 14), r.Ub()), 2 & t) { const t = r.hc(2), e = r.yc(8); r.Cb(1), r.oc("ngIf", t.icon)("ngIfElse", e) } } function js(t, e) { if (1 & t && r.Sb(0, "span", 16), 2 & t) { const t = r.hc(2); r.oc("innerHTML", t.busyText, r.Cc) } } function As(t, e) { if (1 & t && (r.Gc(0, Es, 2, 2, "div", 9), r.Gc(1, ks, 2, 2, "ng-container", 10), r.Gc(2, js, 1, 1, "span", 11)), 2 & t) { const t = r.hc(); r.oc("ngIf", t._isBusyValue), r.Cb(1), r.oc("ngIf", !t._isBusyValue), r.Cb(1), r.oc("ngIf", t._isBusyValue) } } function Rs(t, e) { if (1 & t && (r.Xb(0, "div", 20), r.Sb(1, "ptrn-icon", 21), r.Wb()), 2 & t) { const t = r.hc(2); r.Cb(1), r.oc("icon", t.icon)("size", 18) } } function Ls(t, e) { if (1 & t && (r.Xb(0, "div", 22), r.Sb(1, "ptrn-icon", 21), r.Wb()), 2 & t) { const t = r.hc(2); r.Cb(1), r.oc("icon", t.icon)("size", 24) } } function Is(t, e) { 1 & t && r.Tb(0) } function Ps(t, e) { if (1 & t && (r.Gc(0, Rs, 2, 2, "div", 17), r.Gc(1, Ls, 2, 2, "div", 18), r.Xb(2, "div", 19), r.Gc(3, Is, 1, 0, "ng-container", 7), r.Wb()), 2 & t) { const t = r.hc(), e = r.yc(8); r.oc("ngIf", !t.iconOnly), r.Cb(1), r.oc("ngIf", t.iconOnly || "iconOnly" === t.responsiveBehavior), r.Cb(2), r.oc("ngTemplateOutlet", e) } } function Ds(t, e) { 1 & t && r.mc(0) } const Ms = ["popoverContent"]; function Ns(t, e) { 1 & t && r.Tb(0) } function Fs(t, e) { if (1 & t && (r.Xb(0, "h2", 4), r.Gc(1, Ns, 1, 0, "ng-container", 5), r.Wb()), 2 & t) { const t = r.hc(), e = r.yc(7), n = r.yc(9); r.oc("ngClass", t.cssClass), r.Cb(1), r.oc("ngIf", t.link)("ngIfThen", e)("ngIfElse", n) } } function Vs(t, e) { 1 & t && r.Tb(0) } function Bs(t, e) { if (1 & t && (r.Xb(0, "h3", 4), r.Gc(1, Vs, 1, 0, "ng-container", 5), r.Wb()), 2 & t) { const t = r.hc(), e = r.yc(7), n = r.yc(9); r.oc("ngClass", t.cssClass), r.Cb(1), r.oc("ngIf", t.link)("ngIfThen", e)("ngIfElse", n) } } function Us(t, e) { 1 & t && r.Tb(0) } function Hs(t, e) { if (1 & t && (r.Xb(0, "h4", 4), r.Gc(1, Us, 1, 0, "ng-container", 5), r.Wb()), 2 & t) { const t = r.hc(), e = r.yc(7), n = r.yc(9); r.oc("ngClass", t.cssClass), r.Cb(1), r.oc("ngIf", t.link)("ngIfThen", e)("ngIfElse", n) } } function zs(t, e) { 1 & t && r.Tb(0) } function $s(t, e) { if (1 & t && (r.Xb(0, "h5", 4), r.Gc(1, zs, 1, 0, "ng-container", 5), r.Wb()), 2 & t) { const t = r.hc(), e = r.yc(7), n = r.yc(9); r.oc("ngClass", t.cssClass), r.Cb(1), r.oc("ngIf", t.link)("ngIfThen", e)("ngIfElse", n) } } function Ws(t, e) { 1 & t && r.Tb(0) } function qs(t, e) { if (1 & t && (r.Xb(0, "h6", 4), r.Gc(1, Ws, 1, 0, "ng-container", 5), r.Wb()), 2 & t) { const t = r.hc(), e = r.yc(7), n = r.yc(9); r.oc("ngClass", t.cssClass), r.Cb(1), r.oc("ngIf", t.link)("ngIfThen", e)("ngIfElse", n) } } function Gs(t, e) { 1 & t && r.Tb(0) } function Xs(t, e) { if (1 & t && (r.Xb(0, "a", 6), r.Gc(1, Gs, 1, 0, "ng-container", 7), r.Wb()), 2 & t) { const t = r.hc(), e = r.yc(9); r.oc("ptrnLink", t.link), r.Cb(1), r.oc("ngTemplateOutlet", e) } } function Ks(t, e) { } function Zs(t, e) { 1 & t && (r.mc(0), r.Gc(1, Ks, 0, 0, "ng-template", null, 3, r.Hc)) } function Ys(t, e) { 1 & t && (r.Xb(0, "div", 9), r.Sb(1, "ptrn-icon", 10), r.Wb()), 2 & t && (r.Cb(1), r.oc("size", 24)) } function Qs(t, e) { if (1 & t) { const t = r.Yb(); r.Xb(0, "li", 2), r.Xb(1, "div", 3), r.Gc(2, Ys, 2, 1, "div", 4), r.Xb(3, "div", 5), r.Sb(4, "div", 6), r.Sb(5, "div", 7), r.Wb(), r.Xb(6, "button", 8), r.ec("click", function (n) { r.Bc(t); const s = e.$implicit; return r.hc().changeLanguage(n, s) }), r.Wb(), r.Wb(), r.Wb() } if (2 & t) { const t = e.$implicit, n = r.hc(); r.Cb(1), r.Jb("card--selected-vertical", n.isLanguageSelected(t)), r.Cb(1), r.oc("ngIf", n.isLanguageSelected(t)), r.Cb(2), r.oc("innerHTML", t.name, r.Cc), r.Cb(1), r.oc("dir", t.direction)("innerHTML", t.vernacularName, r.Cc)("lang", t.symbol), r.Cb(1), r.oc("innerHTML", t.name, r.Cc) } } function Js(t, e) { } function tr(t, e) { if (1 & t && r.Gc(0, Js, 0, 0, "ng-template", 19), 2 & t) { const t = e.$implicit; r.hc(2); const n = r.yc(1); r.oc("ngTemplateOutlet", n)("ngTemplateOutletContext", r.tc(2, Zn, t)) } } function er(t, e) { } function nr(t, e) { if (1 & t && r.Gc(0, er, 0, 0, "ng-template", 19), 2 & t) { const t = e.$implicit; r.hc(2); const n = r.yc(1); r.oc("ngTemplateOutlet", n)("ngTemplateOutletContext", r.tc(2, Zn, t)) } } function sr(t, e) { if (1 & t && r.Sb(0, "section", 20), 2 & t) { const t = r.hc(2); r.oc("innerHTML", t.noResults, r.Cc) } } function rr(t, e) { if (1 & t) { const t = r.Yb(); r.Xb(0, "div", 11), r.Xb(1, "div", 12), r.Sb(2, "label", 13), r.Xb(3, "input", 14), r.ec("ngModelChange", function (e) { return r.Bc(t), r.hc().filterText = e }), r.ic(4, "stripHtml"), r.Wb(), r.Wb(), r.Xb(5, "ul", 15), r.Gc(6, tr, 1, 4, void 0, 16), r.Wb(), r.Sb(7, "hr", 17), r.Xb(8, "ul", 15), r.Gc(9, nr, 1, 4, void 0, 16), r.Wb(), r.Gc(10, sr, 1, 1, "section", 18), r.Wb() } if (2 & t) { const t = e.ngIf, n = r.hc(); r.Cb(2), r.oc("innerHTML", n.labelLanguage, r.Cc), r.Cb(1), r.Jb("hide", !n.showFilter), r.oc("ngModel", n.filterText)("placeholder", r.jc(4, 10, n.placeholder)), r.Cb(3), r.oc("ngForOf", n.recentLanguages)("ngForTrackBy", n.languageTrackBy), r.Cb(3), r.oc("ngForOf", t)("ngForTrackBy", n.languageTrackBy), r.Cb(1), r.oc("ngIf", n.showFilter && !t.length) } } const ir = ["dialogElement"]; function or(t, e) { 1 & t && r.Tb(0) } function ar(t, e) { 1 & t && r.Tb(0) } function cr(t, e) { if (1 & t && (r.Xb(0, "section", 6), r.Sb(1, "ptrn-modal-header", 7), r.Xb(2, "ptrn-modal-content"), r.Gc(3, ar, 1, 0, "ng-container", 4), r.Wb(), r.mc(4), r.Wb()), 2 & t) { const t = r.hc(2); r.oc("ngClass", t.cssClass || ""), r.Cb(1), r.oc("modalTitle", t.modalTitle)("canDismiss", t.canDismiss)("closeAriaLabel", t.closeAriaLabel), r.Cb(2), r.oc("ngTemplateOutlet", t.modalContentTemplate || null) } } function lr(t, e) { if (1 & t && (r.Xb(0, "div", 2, 3), r.Gc(2, or, 1, 0, "ng-container", 4), r.Gc(3, cr, 5, 5, "section", 5), r.Wb()), 2 & t) { const t = r.hc(); r.Cb(2), r.oc("ngTemplateOutlet", t.modalContainerTemplate || null), r.Cb(1), r.oc("ngIf", null == t.modalContainerTemplate) } } function ur(t, e) { if (1 & t) { const t = r.Yb(); r.Xb(0, "div", 8), r.ec("click", function () { return r.Bc(t), r.hc().close() }), r.Wb() } } const hr = [[["ptrn-modal-footer"]]], dr = ["ptrn-modal-footer"]; function pr(t, e) { if (1 & t && r.Sb(0, "h5", 6), 2 & t) { const t = r.hc(); r.oc("innerHTML", t.modalTitle || "\xa0", r.Cc) } } function fr(t, e) { 1 & t && (r.Xb(0, "h5", 7), r.mc(1), r.Wb()) } function gr(t, e) { 1 & t && r.mc(0) } function mr(t, e) { if (1 & t && (r.Xb(0, "div", 8), r.ic(1, "stripHtml"), r.Sb(2, "ptrn-icon", 9), r.ic(3, "async"), r.Wb()), 2 & t) { const t = r.hc(2); r.Db("aria-hidden", !t.typeLabel)("aria-label", r.jc(1, 5, t.typeLabel)), r.Cb(2), r.qc("cssClass", "notification__icon-element notification__icon-element--", t.type, ""), r.oc("icon", t.icon)("size", r.jc(3, 7, t.iconSize$)) } } function br(t, e) { if (1 & t && (r.Xb(0, "ptrn-heading", 10), r.Sb(1, "span", 11), r.Wb()), 2 & t) { const t = r.hc(2); r.oc("level", t.level), r.Cb(1), r.oc("innerHTML", t.notificationTitle, r.Cc) } } function _r(t, e) { 1 & t && r.Tb(0) } function vr(t, e) { if (1 & t && (r.Xb(0, "div", 12), r.Gc(1, _r, 1, 0, "ng-container", 13), r.Wb()), 2 & t) { r.hc(2); const t = r.yc(1); r.Cb(1), r.oc("ngTemplateOutlet", t) } } function yr(t, e) { if (1 & t) { const t = r.Yb(); r.Xb(0, "button", 14), r.ec("click", function () { return r.Bc(t), r.hc(2).onDismiss() }), r.ic(1, "stripHtml"), r.Sb(2, "ptrn-icon", 15), r.Wb() } if (2 & t) { const t = r.hc(2); r.Db("aria-label", r.jc(1, 2, t.dismissLabel)), r.Cb(2), r.oc("size", 20) } } function wr(t, e) { 1 & t && r.Tb(0) } function Cr(t, e) { if (1 & t && (r.Xb(0, "div", 16), r.Gc(1, wr, 1, 0, "ng-container", 13), r.Wb()), 2 & t) { r.hc(2); const t = r.yc(1); r.Cb(1), r.oc("ngTemplateOutlet", t) } } function Or(t, e) { if (1 & t && (r.Xb(0, "section"), r.Xb(1, "header", 2), r.Gc(2, mr, 4, 9, "div", 3), r.Gc(3, br, 2, 2, "ptrn-heading", 4), r.Gc(4, vr, 2, 1, "div", 5), r.Gc(5, yr, 3, 4, "button", 6), r.Wb(), r.Gc(6, Cr, 2, 1, "div", 7), r.Wb()), 2 & t) { const t = r.hc(); r.Ib("notification notification--", t.type, " margin-bottom-1 ", t.cssClass, ""), r.Db("role", t.role), r.Cb(2), r.oc("ngIf", t.icon), r.Cb(1), r.oc("ngIf", t.hasHeading), r.Cb(1), r.oc("ngIf", !t.hasHeading), r.Cb(1), r.oc("ngIf", t.dismissible), r.Cb(1), r.oc("ngIf", t.hasHeading) } } function Sr(t, e) { 1 & t && r.mc(0, 1) } const xr = [[["", "ptrnPopoverTarget", ""]], [["", "ptrnPopoverContent", ""]]], Er = ["[ptrnPopoverTarget]", "[ptrnPopoverContent]"]; function Tr(t, e) { if (1 & t && r.Sb(0, "h1", 5), 2 & t) { const t = r.hc().ngIf; r.oc("innerHTML", null == t ? null : t.heading, r.Cc) } } function kr(t, e) { if (1 & t) { const t = r.Yb(); r.Xb(0, "a", 12), r.ec("click", function () { r.Bc(t), r.hc(2); const e = r.yc(1); return r.hc(2).onSideNavItemClick(e) }), r.Ic(1), r.Wb() } if (2 & t) { const t = r.hc(2).$implicit; r.oc("ptrnLink", t.link)("queryParams", t.queryParams)("fragment", t.fragment)("target", t.target)("queryParamsHandling", t.queryParamsHandling), r.Cb(1), r.Kc(" ", t.content, " ") } } function jr(t, e) { if (1 & t && (r.Vb(0), r.Gc(1, kr, 2, 6, "a", 11), r.Ub()), 2 & t) { const t = r.hc().$implicit, e = r.yc(6); r.Cb(1), r.oc("ngIf", !t.isExternal)("ngIfElse", e) } } function Ar(t, e) { if (1 & t && (r.Xb(0, "a", 13), r.Ic(1), r.Wb()), 2 & t) { const t = r.hc().$implicit; r.Cb(1), r.Jc(t.content) } } function Rr(t, e) { if (1 & t && (r.Xb(0, "a", 14), r.Ic(1), r.Wb()), 2 & t) { const t = r.hc().$implicit; r.oc("target", t.target)("href", t.link, r.Dc), r.Cb(1), r.Jc(t.content) } } function Lr(t, e) { if (1 & t && (r.Xb(0, "li", 6, 7), r.Gc(2, jr, 2, 2, "ng-container", 8), r.Gc(3, Ar, 2, 1, "ng-template", null, 9, r.Hc), r.Gc(5, Rr, 2, 3, "ng-template", null, 10, r.Hc), r.Wb()), 2 & t) { const t = e.$implicit, n = r.yc(4), s = r.hc(2); r.oc("routerLinkActiveOptions", s.routerLinkActiveOptions(t.link)), r.Cb(2), r.oc("ngIf", null == t ? null : t.link)("ngIfElse", n) } } function Ir(t, e) { if (1 & t && (r.Xb(0, "section", 1), r.Gc(1, Tr, 1, 1, "h1", 2), r.Xb(2, "ul", 3), r.Gc(3, Lr, 7, 3, "li", 4), r.Wb(), r.Wb()), 2 & t) { const t = e.ngIf; r.Cb(1), r.oc("ngIf", null != (null == t ? null : t.heading)), r.Cb(2), r.oc("ngForOf", null == t ? null : t.items) } } function Pr(t, e) { 1 & t && r.mc(0, 1, ["*ngIf", "!modelBased"]) } function Dr(t, e) { 1 & t && r.Sb(0, "ptrn-side-nav-section", 4), 2 & t && r.oc("model", e.$implicit) } function Mr(t, e) { if (1 & t && (r.Vb(0), r.Gc(1, Dr, 1, 1, "ptrn-side-nav-section", 3), r.Ub()), 2 & t) { const t = r.hc(); r.Cb(1), r.oc("ngForOf", t.resolvedSections) } } const Nr = [[["ptrn-side-nav-header"]], [["ptrn-side-nav-section"]]], Fr = ["ptrn-side-nav-header", "ptrn-side-nav-section"]; function Vr(t, e) { 1 & t && (r.Vb(0), r.mc(1), r.Ub()) } function Br(t, e) { 1 & t && (r.Xb(0, "span"), r.gc(), r.Xb(1, "svg", 2), r.Xb(2, "defs"), r.Xb(3, "style"), r.Ic(4, " .trademark { fill: #fff; } .logo { fill: #fff; } "), r.Wb(), r.Wb(), r.Xb(5, "g"), r.Sb(6, "path", 3), r.Sb(7, "path", 4), r.Xb(8, "g"), r.Sb(9, "path", 5), r.Sb(10, "path", 6), r.Wb(), r.Wb(), r.Wb(), r.Wb()) } function Ur(t, e) { 1 & t && (r.Xb(0, "div", 12), r.Sb(1, "ptrn-icon", 13), r.Wb()), 2 & t && (r.Cb(1), r.oc("size", 24)) } function Hr(t, e) { 1 & t && r.mc(0, 3) } function zr(t, e) { 1 & t && r.Tb(0) } const $r = function () { return [] }; function Wr(t, e) { if (1 & t && (r.Xb(0, "a", 14), r.Gc(1, zr, 1, 0, "ng-container", 15), r.Wb()), 2 & t) { const t = r.hc(), e = r.yc(6); r.oc("routerLink", (null == t.branding ? null : t.branding.routerLink) || r.sc(2, $r)), r.Cb(1), r.oc("ngTemplateOutlet", e) } } function qr(t, e) { 1 & t && r.Tb(0) } function Gr(t, e) { if (1 & t && (r.Vb(0), r.Gc(1, qr, 1, 0, "ng-container", 15), r.Ub()), 2 & t) { r.hc(); const t = r.yc(6); r.Cb(1), r.oc("ngTemplateOutlet", t) } } function Xr(t, e) { 1 & t && (r.Xb(0, "div", 16), r.mc(1, 4), r.Wb()) } function Kr(t, e) { if (1 & t && r.Sb(0, "h1", 17), 2 & t) { const t = r.hc(); r.oc("innerHTML", t.isMobile && null != t.branding.shortTitle ? t.branding.shortTitle : t.branding.title, r.Cc) } } const Zr = function (t) { return { "top-nav__item--active": t } }; function Yr(t, e) { if (1 & t && (r.Xb(0, "li", 20), r.Xb(1, "a", 21), r.Ic(2), r.Wb(), r.Wb()), 2 & t) { const t = e.$implicit; r.oc("ngClass", r.tc(3, Zr, t.active)), r.Cb(1), r.oc("routerLink", t.link), r.Cb(1), r.Jc(t.content) } } function Qr(t, e) { if (1 & t && (r.Xb(0, "ul", 18), r.Gc(1, Yr, 3, 5, "li", 19), r.Wb()), 2 & t) { const t = r.hc(); r.Cb(1), r.oc("ngForOf", t.tabs) } } const Jr = [[["ptrn-top-nav-language"]], [["ptrn-top-nav-aside"]], [["ptrn-top-nav-profile"]], [["ptrn-top-nav-branding"]], [["ptrn-top-nav-extended-branding"]]], ti = ["ptrn-top-nav-language", "ptrn-top-nav-aside", "ptrn-top-nav-profile", "ptrn-top-nav-branding", "ptrn-top-nav-extended-branding"]; function ei(t, e) { 1 & t && r.mc(0, 2, ["*ngIf", "!sideNavModel && !sideNavOutletActive"]) } function ni(t, e) { if (1 & t && r.Sb(0, "ptrn-side-nav", 11), 2 & t) { const t = r.hc(); r.oc("model", t.sideNavModel) } } function si(t, e) { if (1 & t && (r.Xb(0, "span", 17), r.Ic(1), r.Wb()), 2 & t) { const t = r.hc(3); r.Cb(1), r.Jc(t.scrollToTopLabel) } } function ri(t, e) { if (1 & t) { const t = r.Yb(); r.Xb(0, "button", 14), r.ec("click", function () { return r.Bc(t), r.hc(2).scrollToTop() }), r.Gc(1, si, 2, 1, "span", 15), r.Sb(2, "ptrn-icon", 16), r.Wb() } if (2 & t) { const t = r.hc(2); r.oc("@fadeInAnimation", void 0), r.Cb(1), r.oc("ngIf", null != t.scrollToTopLabel), r.Cb(1), r.oc("size", 24) } } function ii(t, e) { if (1 & t && (r.Vb(0), r.Sb(1, "router-outlet", 12), r.Sb(2, "router-outlet"), r.Gc(3, ri, 3, 3, "button", 13), r.ic(4, "async"), r.Ub()), 2 & t) { const t = r.hc(); r.Cb(3), r.oc("ngIf", r.jc(4, 1, t.scrollToTopVisible$)) } } function oi(t, e) { if (1 & t && (r.Xb(0, "div", 18, 10), r.Sb(2, "ptrn-spinner", 19), r.Wb()), 2 & t) { const t = r.hc(); r.Jb("spinner--side-nav-offset", t.hasSideNav && !t.sideNavIsCollapsed), r.Cb(2), r.oc("size", 64)("thickness", 3) } } function ai(t, e) { 1 & t && r.Sb(0, "ptrn-legal-notice") } const ci = [[["ptrn-top-nav"]], [["ptrn-footer"]], [["ptrn-side-nav"]]], li = function (t) { return { "has-side-nav": t } }, ui = ["ptrn-top-nav", "ptrn-footer", "ptrn-side-nav"]; function hi(t, e) { if (1 & t && r.Sb(0, "legend", 3), 2 & t) { const t = r.hc(); r.oc("innerHTML", t.label, r.Cc) } } const di = ["radioInputElement"], pi = ["labelContent"]; function fi(t, e) { if (1 & t) { const t = r.Yb(); r.Xb(0, "div", 2), r.ec("mouseover", function () { r.Bc(t); const n = e.$implicit; return r.hc().stopTimer(n) })("mouseout", function () { r.Bc(t); const n = e.$implicit; return r.hc().restartTimer(n) }), r.Sb(1, "ptrn-toast", 3), r.Wb() } if (2 & t) { const t = e.$implicit; r.Hb("toast ", "toast-" + t.type, ""), r.oc("@toastState", "flyRight"), r.Cb(1), r.oc("toast", t) } } function gi(t, e) { if (1 & t) { const t = r.Yb(); r.Xb(0, "li", 1), r.ec("click", function () { return r.Bc(t), r.hc().handleSelectResult() }), r.ic(1, "async"), r.ic(2, "async"), r.Xb(3, "div"), r.mc(4), r.Wb(), r.Wb() } if (2 & t) { const t = r.hc(); r.Jb("active", t.index === r.jc(1, 6, t.typeaheadService.resultIndex$)), r.rc("id", "typeahead-", t.typeaheadService.typeaheadIndex, "-result-item-", t.index, ""), r.oc("ngClass", t.cssClass), r.Db("aria-selected", t.index === r.jc(2, 8, t.typeaheadService.resultIndex$)) } } const mi = ["typeInstructionBox"], bi = ["noResultsBox"], _i = ["resultsBox"], vi = ["typeaheadInput"]; function yi(t, e) { if (1 & t) { const t = r.Yb(); r.Xb(0, "ptrn-icon", 9), r.ec("click", function (e) { return r.Bc(t), r.hc().onDropdownClick(e) }), r.Wb() } 2 & t && r.oc("size", 16) } function wi(t, e) { if (1 & t && r.Sb(0, "div", 10), 2 & t) { const t = r.hc(); r.qc("id", "typeahead-", t._index, "-result-input-empty"), r.oc("innerHTML", t.typeSearchText, r.Cc) } } function Ci(t, e) { if (1 & t && r.Sb(0, "div", 10), 2 & t) { const t = r.hc(); r.qc("id", "typeahead-", t._index, "-result-no-result"), r.oc("innerHTML", t.noResultsText, r.Cc) } } function Oi(t, e) { if (1 & t && r.Sb(0, "span", 13), 2 & t) { const t = r.hc(2); r.oc("innerHTML", t.moreResultsText, r.Cc) } } function Si(t, e) { if (1 & t && (r.Xb(0, "ul", 11), r.mc(1), r.Wb(), r.Gc(2, Oi, 1, 1, "span", 12)), 2 & t) { const t = r.hc(); r.qc("id", "typeahead-", t._index, "-result-box"), r.Cb(2), r.oc("ngIf", t.showMoreResultsText) } } const xi = [[["ptrn-typeahead-result"]]], Ei = ["ptrn-typeahead-result"]; function Ti(t, e) { if (1 & t && (r.Xb(0, "section", 4), r.Xb(1, "ptrn-modal-header", 5), r.Sb(2, "span", 6), r.Wb(), r.Xb(3, "ptrn-modal-content"), r.mc(4), r.Wb(), r.Wb()), 2 & t) { const t = r.hc(); r.Cb(1), r.oc("closeAriaLabel", t.closeAriaLabel)("canDismiss", !0), r.Cb(1), r.oc("innerHTML", t.modalTitleWithFallback, r.Cc) } } const ki = [[["ptrn-language"]]], ji = ["ptrn-language"]; function Ai(t, e) { 1 & t && r.Tb(0) } function Ri(t, e) { if (1 & t && (r.Vb(0), r.Gc(1, Ai, 1, 0, "ng-container", 5), r.Ub()), 2 & t) { const t = r.hc(3); r.Cb(1), r.oc("ngTemplateOutlet", t.siteModal.template)("ngTemplateOutletContext", t.siteModal.templateContext) } } function Li(t, e) { 1 & t && r.Tb(0) } function Ii(t, e) { if (1 & t && (r.Vb(0), r.Gc(1, Li, 1, 0, "ng-container", 7), r.Ub()), 2 & t) { const t = e.$implicit, n = r.hc(4); r.Cb(1), r.oc("ngComponentOutlet", n.siteModal.modalComponent)("ngComponentOutletInjector", t) } } function Pi(t, e) { if (1 & t && (r.Vb(0), r.Gc(1, Ii, 2, 2, "ng-container", 6), r.Ub()), 2 & t) { const t = r.hc(3); r.Cb(1), r.oc("ptrnCustomProviders", t.siteModal.providers)("ptrnCustomProvidersInjector", t.siteModal.injector)("ptrnCustomProvidersViewProviderTokens", t.viewProviderTokens) } } function Di(t, e) { if (1 & t && (r.Gc(0, Ri, 2, 2, "ng-container", 4), r.Gc(1, Pi, 2, 3, "ng-container", 4)), 2 & t) { const t = r.hc(2); r.oc("ngIf", null != t.siteModal.template && null != t.siteModal.templateContext), r.Cb(1), r.oc("ngIf", null != t.siteModal.modalComponent && null != t.siteModal.injector) } } function Mi(t, e) { if (1 & t) { const t = r.Yb(); r.Xb(0, "ptrn-modal", 2), r.ec("visibleChange", function (e) { return r.Bc(t), r.hc().siteModal.changeVisible(e) }), r.ic(1, "async"), r.Gc(2, Di, 2, 2, "ng-template", 3), r.Wb() } if (2 & t) { const t = r.hc(); r.oc("visible", !0 === r.jc(1, 5, t.siteModal.isVisible$))("cssClass", null == t.siteModal.modalOptions ? null : t.siteModal.modalOptions.cssClass)("modalTitle", null == t.siteModal.modalOptions ? null : t.siteModal.modalOptions.modalTitle)("canDismiss", null == t.siteModal.modalOptions ? null : t.siteModal.modalOptions.canDismiss)("closeAriaLabel", (null == t.siteModal.modalOptions ? null : t.siteModal.modalOptions.closeAriaLabel) || "Close") } } function Ni(t, e) { 1 & t && r.Tb(0) } function Fi(t, e) { if (1 & t && r.Gc(0, Ni, 1, 0, "ng-container", 5), 2 & t) { const t = r.hc(3); r.oc("ngTemplateOutlet", t.siteModal.template)("ngTemplateOutletContext", t.siteModal.templateContext) } } function Vi(t, e) { 1 & t && (r.Vb(0), r.Gc(1, Fi, 1, 2, "ng-template", 9), r.Ub()) } function Bi(t, e) { 1 & t && r.Tb(0) } function Ui(t, e) { if (1 & t && (r.Vb(0), r.Gc(1, Bi, 1, 0, "ng-container", 7), r.Ub()), 2 & t) { const t = e.$implicit, n = r.hc(3); r.Cb(1), r.oc("ngComponentOutlet", n.siteModal.modalComponent)("ngComponentOutletInjector", t) } } function Hi(t, e) { if (1 & t && (r.Vb(0), r.Gc(1, Ui, 2, 2, "ng-container", 6), r.Ub()), 2 & t) { const t = r.hc(2); r.Cb(1), r.oc("ptrnCustomProviders", t.siteModal.providers)("ptrnCustomProvidersInjector", t.siteModal.injector)("ptrnCustomProvidersViewProviderTokens", t.viewProviderTokens) } } function zi(t, e) { if (1 & t) { const t = r.Yb(); r.Xb(0, "ptrn-modal", 8), r.ec("visibleChange", function (e) { return r.Bc(t), r.hc().siteModal.changeVisible(e) }), r.ic(1, "async"), r.Gc(2, Vi, 2, 0, "ng-container", 4), r.Gc(3, Hi, 2, 3, "ng-container", 4), r.Wb() } if (2 & t) { const t = r.hc(); r.oc("visible", !0 === r.jc(1, 3, t.siteModal.isVisible$)), r.Cb(2), r.oc("ngIf", null != t.siteModal.template && null != t.siteModal.templateContext), r.Cb(1), r.oc("ngIf", null != t.siteModal.modalComponent && null != t.siteModal.injector) } } const $i = [[["ptrn-action-links-heading"]], [["ptrn-action-link"]]], Wi = ["ptrn-action-links-heading", "ptrn-action-link"]; function qi() { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, t => { const e = 16 * Math.random() | 0; return ("x" === t ? e : 3 & e | 8).toString(16) }) } let Gi = (() => { class t { constructor() { this.id = qi() } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-accordion-group-header"]], hostVars: 1, hostBindings: function (t, e) { 2 & t && r.Db("id", e.id) }, exportAs: ["ptrnAccordionGroupHeader"], ngContentSelectors: Mn, decls: 1, vars: 0, template: function (t, e) { 1 & t && (r.nc(), r.mc(0)) }, encapsulation: 2, changeDetection: 0 }), t })(); function Xi(t, e) { return (n, s) => { const r = Object.getOwnPropertyDescriptor(n, s), i = `__${s}`; Object.defineProperty(n, s, { set(n) { const s = null != (null == r ? void 0 : r.get) ? r.get.call(this) : this[i]; s !== n && (null != r ? r.set.call(instance, n) : this[i] = n, t && n !== s && this[t].call(null != e ? e : this, n, s)) }, get() { return null != (null == r ? void 0 : r.get) ? r.get.call(null != e ? e : this) : this[i] } }) } } const Ki = new r.r("pattern.content-container"); let Zi = (() => { class t { constructor(t) { this.cdr = t, this.expanded = !1, this.iconSize = 48, this.iconClass = "p700", this.imageClass = "", this.imageAlt = "", this.imageSrcSet = "", this.labelLevel = "sibling", this.expandedChange = new r.n, this.headingId = qi(), this.toggleLabelledBy = this.headingId } registerContent(t) { if (null != this.groupContentTemplate) throw new Error("ptrnContentTemplate already registered. Only one ptrnContentTemplate is allowed. Make sure ptrnContentTemplate is used at the top level if possible and there are no additional nested usages of ptrnContentTemplate."); this.groupContentTemplate = t, this.cdr.markForCheck() } unregisterContent(t) { this.groupContentTemplate === t && (this.groupContentTemplate = void 0, this.cdr.markForCheck()) } toggleExpanded(t) { null == t || t.preventDefault(), null == t || t.stopPropagation(), this.expanded = !this.expanded, this.expandedChange.emit(this.expanded), this.cdr.markForCheck() } ngAfterContentInit() { null != this.headerComponent && (this.toggleLabelledBy = this.headerComponent.id) } handleExpandedChange() { this.cdr.markForCheck() } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.h)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-accordion-group"]], contentQueries: function (t, e, n) { if (1 & t && r.Kb(n, Gi, 1), 2 & t) { let t; r.xc(t = r.fc()) && (e.headerComponent = t.first) } }, inputs: { expanded: "expanded", iconSize: "iconSize", iconClass: "iconClass", imageClass: "imageClass", imageAlt: "imageAlt", imageSrcSet: "imageSrcSet", labelLevel: "labelLevel", label: "label", cssClass: "cssClass", icon: "icon", imageUrl: "imageUrl" }, outputs: { expandedChange: "expandedChange" }, exportAs: ["ptrnAccordionGroup"], features: [r.Bb([{ provide: Ki, useExisting: Object(r.V)(() => t) }])], ngContentSelectors: $n, decls: 9, vars: 17, consts: [["cssClass", "accordion-group__header collapsible__action", "ptrnActionArea", "", 3, "level"], [1, "grid", "grid--cross-center", "grid--no-bleed", "grid--nowrap"], ["class", "grid__item grid__item--shrink grid__item--collapse", 4, "ngIf"], [1, "grid__item"], [3, "id", "innerHTML", 4, "ngIf"], ["tabindex", "0", "type", "button", "ptrnActionTarget", "", 1, "accordion__collapse-button", "grid__item", "grid__item--shrink", "grid__item--collapse", "grid", "grid--no-bleed", 3, "click"], ["icon", "chevron-down", 3, "size"], [4, "ngIf"], [1, "grid__item", "grid__item--shrink", "grid__item--collapse"], [3, "src", "alt", "srcset", "ngClass", 4, "ngIf"], [3, "icon", "size", "cssClass", 4, "ngIf"], [3, "src", "alt", "srcset", "ngClass"], [3, "icon", "size", "cssClass"], [3, "id", "innerHTML"], [3, "ngClass"], [4, "ngTemplateOutlet"]], template: function (t, e) { 1 & t && (r.nc(zn), r.Xb(0, "ptrn-heading", 0), r.Xb(1, "div", 1), r.Gc(2, Vn, 3, 2, "div", 2), r.Xb(3, "div", 3), r.Gc(4, Bn, 1, 2, "span", 4), r.mc(5), r.Wb(), r.Xb(6, "button", 5), r.ec("click", function (t) { return e.toggleExpanded(t) }), r.Sb(7, "ptrn-icon", 6), r.Wb(), r.Wb(), r.Wb(), r.Gc(8, Hn, 3, 2, "ng-container", 7)), 2 & t && (r.oc("level", e.labelLevel), r.Cb(2), r.oc("ngIf", !!e.imageUrl || !!e.icon), r.Cb(1), r.Jb("grid__item--collapse", !e.imageUrl && !e.icon)("header--collapsed", !e.expanded)("header--expanded", e.expanded), r.Cb(1), r.oc("ngIf", null != e.label), r.Cb(2), r.Db("aria-expanded", e.expanded)("aria-labelledby", e.toggleLabelledBy), r.Cb(1), r.Jb("accordion__collapse-button--collapsed", !e.expanded)("accordion__collapse-button--expanded", e.expanded), r.oc("size", 16), r.Cb(1), r.oc("ngIf", e.expanded)) }, directives: function () { return [ma, ca, s.o, aa, ea, s.l, s.s] }, pipes: function () { return [zc] }, encapsulation: 2, changeDetection: 0 }), Object(Wt.b)([Xi("handleExpandedChange")], t.prototype, "expanded", void 0), t })(), Yi = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-accordion-heading"]], ngContentSelectors: Mn, decls: 2, vars: 0, consts: [[1, "accordion__heading"]], template: function (t, e) { 1 & t && (r.nc(), r.Xb(0, "h3", 0), r.mc(1, 0, ["#accordionHeading", ""]), r.Wb()) }, encapsulation: 2, changeDetection: 0 }), t })(), Qi = (() => { class t { constructor() { this.showHeaderActions = !0, this.labelCollapseAll = "Collapse All", this.labelExpandAll = "Expand All", this.initSubscriptions = () => { this.changeSubscription && !this.changeSubscription.closed && this.changeSubscription.unsubscribe(); const t = this.accordionGroups.map(t => t.expandedChange.pipe(Object(h.a)(e => [t, e]))); this.changeSubscription = Object(ft.a)(...t).subscribe(([t, e]) => { !this.allowMultiple && e && this.accordionGroups.forEach(n => { n.expanded = n === t && e }) }) } } get shouldShowHeaderActions() { return this.allowMultiple && this.showHeaderActions } get showHeader() { return this.shouldShowHeaderActions || !!this.accordionHeading } ngAfterContentInit() { this.accordionGroups && (this.queryListChangeSubscription = this.accordionGroups.changes.subscribe(() => { this.initSubscriptions(), this.setChildClasses() }), this.initSubscriptions(), this.setChildClasses()) } toggleAll(t) { this.accordionGroups.forEach(e => { e.expanded !== t && e.toggleExpanded() }) } ngOnDestroy() { this.changeSubscription && !this.changeSubscription.closed && this.changeSubscription.unsubscribe(), this.queryListChangeSubscription && !this.queryListChangeSubscription.closed && this.queryListChangeSubscription.unsubscribe() } setChildClasses() { this.cssClass && this.accordionGroups.forEach(t => { t.cssClass = t.cssClass ? `${t.cssClass} ${this.cssClass}` : this.cssClass }) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-accordion"]], contentQueries: function (t, e, n) { if (1 & t && (r.Kb(n, Yi, 1), r.Kb(n, Zi, 0)), 2 & t) { let t; r.xc(t = r.fc()) && (e.accordionHeading = t.first), r.xc(t = r.fc()) && (e.accordionGroups = t) } }, inputs: { showHeaderActions: "showHeaderActions", labelCollapseAll: "labelCollapseAll", labelExpandAll: "labelExpandAll", cssClass: "cssClass", allowMultiple: "allowMultiple" }, exportAs: ["ptrnAccordion"], ngContentSelectors: Xn, decls: 4, vars: 2, consts: [[1, "accordion"], ["class", "grid grid--no-bleed grid--main-between grid--cross-center grid--nowrap@medium-up", 4, "ngIf"], [3, "ngClass"], [1, "grid", "grid--no-bleed", "grid--main-between", "grid--cross-center", "grid--nowrap@medium-up"], [1, "accordion__heading-wrapper"], [4, "ngIf"], ["icon", "circle-chevron-down", 3, "isAction", "action"], [3, "innerHTML"], ["icon", "circle-chevron-up", 3, "isAction", "action"]], template: function (t, e) { 1 & t && (r.nc(Gn), r.Xb(0, "section", 0), r.Gc(1, qn, 4, 1, "header", 1), r.Xb(2, "div", 2), r.mc(3), r.Wb(), r.Wb()), 2 & t && (r.Cb(1), r.oc("ngIf", e.showHeader), r.Cb(1), r.oc("ngClass", e.cssClass)) }, directives: function () { return [s.o, s.l, Jo, na] }, encapsulation: 2, changeDetection: 0 }), t })(); class Ji { constructor(t, e, n) { this.path = t, this.errorKey = e, this.error = n, this.type = "[FormService] FieldErrorAction" } } class to { constructor(t) { this.path = t, this.type = "[FormService] FieldEditAction" } } class eo { constructor(t, e) { this.path = t, this.readOnly = e, this.type = "[FormService] FieldReadOnlyAction" } } class no { constructor() { this.type = "[FormService] FormTouchedAction" } } class so { constructor() { this.type = "[FormService] FormUntouchedAction" } } class ro { constructor() { this.type = "[FormService] FormResetAction" } } class io { constructor() { this.type = "[FormService] FormSubmitAction" } } class oo { constructor() { this.type = "[FormService] FormValidateAction" } } class ao { constructor() { this.type = "[FormService] FormValidateFailureAction" } } class co { constructor() { this.type = "[FormService] FormValidateConfirmAction" } } class lo { constructor() { this.type = "[FormService] FormValidateSubmitAction" } } class uo { constructor() { this.type = "[FormService] FormConfirmSubmitAction" } } class ho { constructor() { this.type = "[FormService] FormReadOnlyAction" } } class po { constructor() { this.type = "[FormService] FormNotReadOnlyAction" } } class fo { constructor() { this.type = "[FormService] FormBusyAction" } } class go { constructor() { this.type = "[FormService] FormNotBusyAction" } } class mo { constructor() { this.type = "[FormService] FormStartProcessingAction" } } class bo { constructor(t) { this.payload = t, this.type = "[FormService] FormEndProcessingAction" } } var _o = function (t) { return t.READONLY = "Readonly", t.EDIT = "Edit", t.VALIDATE = "Validate", t.ERROR = "Error", t.CONFIRM = "Confirm", t }({}); const vo = () => t => t.pipe(t => t.pipe(Object(B.a)((t, e) => t.status === e.status)), Object(h.a)(({ status: t }) => t)), yo = { status: _o.EDIT, nextStatus: null, busy: !1, processing: !1, touched: !1, submitted: !1, fields: {}, arrays: {}, groups: {} }; function wo(t) { Object.keys(t.fields).forEach(e => t.fields[e].editing = !1) } let Co = (() => { class t { constructor() { this.state = new qt.a(yo), this.actions = new i.a, this._childForms = 0, this.actions$ = this.actions.asObservable(), this.state$ = this.state.asObservable(), this.isReadOnly$ = this.state$.pipe(vo(), Object(h.a)(t => t === _o.READONLY || t === _o.CONFIRM), Object(B.a)(), Object(J.a)({ refCount: !0, bufferSize: 1 })), this.isBusy$ = Object(Gt.a)([this.state$.pipe(vo()), this.state$.pipe(Object(h.a)(({ busy: t, processing: e }) => t || e), Object(B.a)())]).pipe(Object(l.a)(1), Object(h.a)(([t, e]) => t === _o.VALIDATE || e), Object(B.a)(), Object(J.a)({ refCount: !0, bufferSize: 1 })) } get stateValue() { return this.state.getValue() } dispatch(t) { const e = function (t, e) { var n, s, r; switch (e.type) { case "[FormService] FieldErrorAction": return Object.assign(Object.assign({}, t), { fields: Object.assign(Object.assign({}, t.fields), { [e.path]: Object.assign(Object.assign({}, t.fields[e.path]), { errors: Object.assign(Object.assign({}, (t.fields[e.path] || { errors: {} }).errors), { [e.errorKey]: e.error }) }) }) }); case "[FormService] FieldWarningAction": return Object.assign(Object.assign({}, t), { fields: Object.assign(Object.assign({}, t.fields), { [e.path]: Object.assign(Object.assign({}, t.fields[e.path]), { warnings: Object.assign(Object.assign({}, (t.fields[e.path] || { warnings: {} }).warnings), { [e.warningKey]: e.warning }) }) }) }); case "[FormService] FieldReadOnlyAction": return Object.assign(Object.assign({}, t), { fields: Object.assign(Object.assign({}, t.fields), { [e.path]: Object.assign(Object.assign({}, t.fields[e.path]), { readOnly: e.readOnly }) }) }); case "[FormService] ArrayErrorAction": return Object.assign(Object.assign({}, t), { arrays: Object.assign(Object.assign({}, t.arrays), { [e.path]: Object.assign(Object.assign({}, t.arrays[e.path]), { errors: Object.assign(Object.assign({}, (t.arrays[e.path] || { errors: {} }).errors), { [e.errorKey]: e.error }) }) }) }); case "[FormService] FormErrorAction": return Object.assign(Object.assign({}, t), { groups: Object.assign(Object.assign({}, t.groups), { [e.path]: Object.assign(Object.assign({}, t.groups[e.path]), { errors: Object.assign(Object.assign({}, (t.groups[e.path] || { errors: {} }).errors), { [e.errorKey]: e.error }) }) }) }); case "[FormService] FormWarningAction": return Object.assign(Object.assign({}, t), { groups: Object.assign(Object.assign({}, t.groups), { [e.path]: Object.assign(Object.assign({}, t.groups[e.path]), { warnings: Object.assign(Object.assign({}, (t.groups[e.path] || { warnings: {} }).warnings), { [e.warningKey]: e.warning }) }) }) }); case "[FormService] FieldEditAction": { const r = Object.assign(Object.assign({}, t), { fields: Object.assign(Object.assign({}, t.fields), { [e.path]: Object.assign(Object.assign({}, t.fields[e.path]), { editing: !0 }) }) }), i = Object.keys(null !== (s = null === (n = r.groups[e.path]) || void 0 === n ? void 0 : n.errors) && void 0 !== s ? s : {}); return Object.keys(r.groups).filter(t => i.some(e => { var n, s; return null != (null === (s = null === (n = r.groups[t]) || void 0 === n ? void 0 : n.errors) || void 0 === s ? void 0 : s[e]) })).forEach(t => { null != r.fields[t] && (r.fields[t].editing = !0) }), r } case "[FormService] FormTouchedAction": return Object.assign(Object.assign({}, t), { touched: !0 }); case "[FormService] FormUntouchedAction": return Object.assign(Object.assign({}, t), { touched: !1 }); case "[FormService] FormBusyAction": return Object.assign(Object.assign({}, t), { busy: !0 }); case "[FormService] FormNotBusyAction": return Object.assign(Object.assign({}, t), { busy: !1 }); case "[FormService] FormStartProcessingAction": return Object.assign(Object.assign({}, t), { processing: !0 }); case "[FormService] FormEndProcessingAction": return Object.assign(Object.assign({}, t), { processing: !1 }) }switch (e.type) { case "[FormService] FormValidateAction": return Object.assign(Object.assign({}, t), t.status === _o.READONLY ? { nextStatus: _o.VALIDATE, submitted: !0 } : { status: _o.VALIDATE, submitted: !0 }); case "[FormService] FormValidateConfirmAction": { let e; return e = Object.assign(Object.assign({}, t), t.status === _o.READONLY ? { nextStatus: _o.CONFIRM } : { status: _o.CONFIRM }), wo(e), e } case "[FormService] FormValidateFailureAction": { let e; return e = Object.assign(Object.assign({}, t), t.status === _o.READONLY ? { nextStatus: _o.ERROR } : { status: _o.ERROR }), wo(e), e } case "[FormService] FormValidateSubmitAction": return Object.assign(Object.assign({}, t), t.status === _o.READONLY ? { nextStatus: _o.EDIT } : { status: _o.EDIT }); case "[FormService] FormConfirmSubmitAction": return Object.assign(Object.assign({}, t), t.status === _o.READONLY ? { nextStatus: _o.CONFIRM } : { status: _o.CONFIRM }); case "[FormService] FormResetAction": return Object.assign(Object.assign({}, t), t.status === _o.READONLY ? { nextStatus: _o.EDIT, submitted: !1 } : { status: _o.EDIT, submitted: !1 }); case "[FormService] FormPreviousAction": return Object.assign(Object.assign({}, t), t.status === _o.READONLY ? { nextStatus: _o.EDIT } : { status: _o.EDIT }); case "[FormService] FormReadOnlyAction": return Object.assign(Object.assign({}, t), { status: _o.READONLY, nextStatus: t.status === _o.READONLY ? t.nextStatus : t.status }); case "[FormService] FormNotReadOnlyAction": return Object.assign(Object.assign({}, t), { status: null !== (r = t.nextStatus) && void 0 !== r ? r : _o.EDIT, nextStatus: null }) }return t }(this.state.value, t); this.state.next(e), this.actions.next(t) } incrementForm() { return ++this._childForms } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = r.Nb({ token: t, factory: t.\u0275fac }), t })(), Oo = (() => { class t { constructor(t, e, n, s) { this.formService = t, this.parentContainer = e, this.controlContainer = n, this.controlName = s, this._unsubscribe$ = new i.a, this.valueChange = new r.n } ngOnInit() { var t, e, n, s; this._path = null == this.parentContainer ? "form" : null != this.parentContainer.path && null != (null === (t = this.controlContainer) || void 0 === t ? void 0 : t.name) ? `${this.parentContainer.path}.${this.controlContainer.name}` : null != (null === (e = this.controlName) || void 0 === e ? void 0 : e.name) ? `${null !== (n = this.parentContainer.path) && void 0 !== n ? n : "form"}.${this.controlName.name}` : `form${this.formService.incrementForm()}`, null != (null === (s = this.controlContainer) || void 0 === s ? void 0 : s.control) && (this.formService.actions$.pipe(Object(u.a)(t => "[FormService] FormSubmitAction" === t.type), Object(Z.a)(this._unsubscribe$)).subscribe(t => { var e; if (null != (null === (e = this.controlContainer) || void 0 === e ? void 0 : e.control)) { if (this.controlContainer.control.markAllAsTouched(), this.controlContainer.control instanceof $t.i) { const t = this.controlContainer.control; for (const e of Object.keys(t.controls)) t.controls[e].updateValueAndValidity({ onlySelf: !0 }) } this.controlContainer.control.updateValueAndValidity({ onlySelf: !0 }) } }), this.controlContainer.control.valueChanges.pipe(Object(Z.a)(this._unsubscribe$)).subscribe(t => this.valueChange.emit(t))) } ngOnDestroy() { this._unsubscribe$.next(), this._unsubscribe$.complete() } get path() { return this._path } get control() { return this.controlContainer.control } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(Co), r.Rb(t, 12), r.Rb($t.c, 10), r.Rb($t.h, 8)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["", "formGroup", ""], ["", "formGroupName", ""], ["", "formArray", ""], ["", "formArrayName", ""]], outputs: { valueChange: "valueChange" }, exportAs: ["ptrnControlContainer"] }), t })(); const So = new r.r("@apps/pattern/core/forms/field.interface"); function xo(t) { return { value: t.value, displayValue: t.value } } const Eo = /chrome/i, To = /jsdom/i, ko = /iPhone/i, jo = /iPod/i, Ao = /iPad/i, Ro = /\bAndroid(?:.+)Mobile\b/i, Lo = /Android/i, Io = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, Po = /Silk/i, Do = /Windows Phone/i, Mo = /\bWindows(?:.+)ARM\b/i, No = /BlackBerry/i, Fo = /BB10/i, Vo = /Opera Mini/i, Bo = /\b(CriOS|Chrome)(?:.+)Mobile/i, Uo = /Mobile(?:.+)Firefox\b/i, Ho = function (t) { let e = (t = t || ("undefined" != typeof navigator ? navigator.userAgent : "")).split("[FBAN"); void 0 !== e[1] && (t = e[0]), e = t.split("Twitter"), void 0 !== e[1] && (t = e[0]); const n = "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1, s = function (t) { return e => e.test(t) }(t), r = { apple: { phone: s(ko) && !s(Do), ipod: s(jo), tablet: !s(ko) && (s(Ao) || n) && !s(Do), device: (s(ko) || s(jo) || s(Ao) || n) && !s(Do) }, amazon: { phone: s(Io), tablet: !s(Io) && s(Po), device: s(Io) || s(Po) }, android: { phone: !s(Do) && s(Io) || !s(Do) && s(Ro), tablet: !s(Do) && !s(Io) && !s(Ro) && (s(Po) || s(Lo)), device: !s(Do) && (s(Io) || s(Po) || s(Ro) || s(Lo)) || s(/\bokhttp\b/i) }, windows: { phone: s(Do), tablet: s(Mo), device: s(Do) || s(Mo) }, other: { blackberry: s(No), blackberry10: s(Fo), opera: s(Vo), firefox: s(Uo), chrome: s(Bo), device: s(No) || s(Fo) || s(Vo) || s(Uo) || s(Bo) }, any: !1, phone: !1, tablet: !1 }; return r.any = r.apple.device || r.android.device || r.windows.device || r.other.device, r.phone = r.apple.phone || r.android.phone || r.windows.phone, r.tablet = r.apple.tablet || r.android.tablet || r.windows.tablet, r }(), zo = ($o = $o || ("undefined" != typeof navigator ? navigator.userAgent : ""), /msie\s|trident/i.test($o)); var $o; const Wo = function (t) { return t = t || ("undefined" != typeof navigator ? navigator.userAgent : ""), Eo.test(t) }(), qo = function (t) { return t = t || ("undefined" != typeof navigator ? navigator.userAgent : ""), To.test(t) }(); let Go = (() => { class t { get isMobile() { return Ho.any } get isMobileApple() { return Ho.apple.device } get isMSIE() { return zo } get isChromium() { return Wo } get isJsDom() { return qo } get supportsSmoothScroll() { return "scrollBehavior" in document.documentElement.style } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(), Xo = (() => { class t { constructor(t) { this.template = t } ngOnInit() { this.templateVar && (this.template = this.templateVar) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.N)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["", "ptrnReadOnlyTemplate", ""]], inputs: { templateVar: ["ptrnReadOnlyTemplate", "templateVar"] } }), t })(), Ko = (() => { class t { constructor(e, n, s) { if (this._el = e, this.renderer = n, this._inputComponents = s, ["INPUT", "TEXTAREA", "SELECT", "PTRN-TYPEAHEAD", "PTRN-TIMEPICKER"].indexOf(this._el.nativeElement.tagName) < 0) throw new Error(`${this._el.nativeElement.tagName.toLowerCase()} does not support ptrnFieldControl`); this._fieldId = "ptrn-field-control-" + t.numCreated++ } set fieldId(t) { this._fieldId = t || this._fieldId } get fieldId() { return this._fieldId } get input() { return this._input } ngAfterViewInit() { const t = this._inputComponents && this._inputComponents[0]; this._input = t ? t.inputElementRef : this._el, null != this._input && this.renderer.setAttribute(this._input.nativeElement, "id", this.fieldId) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.l), r.Rb(r.F), r.Rb($t.o, 10)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["", "ptrnFieldControl", ""]], inputs: { fieldId: ["ptrnFieldControl", "fieldId"] } }), t.numCreated = 0, t })(), Zo = (() => { class t { constructor(t, e, n, s, r) { this.renderer = t, this.cdr = e, this.platform = n, this.formService = s, this.controlContainer = r, this.emptyLabel = "None", this.showLabelInSummary = !0, this.isOptional = !1, this.optionalText = "(Optional)", this.focused = new qt.a(!1), this.focused$ = this.focused.asObservable(), this.initialReadOnly = !1, this.isField = !0, this.hasErrors = !1, this.hasWarnings = !1, this.unsubscribe$ = new i.a } ngOnChanges(t) { t.isReadOnly && null != this.formService && this.formService.dispatch(new eo(this.path, t.isReadOnly.currentValue)) } ngAfterContentInit() { this._setInputClasses(), this.subscribeReadOnly(), this.subscribeErrorsWarnings() } ngAfterViewInit() { var t, e, n, s; const r = this.inputElement; null != (null == r ? void 0 : r.nativeElement) && (this._turnOffAutoCompleteIfNotSet(r), "radio" !== r.nativeElement.getAttribute("type") && this.renderer.setAttribute(r.nativeElement, "id", this.path)), Object(V.a)(null === (e = null === (t = this.internalFormControl) || void 0 === t ? void 0 : t.valueAccessor) || void 0 === e ? void 0 : e.focusChanges) ? (null === (n = this.internalFormControl) || void 0 === n ? void 0 : n.valueAccessor).focusChanges.pipe(Object(Z.a)(this.unsubscribe$), Object(h.a)(t => "focus" === t.type)).subscribe(t => this.focused.next(t)) : null != r && Object(ft.a)(N(r.nativeElement, "focus"), N(r.nativeElement, "blur")).pipe(Object(Z.a)(this.unsubscribe$), Object(h.a)(t => "focus" === t.type)).subscribe(t => this.focused.next(t)), (null === (s = this.internalFormControl) || void 0 === s ? void 0 : s.control) instanceof $t.g && this.internalFormControl.control.valueChanges.pipe(Object(B.a)(), Object(Q.a)(() => this.formService.state$.pipe(Object(d.a)(1))), Object(Z.a)(this.unsubscribe$), Object(h.a)(t => t.fields[this.path] && t.fields[this.path].editing), Object(u.a)(t => !t)).subscribe(() => this.formService.dispatch(new to(this.path))), this.initialReadOnly && this.cdr.detectChanges() } ngOnDestroy() { this.unsubscribe$.next(), this.unsubscribe$.complete() } get formControl() { var t, e; return null !== (e = null === (t = this.internalFormControl) || void 0 === t ? void 0 : t.control) && void 0 !== e ? e : null } get inputElement() { var t; return null != (null === (t = this.internalFormControl) || void 0 === t ? void 0 : t.valueAccessor) ? this.internalFormControl.valueAccessor._elementRef : null != this.control ? this.control.input : null } get label() { var t, e; return null !== (e = null !== (t = this.labelValue) && void 0 !== t ? t : this.inlineLabel) && void 0 !== e ? e : "" } get name() { var t, e, n, s; return null !== (s = null !== (e = null === (t = this.internalFormControl) || void 0 === t ? void 0 : t.name) && void 0 !== e ? e : null === (n = this.control) || void 0 === n ? void 0 : n.fieldId) && void 0 !== s ? s : "unknown" } get path() { return null != this.controlContainer ? `${this.controlContainer.path}.${this.name}` : this.name.toString() } get hasValue() { let t = this.value; return "function" == typeof (null == t ? void 0 : t.trim) && (t = t.trim()), null != t && "" !== t } get value() { const t = this.getFieldValueAccessor(); return null != t ? t.value : null != this.formControl ? this.formControl.value : null } get display() { var t; const e = this.getFieldValueAccessor(); return null !== (t = null == e ? void 0 : e.displayValue) && void 0 !== t ? t : this.value } get readOnlyLabel() { var t; let e = null !== (t = this.labelValue) && void 0 !== t ? t : this.inlineLabel; return this.isOptional && (e += ` <span class="field-optional-text">${this.optionalText}</span>`), e } getFieldValueAccessor() { var t; if (null != (null === (t = this.internalFormControl) || void 0 === t ? void 0 : t.valueAccessor)) { const t = this.internalFormControl.valueAccessor; if (void 0 !== t.value && void 0 !== t.displayValue) return t } if (null != this.inputElement) { const t = function (t) { if (null != t.nativeElement) switch (t.nativeElement.tagName) { case "INPUT": switch (t.nativeElement.type) { case "text": case "search": case "number": return xo(t.nativeElement); case "checkbox": return function (t) { return { value: t.indeterminate ? null : t.checked, displayValue: t.indeterminate ? "Unknown" : t.checked ? "Yes" : "No" } }(t.nativeElement) }break; case "TEXTAREA": return xo(t.nativeElement); case "SELECT": switch (t.nativeElement.type) { case "select-one": return function (t) { const e = t.selectedIndex >= 0 ? t.value : null, n = t.options[t.selectedIndex]; return { value: e, displayValue: null != n && null != n.textContent ? n.textContent.trim() : e || "" } }(t.nativeElement) } }return console.warn(`Element with type "${t.nativeElement.type}" does not have FieldValueAccessor`, t.nativeElement), { value: null, displayValue: "" } }(this.inputElement); if (null != t) return t } return { value: this.value, displayValue: this.display } } _turnOffAutoCompleteIfNotSet(t) { const e = t.nativeElement instanceof HTMLInputElement || t.nativeElement instanceof HTMLTextAreaElement ? t.nativeElement : null; null == e || e.autocomplete || null == e.attributes.getNamedItem("autocomplete") && (e.autocomplete = this.platform.isChromium ? "none" : "off") } subscribeReadOnly() { this.formService && (this.isReadOnly$ = Object(Gt.a)([this.formService.isReadOnly$, this.formService.state$]).pipe(Object(Z.a)(this.unsubscribe$), Object(h.a)(([t, e]) => { var n; return t || !!(null === (n = e.fields[this.path]) || void 0 === n ? void 0 : n.readOnly) }), Object(B.a)()), this.formService.dispatch(new eo(this.path, this.isReadOnly)), this.isReadOnly$.pipe(Object(d.a)(1)).subscribe(t => this.initialReadOnly = t)) } subscribeErrorsWarnings() { const t = {}; this.formService && Object(Gt.a)([this.formService.state$.pipe(Object(h.a)(e => e.fields[this.path] || t), Object(B.a)()), this.formService.state$.pipe(Object(h.a)(e => e.groups[this.path] || t), Object(B.a)()), this.formService.state$.pipe(Object(h.a)(e => e.arrays[this.path] || t), Object(B.a)()), this.formService.state$.pipe(Object(h.a)(t => t.submitted), Object(B.a)()), this.formService.actions$.pipe(Object(Y.a)(new so), Object(u.a)(t => "[FormService] FormValidateSubmitAction" === t.type || "[FormService] FormValidateConfirmAction" === t.type || "[FormService] FormValidateFailureAction" === t.type || "[FormService] FormTouchedAction" === t.type || "[FormService] FormUntouchedAction" === t.type))]).pipe(Object(Z.a)(this.unsubscribe$)).subscribe(([t, e, n, s, r]) => { if (null == this.formControl || !this.formControl.touched && !s) this.hasErrors = this.hasWarnings = !1; else { const r = t.errors || {}, i = s && !0 !== t.editing; if (this.hasErrors = Object.keys(r).length > 0 && Object.keys(r).some(t => { var e; return null != r[t] && ((null === (e = r[t]) || void 0 === e ? void 0 : e.showImmediate) || i) }), !this.hasErrors) { const n = e.errors || {}, r = s && !0 !== t.editing; Object.keys(n).length > 0 && (this.hasErrors = Object.keys(n).some(t => { var e; return null != n[t] && ((null === (e = n[t]) || void 0 === e ? void 0 : e.showImmediate) || r) })) } if (!this.hasErrors) { const e = n.errors || {}, r = s && !0 !== t.editing; Object.keys(e).length > 0 && (this.hasErrors = Object.keys(e).some(t => { var n; return null != e[t] && ((null === (n = e[t]) || void 0 === n ? void 0 : n.showImmediate) || r) })) } const o = Object.assign(Object.assign({}, t.warnings), e.warnings) || {}; this.hasWarnings = !this.hasErrors && Object.keys(o).length > 0 && i && Object.keys(o).some(t => null != o[t]) } this.cdr.markForCheck() }) } _setInputClasses() { const t = ["email", "password", "search", "text", "url", "number", "tel"]; if (!this.inputElement) return; const e = this.inputElement.nativeElement; switch (e.tagName) { case "INPUT": const n = e.attributes.getNamedItem("type"); null == n || t.indexOf(n.value) >= 0 ? this.renderer.addClass(e, "field__input") : "checkbox" === n.value && this.renderer.addClass(e, "field__checkbox"); break; case "SELECT": this.renderer.addClass(e, "field__select"); break; case "TEXTAREA": this.renderer.addClass(e, "field__textarea") } } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.F), r.Rb(r.h), r.Rb(Go), r.Rb(Co, 8), r.Rb(Oo, 8)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-field"]], contentQueries: function (t, e, n) { if (1 & t && (r.Kb(n, $t.h, 3), r.Kb(n, Ko, 3), r.Kb(n, Xo, 1)), 2 & t) { let t; r.xc(t = r.fc()) && (e.internalFormControl = t.first), r.xc(t = r.fc()) && (e.control = t.first), r.xc(t = r.fc()) && (e.readOnlyTemplate = t.first) } }, hostVars: 6, hostBindings: function (t, e) { 2 & t && r.Jb("field", e.isField)("field--error", e.hasErrors)("field--warning", e.hasWarnings) }, inputs: { emptyLabel: "emptyLabel", showLabelInSummary: "showLabelInSummary", isOptional: "isOptional", optionalText: "optionalText", labelValue: ["label", "labelValue"], isReadOnly: "isReadOnly" }, features: [r.Bb([{ provide: So, useExisting: Object(r.V)(() => t) }]), r.Ab], ngContentSelectors: ds, decls: 8, vars: 4, consts: [["warnings", ""], [4, "ngIf", "ngIfElse"], ["defaultReadOnlyTmpl", ""], ["formControlTmpl", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf", "ngIfElse"], ["class", "field-messages", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "field-messages"], [4, "ngTemplateOutlet"], [1, "data"], ["class", "data__label", 3, "innerHTML", 4, "ngIf"], [1, "data__value", 3, "ngClass", "innerHTML"], [1, "data__label", 3, "innerHTML"], ["class", "field__label", 3, "field__label--hasFocus", "for", 4, "ngIf"], [1, "field__label", 3, "for"], [3, "innerHTML"], [4, "ngIf"], ["class", "field-optional-text", 3, "innerHTML", 4, "ngIf"], [1, "field-optional-text", 3, "innerHTML"]], template: function (t, e) { if (1 & t && (r.nc(hs), r.Gc(0, Kn, 2, 0, "ng-template", null, 0, r.Hc), r.Gc(2, ts, 3, 3, "ng-container", 1), r.ic(3, "async"), r.Gc(4, is, 4, 6, "ng-template", null, 2, r.Hc), r.Gc(6, us, 6, 2, "ng-template", null, 3, r.Hc)), 2 & t) { const t = r.yc(7); r.Cb(2), r.oc("ngIf", r.jc(3, 2, e.isReadOnly$))("ngIfElse", t) } }, directives: [s.o, s.s, s.l], pipes: [s.b], encapsulation: 2, changeDetection: 0 }), t })(), Yo = (() => { class t { get messageText() { if (null != this.messageElement && null != this.messageElement.nativeElement) return this.messageElement.nativeElement.innerHTML.trim() } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-summary-message"]], viewQuery: function (t, e) { if (1 & t && r.Nc(ps, 1), 2 & t) { let t; r.xc(t = r.fc()) && (e.messageElement = t.first) } }, ngContentSelectors: Mn, decls: 3, vars: 0, consts: [["message", ""]], template: function (t, e) { 1 & t && (r.nc(), r.Xb(0, "span", null, 0), r.mc(2), r.Wb()) }, encapsulation: 2, changeDetection: 0 }), t })(), Qo = (() => { class t { constructor(t, e, n) { this.parentField = t, this.container = e, this.formService = n, this.omitSummaryLabel = !1, this.unsubscribe$ = new i.a } subscribeToControlStatus(t, e, n) { if (this._actionFactory = n, null != t && null != this.formService) { const n = t; t.statusChanges.pipe(Object(Y.a)(t.status)).pipe(Object(Z.a)(this.unsubscribe$)).subscribe(t => { const s = null != n[e] && n[e].hasOwnProperty(this.name) ? "errors" === e ? this.getError() : this.getWarning() : null; this.formService.dispatch(this._actionFactory(s)) }) } } initializeDisplayStyleObservable(t, e) { null != this.formService && (this.display$ = this.formService.state$.pipe(Object(Zt.a)(0), Object(h.a)(n => { var s, r, i; const o = n[t][this.path]; if (null == o) return !1; if ("errors" === e) { const t = this.getError(); if (null == t.message && null == t.summaryMessage) return !1 } else { const t = this.getWarning(); if (null == t.message && null == t.summaryMessage) return !1 } let a = !1; "errors" === e && null != o.errors ? a = (null === (s = function (t = {}) { if (null != t.required) return t.required; let e = null; for (const n of Object.keys(t)) { const s = t[n]; if (null != s && (s.message || s.summaryMessage) && (null == e || (null == s ? void 0 : s.showImmediate)) && (e = n, null == s ? void 0 : s.showImmediate)) break } return null != e ? t[e] : null }(o.errors)) || void 0 === s ? void 0 : s.error) === this.name : "errors" !== e && null != o.warnings && (a = (null === (r = function (t = {}) { for (const e of Object.keys(t)) { const n = t[e]; if (null != n && (n.message || n.summaryMessage)) return t[e] } return null }(o.warnings)) || void 0 === r ? void 0 : r.warning) === this.name && (this.shouldShowWarnings(n) || !0 === this.immediate)); const c = null === (i = n.fields[this.path]) || void 0 === i ? void 0 : i.editing; return a && (this.immediate || this.isTouched && !0 !== c && n.submitted) }), Object(B.a)())) } ngOnDestroy() { this.formService && this._actionFactory && this.formService.dispatch(this._actionFactory(null)), this.unsubscribe$.next(), this.unsubscribe$.complete() } get path() { var t, e, n; const s = null !== (n = null !== (t = this.fieldName) && void 0 !== t ? t : null === (e = this.parentField) || void 0 === e ? void 0 : e.name) && void 0 !== n ? n : "unknown"; return `${this.container.path}.${s}` } get parentFormControl() { var t, e, n, s; return this.fieldName ? null !== (e = null === (t = this.parentForm) || void 0 === t ? void 0 : t.get(this.fieldName)) && void 0 !== e ? e : null : null !== (s = null === (n = this.parentField) || void 0 === n ? void 0 : n.formControl) && void 0 !== s ? s : null } get parentForm() { var t; return null === (t = this.container) || void 0 === t ? void 0 : t.control } get isTouched() { return null == this.parentFormControl || this.parentFormControl.touched } get isDirty() { return null != this.parentFormControl && this.parentFormControl.dirty } getError() { var t, e, n, s, r; return { error: this.name, field: null !== (e = null === (t = this.focusField) || void 0 === t ? void 0 : t.inputElement) && void 0 !== e ? e : this.parentField ? this.parentField : null, element: null !== (n = this.getValidatedElement()) && void 0 !== n ? n : null === (s = this.parentField) || void 0 === s ? void 0 : s.inputElement, message: this.getValidationMessage(), summaryLabel: this.label, summaryMessage: null === (r = this.summaryMessageComponent) || void 0 === r ? void 0 : r.messageText, showImmediate: this.immediate, omitSummaryLabel: this.omitSummaryLabel } } getWarning() { var t, e, n, s, r; return { warning: this.name, field: null !== (e = null === (t = this.focusField) || void 0 === t ? void 0 : t.inputElement) && void 0 !== e ? e : this.parentField, element: null !== (n = this.getValidatedElement()) && void 0 !== n ? n : null === (s = this.parentField) || void 0 === s ? void 0 : s.inputElement, message: this.getValidationMessage(), summaryLabel: this.getSummaryLabel(), summaryMessage: null === (r = this.summaryMessageComponent) || void 0 === r ? void 0 : r.messageText, omitSummaryLabel: this.omitSummaryLabel } } getValidationMessage() { return console.warn("Validation setup: getValidationMessage has not been overridden"), "" } getValidatedElement() { return console.warn("Validation setup: getValidatedElement has not been overridden"), null } getSummaryLabel() { return this.label } onMessageChanged(t) { const e = "errors" === t ? this.getError() : this.getWarning(); this.formService.dispatch(this._actionFactory(e)) } shouldShowWarnings(t) { return t.status === _o.CONFIRM || t.status === _o.EDIT && t.submitted } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(Zo), r.Rb(Oo), r.Rb(Co)) }, t.\u0275dir = r.Mb({ type: t, contentQueries: function (t, e, n) { if (1 & t && r.Kb(n, Yo, 1), 2 & t) { let t; r.xc(t = r.fc()) && (e.summaryMessageComponent = t.first) } }, inputs: { name: "name", immediate: "immediate", label: "label", fieldName: "fieldName", focusField: "focusField" } }), t })(), Jo = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-action-buttons"]], exportAs: ["ptrnActionButtons"], ngContentSelectors: _s, decls: 2, vars: 0, consts: [[1, "buttons", "buttons--actions"]], template: function (t, e) { 1 & t && (r.nc(bs), r.Xb(0, "div", 0), r.mc(1), r.Wb()) }, encapsulation: 2, changeDetection: 0 }), t })(), ta = (() => { class t { constructor() { this.appIcons = { error: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><path d="M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M8,14c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6 S11.3,14,8,14z"></path><rect x="7" y="4" width="2" height="5"></rect><circle cx="8" cy="11" r="1"></circle></g></svg>', 24: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M12,0C5.383,0,0,5.383,0,12s5.383,12,12,12s12-5.383,12-12S18.617,0,12,0z M13.645,5L13,14h-2l-0.608-9 H13.645z M12,20c-1.105,0-2-0.895-2-2c0-1.105,0.895-2,2-2c1.105,0,2,0.895,2,2C14,19.105,13.105,20,12,20z"/></g></svg>' }, "error-outline": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><path d="M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M8,14c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6 S11.3,14,8,14z"></path><rect x="7" y="4" width="2" height="5"></rect><circle cx="8" cy="11" r="1"></circle></g></svg>', 24: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><circle cx="12" cy="12" r="11" fill="none" stroke-miterlimit="10"/> <line x1="11.959" y1="7" x2="11.959" y2="13" fill="none" stroke-miterlimit="10"/> <circle data-stroke="none" cx="11.959" cy="17" r="1" stroke="none"/></g></svg>' }, warning: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><rect x="7" y="6" width="2" height="4"></rect><circle cx="8" cy="12" r="1"></circle><path d="M15,16H1c-0.347,0-0.668-0.18-0.851-0.475s-0.199-0.663-0.044-0.973l7-14c0.34-0.678,1.449-0.678,1.789,0 l7,14c0.155,0.31,0.139,0.678-0.044,0.973S15.347,16,15,16z M2.618,14h10.764L8,3.236L2.618,14z"></path></g></svg>', 24: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M23.865,20.5l-11-19a1.04,1.04,0,0,0-1.73,0l-11,19A1,1,0,0,0,1,22H23a1,1,0,0,0,.865-1.5ZM13.206,8l-.473,6.6H11.267L10.821,8ZM12,19a1.467,1.467,0,1,1,1.467-1.467A1.467,1.467,0,0,1,12,19Z" /></g></svg>' }, "warning-outline": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><rect x="7" y="6" width="2" height="4"></rect><circle cx="8" cy="12" r="1"></circle><path d="M15,16H1c-0.347,0-0.668-0.18-0.851-0.475s-0.199-0.663-0.044-0.973l7-14c0.34-0.678,1.449-0.678,1.789,0 l7,14c0.155,0.31,0.139,0.678-0.044,0.973S15.347,16,15,16z M2.618,14h10.764L8,3.236L2.618,14z"></path></g></svg>', 24: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><polygon fill="none" stroke-miterlimit="10" points="2,22 12,3 22,22 "/> <line fill="none" stroke-miterlimit="10" x1="12" y1="11" x2="12" y2="15"/> <circle data-stroke="none" cx="12" cy="18" r="1" stroke-linejoin="miter" stroke-linecap="square" stroke="none"/></g></svg>' }, "priority-high": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><polygon points="13,16 11,16 10,1 14,1 "/> <circle cx="12" cy="21" r="2"/></g></svg>' }, check: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M8.5,20a1.5,1.5,0,0,1-1.061-.439L.379,12.5,2.5,10.379l6,6,13-13L23.621,5.5,9.561,19.561A1.5,1.5,0,0,1,8.5,20Z" /></g></svg>' }, "check-circle": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><path d="M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M7,11.4L3.6,8L5,6.6l2,2l4-4L12.4,6L7,11.4z"></path></g></svg>', 24: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M12,0A12,12,0,1,0,24,12,12.035,12.035,0,0,0,12,0ZM10,17.414,4.586,12,6,10.586l4,4,8-8L19.414,8Z" /></g></svg>' }, "check-circle-outline": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><path d="M8,0C3.589,0,0,3.589,0,8s3.589,8,8,8s8-3.589,8-8S12.411,0,8,0z M8,14c-3.309,0-6-2.691-6-6s2.691-6,6-6 s6,2.691,6,6S11.309,14,8,14z"></path> <polygon points="7,11.414 3.586,8 5,6.586 7,8.586 11,4.586 12.414,6 "></polygon></g></svg>', 24: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><polyline fill="none" stroke-miterlimit="10" points=" 6,12 10,16 18,8 "/> <circle fill="none" stroke-miterlimit="10" cx="12" cy="12" r="11"/></g></svg>' }, add: { 0: '<svg  xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M22,11h-9V2c0-0.6-0.4-1-1-1s-1,0.4-1,1v9H2c-0.6,0-1,0.4-1,1s0.4,1,1,1h9v9c0,0.6,0.4,1,1,1s1-0.4,1-1v-9h9 c0.6,0,1-0.4,1-1S22.6,11,22,11z"></path></g></svg>' }, "add-circle": { 0: '<svg  xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><path d="M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M12,9H9v3H7V9H4V7h3V4h2v3h3V9z"></path></g></svg>', 24: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M12,0A12,12,0,1,0,24,12,12.035,12.035,0,0,0,12,0Zm6,13H13v5H11V13H6V11h5V6h2v5h5Z" /></g></svg>' }, "add-circle-outline": { 0: '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><g><polygon points="9,4 7,4 7,7 4,7 4,9 7,9 7,12 9,12 9,9 12,9 12,7 9,7 "></polygon> <path d="M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M8,14c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6 S11.3,14,8,14z"></path></g></svg>', 24: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><line fill="none" stroke-miterlimit="10" x1="12" y1="7" x2="12" y2="17"/> <line fill="none" stroke-miterlimit="10" x1="17" y1="12" x2="7" y2="12"/> <circle fill="none" stroke-miterlimit="10" cx="12" cy="12" r="11"/></g></svg>' }, view: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><g transform="translate(0, 0)"><path d="M12.7,11.3c0.9-1.2,1.4-2.6,1.4-4.2C14.1,3.2,11,0,7.1,0S0,3.2,0,7.1c0,3.9,3.2,7.1,7.1,7.1 c1.6,0,3.1-0.5,4.2-1.4l3,3c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L12.7,11.3z M7.1,12.1 C4.3,12.1,2,9.9,2,7.1S4.3,2,7.1,2s5.1,2.3,5.1,5.1S9.9,12.1,7.1,12.1z"></path><polygon points="8,4 6,4 6,6 4,6 4,8 6,8 6,10 8,10 8,8 10,8 10,6 8,6 "></polygon></g></svg>', 24: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g transform="translate(0, 0)"><polygon points="14 9 11 9 11 6 9 6 9 9 6 9 6 11 9 11 9 14 11 14 11 11 14 11 14 9"></polygon><path d="M23.061,20.939l-5.733-5.733a9.028,9.028,0,1,0-2.122,2.122l5.733,5.733ZM3,10a7,7,0,1,1,7,7A7.008,7.008,0,0,1,3,10Z"></path></g></svg>' }, edit: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><g><path d="M8.1,3.5l-7.8,7.8C0.1,11.5,0,11.7,0,12v3c0,0.6,0.4,1,1,1h3c0.3,0,0.5-0.1,0.7-0.3l7.8-7.8L8.1,3.5z"/><path d="M15.7,3.3l-3-3c-0.4-0.4-1-0.4-1.4,0L9.5,2.1l4.4,4.4l1.8-1.8C16.1,4.3,16.1,3.7,15.7,3.3z"/></g></svg>', 24: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M1.915,17.329L1.02,21.804c-0.066,0.328,0.037,0.667,0.273,0.903C1.482,22.896,1.737,23,2,23 c0.065,0,0.131-0.006,0.196-0.02l4.475-0.895L1.915,17.329z"/> <polygon points="13.586,5 11,7.586 3,15.586 8.414,21 19,10.414 "/> <path d="M22.707,5.293l-4-4c-0.391-0.391-1.023-0.391-1.414,0L15,3.586L20.414,9l2.293-2.293 C23.098,6.316,23.098,5.684,22.707,5.293z"/></g></svg>' }, "edit-outline": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><path d="M11.7,0.3c-0.4-0.4-1-0.4-1.4,0l-10,10C0.1,10.5,0,10.7,0,11v4c0,0.6,0.4,1,1,1h4c0.3,0,0.5-0.1,0.7-0.3 l10-10c0.4-0.4,0.4-1,0-1.4L11.7,0.3z M4.6,14H2v-2.6l6-6L10.6,8L4.6,14z M12,6.6L9.4,4L11,2.4L13.6,5L12,6.6z"></path></g></svg>', 24: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><line data-cap="butt" x1="14.328" y1="4.672" x2="19.328" y2="9.672" fill="none" stroke-miterlimit="10" stroke-linecap="butt"/> <path d="M8,21,2,22l1-6L16.414,2.586a2,2,0,0,1,2.828,0l2.172,2.172a2,2,0,0,1,0,2.828Z" fill="none" stroke-miterlimit="10"/></g></svg>' }, "edit-box": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M19,23H2a1,1,0,0,1-1-1V5A1,1,0,0,1,2,4h8V6H3V21H18V14h2v8A1,1,0,0,1,19,23Z" /> <rect x="18.086" y="1.379" width="4.243" height="4.828" transform="translate(3.236 15.399) rotate(-45)"/> <polygon points="15.586 5 8.126 12.46 6.419 17.581 11.54 15.874 19 8.414 15.586 5"/></g></svg>' }, copy: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><g transform="translate(0, 0)"><path d="M10,4H2C1.4,4,1,4.4,1,5v10c0,0.6,0.4,1,1,1h8c0.6,0,1-0.4,1-1V5C11,4.4,10.6,4,10,4z"></path><path d="M14,0H4v2h9v11h2V1C15,0.4,14.6,0,14,0z"></path></g></svg>' }, remove: { 0: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2" ><line fill="none" stroke-miterlimit="10" x1="19" y1="5" x2="5" y2="19"/> <line fill="none" stroke-miterlimit="10" x1="19" y1="19" x2="5" y2="5"/></g></svg>' }, "remove-circle": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><path d="M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M11.5,10.1l-1.4,1.4L8,9.4l-2.1,2.1l-1.4-1.4L6.6,8 L4.5,5.9l1.4-1.4L8,6.6l2.1-2.1l1.4,1.4L9.4,8L11.5,10.1z"></path></g></svg>', 24: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M12,0A12,12,0,1,0,24,12,12.035,12.035,0,0,0,12,0Zm4.95,15.536L15.536,16.95,12,13.414,8.464,16.95,7.05,15.536,10.586,12,7.05,8.464,8.464,7.05,12,10.586,15.536,7.05,16.95,8.464,13.414,12Z" /></g></svg>' }, "remove-circle-outline": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><polygon points="10.1,4.5 8,6.6 5.9,4.5 4.5,5.9 6.6,8 4.5,10.1 5.9,11.5 8,9.4 10.1,11.5 11.5,10.1 9.4,8 11.5,5.9 "></polygon> <path d="M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M8,14c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6 S11.3,14,8,14z"></path></g></svg>', 24: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2" ><line fill="none" stroke-miterlimit="10" x1="16" y1="8" x2="8" y2="16"/> <line fill="none" stroke-miterlimit="10" x1="16" y1="16" x2="8" y2="8"/> <circle fill="none" stroke-miterlimit="10" cx="12" cy="12" r="11"/></g></svg>' }, close: { 0: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2" ><line fill="none" stroke-miterlimit="10" x1="19" y1="5" x2="5" y2="19"/> <line fill="none" stroke-miterlimit="10" x1="19" y1="19" x2="5" y2="5"/></g></svg>' }, menu: { 0: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><line fill="none" stroke-miterlimit="10" x1="1" y1="12" x2="23" y2="12"/> <line fill="none" stroke-miterlimit="10" x1="1" y1="5" x2="23" y2="5"/> <line fill="none" stroke-miterlimit="10" x1="1" y1="19" x2="23" y2="19"/></g></svg>' }, "menu-dots": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><circle cx="12" cy="12" r="2"/> <circle cx="3" cy="12" r="2"/> <circle cx="21" cy="12" r="2"/></g></svg>' }, more: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g></svg>' }, "more-horizontal": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g></svg>' }, person: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M12,13c3.309,0,6-2.691,6-6V6c0-3.309-2.691-6-6-6S6,2.691,6,6v1C6,10.309,8.691,13,12,13z"/> <path d="M19.322,15.981c-4.704-1.303-9.939-1.303-14.644,0C2.513,16.581,1,18.564,1,20.805V24h22 v-3.195C23,18.564,21.487,16.581,19.322,15.981z"/></g></svg>' }, "person-outline": { 0: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><path fill="none" stroke-miterlimit="10" d="M12,12L12,12 c-2.761,0-5-2.239-5-5V6c0-2.761,2.239-5,5-5h0c2.761,0,5,2.239,5,5v1C17,9.761,14.761,12,12,12z"/> <path fill="none" stroke-miterlimit="10" d="M22,20.908 c0-1.8-1.197-3.383-2.934-3.856C17.172,16.535,14.586,16,12,16s-5.172,0.535-7.066,1.052C3.197,17.525,2,19.108,2,20.908V23h20 V20.908z"/></g></svg>' }, "person-circle": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M12,0C5.383,0,0,5.383,0,12s5.383,12,12,12s12-5.383,12-12S18.617,0,12,0z M8,10c0-2.209,1.844-4,4-4 s4,1.791,4,4v1c0,2.209-1.844,4-4,4s-4-1.791-4-4V10z M12,22c-2.433,0-4.665-0.876-6.401-2.326C6.438,18.091,8.083,17,10,17h4 c1.917,0,3.562,1.091,4.401,2.674C16.665,21.124,14.433,22,12,22z"/></g></svg>' }, "person-add": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><g><circle cx="8" cy="4" r="4"></circle><polygon points="16,12 14,12 14,10 12,10 12,12 10,12 10,14 12,14 12,16 14,16 14,14 16,14 "></polygon><path d="M8,13c0-1.117,0.379-2.137,0.998-2.97C8.673,10.013,8.344,10,8,10c-3.192,0-5.539,0.795-6.837,1.382 C0.45,11.705,0,12.417,0,13.2V16h9.023C8.39,15.162,8,14.131,8,13z"></path></g></svg>', 24: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M9,12c2.761,0,5-3.239,5-6V5c0-2.761-2.239-5-5-5S4,2.239,4,5v1C4,8.761,6.239,12,9,12z"/> <path d="M16.257,15.315c-0.093-0.043-0.184-0.088-0.283-0.121C14.329,14.638,11.824,14,9,14 s-5.329,0.638-6.974,1.193C0.81,15.604,0,16.749,0,18.032V22h14.349C14.127,21.374,14,20.702,14,20 C14,18.103,14.883,16.414,16.257,15.315z"/> <polygon points="21,16 19,16 19,19 16,19 16,21 19,21 19,24 21,24 21,21 24,21 24,19 21,19 "/></g></svg>' }, "person-remove": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><g><circle cx="8" cy="4" r="4"/> <rect x="10" y="12" width="6" height="2"/> <path d="M8,13c0-1.117,0.379-2.137,0.998-2.97C8.673,10.013,8.344,10,8,10c-3.192,0-5.539,0.795-6.837,1.382 C0.45,11.705,0,12.417,0,13.2V16h9.023C8.39,15.162,8,14.131,8,13z"/></g></svg>', 24: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M9,12c2.761,0,5-3.239,5-6V5c0-2.761-2.239-5-5-5S4,2.239,4,5v1C4,8.761,6.239,12,9,12z"/> <path d="M16.257,15.315c-0.093-0.043-0.184-0.088-0.283-0.121C14.329,14.638,11.824,14,9,14 s-5.329,0.638-6.974,1.193C0.81,15.604,0,16.749,0,18.032V22h14.349C14.127,21.374,14,20.702,14,20 C14,18.103,14.883,16.414,16.257,15.315z"/> <rect x="16" y="19" width="8" height="2"/></g></svg>' }, "person-multiple": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M17,2c-0.905,0-1.73,0.312-2.4,0.818C15.475,3.986,16,5.431,16,7v1 c0,0.953-0.193,1.862-0.54,2.691C15.935,10.889,16.454,11,17,11c2.209,0,4-1.791,4-4V6C21,3.791,19.209,2,17,2z"/> <path d="M9,13L9,13c-2.761,0-5-2.239-5-5V7c0-2.761,2.239-5,5-5h0c2.761,0,5,2.239,5,5v1C14,10.761,11.761,13,9,13z"/> <path d="M22.839,14.405C21.555,13.815,19.354,13,17,13c-1.195,0-2.35,0.211-3.367,0.495 c0.376,0.078,0.753,0.157,1.13,0.253c2.911,0.742,4.97,3.275,5.192,6.252H23c0.552,0,1-0.448,1-1v-2.779 C24,15.439,23.55,14.731,22.839,14.405z"/> <path d="M17,22H1c-0.552,0-1-0.448-1-1v-0.475c0-2.275,1.527-4.277,3.731-4.839C5.205,15.31,7.021,15,9,15 s3.795,0.31,5.269,0.686C16.473,16.248,18,18.25,18,20.525V21C18,21.552,17.552,22,17,22z"/></g></svg>' }, help: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><path d="M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M8,14c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6 S11.3,14,8,14z"/> <circle cx="8" cy="12" r="1"/> <path d="M7.1,5.5C7.3,5.2,7.6,5,8,5c0.6,0,1,0.4,1,1c0,0.3-0.1,0.4-0.6,0.7C7.8,7.1,7,7.7,7,9v1h2V9 c0-0.2,0-0.3,0.5-0.6C10.1,8,11,7.4,11,6c0-1.7-1.3-3-3-3C6.9,3,5.9,3.6,5.4,4.5L4.9,5.4l1.7,1L7.1,5.5z"/></g></svg>', 24: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M12,0C5.383,0,0,5.383,0,12s5.383,12,12,12s12-5.383,12-12S18.617,0,12,0z M11.5,19 c-0.828,0-1.5-0.672-1.5-1.5s0.672-1.5,1.5-1.5s1.5,0.672,1.5,1.5S12.328,19,11.5,19z M15.811,10.127 c-0.309,0.495-0.896,1.051-1.762,1.669c-1.401,1.036-1.363,1.266-1.363,2.204h-2.457c0-0.733-0.016-1.296,0.38-1.981 c0.253-0.439,0.717-0.906,1.391-1.4c0.809-0.578,1.595-1.135,1.595-2.105c0-0.909-0.778-1.233-1.687-1.233 c-0.927,0-1.984,0.303-3.171,0.909l-1.011-2.03c2.157-1.209,5.561-1.756,7.422-0.241C16.514,7.032,16.522,8.989,15.811,10.127z"/></g></svg>' }, search: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><path d="M12.7,11.3c0.9-1.2,1.4-2.6,1.4-4.2C14.1,3.2,11,0,7.1,0S0,3.2,0,7.1c0,3.9,3.2,7.1,7.1,7.1 c1.6,0,3.1-0.5,4.2-1.4l3,3c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L12.7,11.3z M7.1,12.1 C4.3,12.1,2,9.9,2,7.1S4.3,2,7.1,2s5.1,2.3,5.1,5.1S9.9,12.1,7.1,12.1z"/></g></svg>', 24: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M23.061,20.939l-5.733-5.733a9.028,9.028,0,1,0-2.122,2.122l5.733,5.733ZM3,10a7,7,0,1,1,7,7A7.008,7.008,0,0,1,3,10Z" /></g></svg>' }, "attach-file": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M11.5,24C7.4,24,4,20.6,4,16.5v-11C4,2.5,6.5,0,9.5,0S15,2.5,15,5.5v10c0,1.9-1.6,3.5-3.5,3.5S8,17.4,8,15.5 V7c0-0.6,0.4-1,1-1s1,0.4,1,1v8.5c0,0.8,0.7,1.5,1.5,1.5s1.5-0.7,1.5-1.5v-10C13,3.6,11.4,2,9.5,2S6,3.6,6,5.5v11 c0,3,2.5,5.5,5.5,5.5s5.5-2.5,5.5-5.5V4c0-0.6,0.4-1,1-1s1,0.4,1,1v12.5C19,20.6,15.6,24,11.5,24z"/></g></svg>' }, attachment: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M8.5,23.1c-1.9,0-3.8-0.7-5.3-2.2C1.8,19.5,1,17.6,1,15.6c0-2,0.8-3.9,2.2-5.3L11,2.5c2.1-2.1,5.6-2.1,7.8,0 s2.1,5.6,0,7.8l-7.1,7.1c-1.4,1.4-3.6,1.4-5,0c-1.4-1.4-1.4-3.6,0-5l6-6c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-6,6 c-0.6,0.6-0.6,1.5,0,2.1c0.6,0.6,1.5,0.6,2.1,0l7.1-7.1c0.7-0.7,1-1.5,1-2.5c0-0.9-0.4-1.8-1-2.5c-1.4-1.4-3.6-1.4-4.9,0l-7.8,7.8 c-1,1-1.6,2.4-1.6,3.9c0,1.5,0.6,2.8,1.6,3.9c2.1,2.1,5.6,2.1,7.8,0l8.8-8.8c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-8.8,8.8 C12.4,22.4,10.5,23.1,8.5,23.1z"/></g></svg>' }, download: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M19.872,10.076C19.189,6.045,15.666,3,11.5,3c-4.304,0-7.877,3.196-8.419,7.396C1.236,11.161,0,12.963,0,15 c0,2.757,2.243,5,5,5h14c2.757,0,5-2.243,5-5C24,12.54,22.215,10.49,19.872,10.076z M12,17l-5-5h4V8h2v4h4L12,17z"/></g></svg>' }, upload: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M19.872,10.076C19.189,6.045,15.666,3,11.5,3c-4.304,0-7.876,3.196-8.419,7.396C1.235,11.161,0,12.963,0,15 c0,2.757,2.243,5,5,5h14c2.757,0,5-2.243,5-5C24,12.54,22.215,10.489,19.872,10.076z M13,13v4h-2v-4H7l5-5l5,5H13z"/></g></svg>' }, settings: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M24,14V10l-3.338-.417a8.934,8.934,0,0,0-.826-2L21.9,4.929,19.071,2.1,16.418,4.164a8.934,8.934,0,0,0-2-.826L14,0H10L9.583,3.338a8.934,8.934,0,0,0-2,.826L4.929,2.1,2.1,4.929,4.164,7.582a8.934,8.934,0,0,0-.826,2L0,10v4l3.338.417a8.934,8.934,0,0,0,.826,2L2.1,19.071,4.929,21.9l2.653-2.063a8.934,8.934,0,0,0,2,.826L10,24h4l.417-3.338a8.934,8.934,0,0,0,2-.826L19.071,21.9,21.9,19.071l-2.063-2.653a8.934,8.934,0,0,0,.826-2ZM12,16a4,4,0,1,1,4-4A4,4,0,0,1,12,16Z" /></g></svg>' }, "chevron-up": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M22.412,16.809L12,9.236L1.588,16.809l-1.177-1.617l11-8c0.351-0.256,0.826-0.256,1.177,0l11,8 L22.412,16.809z"/></g></svg>' }, "chevron-right": { 0: '<svg class="icon__body--flip-rtl" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M8.809,23.588l-1.617-1.176L14.764,12L7.191,1.588l1.617-1.176l8,11c0.255,0.351,0.255,0.825,0,1.176 L8.809,23.588z"/></g></svg>', 24: '<svg class="icon__body--flip-rtl" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></g></svg>' }, "chevron-down": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M12,17c-0.207,0-0.413-0.063-0.588-0.191l-11-8l1.177-1.617L12,14.764l10.412-7.572l1.177,1.617l-11,8 C12.413,16.937,12.207,17,12,17z"/></g></svg>' }, "chevron-left": { 0: '<svg class="icon__body--flip-rtl" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M15.191,23.588l-8-11c-0.255-0.351-0.255-0.825,0-1.176l8-11l1.617,1.176L9.236,12l7.572,10.412 L15.191,23.588z"/></g></svg>', 24: '<svg class="icon__body--flip-rtl" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></g></svg>' }, "circle-chevron-up": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M0,12c0,6.617,5.383,12,12,12s12-5.383,12-12S18.617,0,12,0S0,5.383,0,12z M17.414,14L16,15.414l-4-4l-4,4 L6.586,14L12,8.586L17.414,14z"/></g></svg>' }, "circle-chevron-down": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M24,12c0-6.617-5.383-12-12-12S0,5.383,0,12s5.383,12,12,12S24,18.617,24,12z M6.586,10L8,8.586l4,4l4-4 L17.414,10L12,15.414L6.586,10z"/></g></svg>' }, "arrow-up": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M12,0l7,10h-6v13c0,0.553-0.448,1-1,1s-1-0.447-1-1V10H5L12,0z"/></g></svg>' }, "arrow-down": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M12,24l7-10h-6V1c0-0.553-0.448-1-1-1c-0.552,0-1,0.447-1,1v13H5L12,24z"/></g></svg>' }, "circle-arrow-up": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M12,0C5.383,0,0,5.383,0,12c0,6.617,5.383,12,12,12s12-5.383,12-12S18.617,0,12,0z M12,5l5,6h-4v8h-2v-8H7 L12,5z"/></g></svg>' }, "circle-arrow-down": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M24,12c0-6.617-5.383-12-12-12C5.383,0,0,5.383,0,12c0,6.617,5.383,12,12,12S24,18.617,24,12z M7,13h4V5h2v8 h4l-5,6L7,13z"/></g></svg>' }, notifications: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M21.855,18.482A12.85,12.85,0,0,1,20,11.994V8.006a8,8,0,0,0-16,0v3.982a12.851,12.851,0,0,1-1.855,6.494A1,1,0,0,0,3,20H21a1,1,0,0,0,.855-1.518Z" /> <path d="M13.007,23.825a3,3,0,0,0,1.819-1.819H9.174A3,3,0,0,0,13.007,23.825Z"/></g></svg>' }, "notifications-empty": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M13.007,23.822A3,3,0,0,0,14.826,22H9.174A3,3,0,0,0,13.007,23.822Z" /> <path  d="M20,11.991V8A7.99,7.99,0,0,0,6.474,2.232L20.982,16.739A12.807,12.807,0,0,1,20,11.991Z"/> <path d="M22.707,21.293l-20-20A1,1,0,0,0,1.293,2.707L4.339,5.753A7.858,7.858,0,0,0,4,8v3.982a12.849,12.849,0,0,1-1.855,6.494A1,1,0,0,0,3,20H18.583l2.71,2.71a1,1,0,0,0,1.414-1.414Z" /></g></svg>' }, "notifications-outline": { 0: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><path d="M19,13V8A7,7,0,0,0,5,8v5a13.834,13.834,0,0,1-2,7H21A13.834,13.834,0,0,1,19,13Z" fill="none" stroke-miterlimit="10"/> <path data-stroke="none" d="M9.174,22a3,3,0,0,0,5.652,0Z" stroke="none"/></g></svg>' }, "notifications-empty-outline": { 0: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2" ><path d="M19.041,14c-.027-.325-.041-.659-.041-1V8A7.023,7.023,0,0,0,8,2.235" fill="none" stroke-miterlimit="10"/> <path data-cap="butt" d="M5.464,5.464A7.066,7.066,0,0,0,5,8v5a13.834,13.834,0,0,1-2,7H20" fill="none" stroke-miterlimit="10" stroke-linecap="butt"/> <path data-stroke="none" d="M9.174,22.006a3,3,0,0,0,5.652,0Z" stroke="none"/> <line  x1="2" y1="2" x2="22" y2="22" fill="none" stroke-miterlimit="10"/></g></svg>' }, "open-new": { 0: '<svg class="icon__body--flip-rtl" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><polygon points="16,0 10,0 12.293,2.293 6.022,8.564 7.436,9.978 13.707,3.707 16,6 "></polygon> <path d="M13,16H1c-0.552,0-1-0.448-1-1V3c0-0.552,0.448-1,1-1h6v2H2v10h10V9h2v6C14,15.552,13.552,16,13,16z"></path></g></svg>', 24: '<svg class="icon__body--flip-rtl" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><polygon points="24,0 13,0 17.793,4.793 11.293,11.293 12.707,12.707 19.207,6.207 24,11 "/> <path d="M19,24H1c-0.553,0-1-0.447-1-1V5c0-0.553,0.447-1,1-1h9v2H2v16h16v-8h2v9C20,23.553,19.553,24,19,24z"/></g></svg>' }, trash: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M3,8V21a3,3,0,0,0,3,3H18a3,3,0,0,0,3-3V8ZM9,19H7V12H9Zm4,0H11V12h2Zm4,0H15V12h2Z" /> <path d="M23,4H17V1a1,1,0,0,0-1-1H8A1,1,0,0,0,7,1V4H1A1,1,0,0,0,1,6H23a1,1,0,0,0,0-2ZM9,2h6V4H9Z"/></g></svg>' }, "trash-outline": { 0: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><path d="M20,9V21a2,2,0,0,1-2,2H6a2,2,0,0,1-2-2V9" fill="none" stroke-miterlimit="10"></path> <line x1="1" y1="5" x2="23" y2="5" fill="none" stroke-miterlimit="10"></line> <line x1="12" y1="12" x2="12" y2="18" fill="none" stroke-miterlimit="10"></line> <line x1="8" y1="12" x2="8" y2="18" fill="none" stroke-miterlimit="10"></line> <line x1="16" y1="12" x2="16" y2="18" fill="none" stroke-miterlimit="10"></line> <polyline data-cap="butt" points="8 5 8 1 16 1 16 5" fill="none" stroke-miterlimit="10" stroke-linecap="butt"></polyline></g></svg>' }, reset: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><path d="M2.502,12.333c-0.726-0.92-1.212-2.016-1.405-3.168l1.973-0.331 c0.138,0.822,0.484,1.604,1.003,2.26L2.502,12.333z"></path><path d="M6.834,14.903c-1.07-0.18-2.1-0.615-2.976-1.259l1.186-1.611 c0.624,0.459,1.358,0.77,2.122,0.898L6.834,14.903z"></path><path d="M9.165,14.903l-0.33-1.973c0.799-0.134,1.563-0.467,2.209-0.964l1.219,1.586 C11.358,14.248,10.287,14.715,9.165,14.903z"></path><path d="M8,1C6.127,1,4.35,1.759,3.052,3.052L0.9,0.9L0.2,7.3l6.4-0.7L4.465,4.465C5.393,3.542,6.662,3,8,3 c2.757,0,5,2.243,5,5c0,1.06-0.327,2.072-0.947,2.928l1.621,1.173C14.541,10.901,15,9.483,15,8C15,4.14,11.859,1,8,1z"></path></g></svg>', 24: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><path data-cap="butt" fill="none" stroke-miterlimit="10" d="M22,12c0-5.5-4.5-10-10-10 C8.1,2,4.7,4.2,3.1,7.5" stroke-linecap="butt"/> <polyline fill="none" stroke-miterlimit="10" points="2.3,1.6 3.1,7.5 9.1,6.7 "/> <path fill="none" stroke-miterlimit="10" d=" M19.26,18.885c0.658-0.703,1.213-1.505,1.64-2.385"/> <path fill="none" stroke-miterlimit="10" d=" M12.25,21.997c1.122-0.027,2.199-0.236,3.201-0.601"/> <path fill="none" stroke-miterlimit="10" d="M4.866,18.99 c0.779,0.795,1.69,1.462,2.695,1.964"/> <path fill="none" stroke-miterlimit="10" d="M2,12 c0,1.042,0.162,2.048,0.461,2.994"/></g></svg>' }, filter: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><g transform="translate(0, 0)"><path d="M15,3h-5C9.4,3,9,3.4,9,4s0.4,1,1,1h5c0.6,0,1-0.4,1-1S15.6,3,15,3z"></path><path d="M1,5h1v2c0,0.6,0.4,1,1,1h3c0.6,0,1-0.4,1-1V1c0-0.6-0.4-1-1-1H3C2.4,0,2,0.4,2,1v2H1C0.4,3,0,3.4,0,4,S0.4,5,1,5z"></path><path d="M1,13h5c0.6,0,1-0.4,1-1s-0.4-1-1-1H1c-0.6,0-1,0.4-1,1S0.4,13,1,13z"></path><path d="M15,11h-1V9c0-0.6-0.4-1-1-1h-3C9.4,8,9,8.4,9,9v6c0,0.6,0.4,1,1,1h3c0.6,0,1-0.4,1-1v-2h1,c0.6,0,1-0.4,1-1S15.6,11,15,11z"></path></g></svg>' }, sort: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><polygon points="7,0 13,7 8,7 8,17 6,17 6,7 1,7 "/> <polygon points="18,7 18,17 23,17 17,24 11,17 16,17 16,7 "/></g></svg>' }, swap: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M22,16H10v-5.9L0.3,17l9.7,6.9V18h12c0.6,0,1-0.4,1-1S22.6,16,22,16z"/> <path d="M14,13.9L23.7,7L14,0.1V6H2C1.4,6,1,6.4,1,7s0.4,1,1,1h12V13.9z"/></g></svg>' }, "transfer-out": { 0: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><polyline fill="none" stroke-miterlimit="10" points=" 2,16 2,22 22,22 22,16 "></polyline> <line data-cap="butt" fill="none" stroke-miterlimit="10" x1="12" y1="17" x2="12" y2="2" stroke-linecap="butt"></line> <polyline fill="none" stroke-miterlimit="10" points="18,8 12,2 6,8 "></polyline></g></svg>' }, "transfer-in": { 0: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><polyline fill="none" stroke-miterlimit="10" points=" 2,16 2,22 22,22 22,16 "></polyline> <line data-cap="butt" fill="none" stroke-miterlimit="10" x1="12" y1="1" x2="12" y2="16" stroke-linecap="butt"></line> <polyline fill="none" stroke-miterlimit="10" points="6,10 12,16 18,10 "></polyline></g></svg>' }, "jw-dashboard": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"></path></g></svg>' }, "logo-no-trademark": { 0: '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg">\n        <style type="text/css">\n            .st1 {\n                fill: #FFFFFF;\n            }\n        </style>\n        <rect width="80" height="80" />\n        <path class="st1" d="M22.7 41.2c-1.6 0-3-0.2-4.1-0.7 -1.1-0.5-2.1-1.1-3.1-1.8l1.5-2.8c0.9 0.7 1.7 1.2 2.6 1.6 0.9 0.4 1.8 0.6 2.8 0.6 1.4 0 2.4-0.5 3.2-1.5 0.7-1 1.1-2.4 1.1-4.1V13.3h3.5v19c0 2.7-0.6 4.8-1.8 6.4C27.2 40.4 25.3 41.2 22.7 41.2M39.9 40.9h3l6.5-20.6 5.9 20.6h3.1l6.7-27.5h-3.7c0 0-4.4 19.9-4.7 20.9L51 14.4h-3l-6.1 19.9 -4.4-20.9h-3.8L39.9 40.9zM27.5 66c1-0.5 1.8-1.1 2.5-2 0.7-0.9 1.2-1.9 1.6-3.1 0.4-1.2 0.6-2.5 0.6-4 0-1.4-0.2-2.8-0.6-3.9 -0.4-1.2-0.9-2.2-1.7-3 -0.7-0.8-1.6-1.5-2.5-1.9 -1-0.5-2.1-0.7-3.3-0.7 -1.2 0-2.3 0.2-3.3 0.7 -1 0.5-1.9 1.1-2.6 1.9 -0.7 0.8-1.3 1.9-1.7 3 -0.4 1.2-0.6 2.5-0.6 4 0 1.4 0.2 2.8 0.5 3.9 0.4 1.2 0.9 2.2 1.6 3.1 0.7 0.8 1.5 1.5 2.5 2 1 0.5 2.2 0.7 3.5 0.7C25.4 66.7 26.5 66.5 27.5 66zM26.6 49.7c0.7 0.4 1.4 1 1.9 1.7 0.5 0.7 0.9 1.5 1.2 2.5 0.3 0.9 0.4 2 0.4 3.1 0 1.2-0.2 2.2-0.4 3.2 -0.3 1-0.7 1.8-1.2 2.5 -0.5 0.7-1.2 1.3-1.9 1.7C25.8 64.8 25 65 24.2 65c-0.9 0-1.7-0.2-2.5-0.6 -0.7-0.4-1.4-1-1.9-1.7 -0.5-0.7-0.9-1.6-1.2-2.5 -0.3-1-0.4-2-0.4-3.2 0-1.1 0.1-2.2 0.4-3.1 0.3-0.9 0.7-1.8 1.2-2.5 0.5-0.7 1.2-1.3 1.9-1.6 0.7-0.4 1.6-0.6 2.5-0.6C25 49.1 25.9 49.3 26.6 49.7zM48.8 66.4l-5.2-8.1 0.3-0.1c0.6-0.1 1.2-0.4 1.7-0.6 0.5-0.3 1-0.6 1.4-1 0.4-0.4 0.7-0.9 0.9-1.5 0.2-0.6 0.3-1.2 0.3-1.9 0-0.9-0.2-1.8-0.5-2.4 -0.3-0.7-0.8-1.2-1.4-1.7 -0.6-0.4-1.3-0.8-2.1-1 -0.8-0.2-1.6-0.3-2.4-0.3h-6.1v18.7h2v-7.8h3.8l4.9 7.8H48.8zM37.6 49.4h4c1.3 0 2.4 0.3 3.2 1 0.8 0.7 1.2 1.6 1.2 2.8 0 1.2-0.4 2.1-1.3 2.7 -0.8 0.6-1.9 0.9-3.4 0.9h-3.8V49.4zM61 66.5c0.6-0.1 1.1-0.3 1.6-0.5 0.5-0.2 0.9-0.5 1.3-0.7 0.4-0.2 0.7-0.5 1-0.8v-8h-6.4v1.7H63v5.4l-0.1 0.1c-0.3 0.3-0.8 0.6-1.4 0.9C60.8 64.8 60 65 59.2 65c-0.9 0-1.8-0.2-2.5-0.6 -0.8-0.4-1.4-0.9-2-1.6 -0.6-0.7-1-1.5-1.3-2.5 -0.3-1-0.5-2-0.5-3.2 0-1.1 0.2-2.2 0.5-3.2 0.3-1 0.8-1.8 1.3-2.5 0.6-0.7 1.2-1.3 2-1.6 0.8-0.4 1.6-0.6 2.4-0.6 1 0 1.9 0.2 2.7 0.6 0.7 0.3 1.3 0.8 1.9 1.2l1.2-1.6c-0.8-0.6-1.6-1.1-2.5-1.5 -0.9-0.4-2-0.5-3.2-0.5 -1.2 0-2.4 0.2-3.4 0.7 -1 0.5-1.9 1.2-2.6 2 -0.7 0.9-1.3 1.9-1.7 3 -0.4 1.2-0.6 2.5-0.6 3.8 0 1.5 0.2 2.8 0.6 4 0.4 1.2 1 2.2 1.7 3.1 0.7 0.8 1.6 1.5 2.7 2 1 0.5 2.2 0.7 3.5 0.7C59.8 66.7 60.4 66.6 61 66.5zM14.7 63.5h-2.9v2.9h2.9V63.5z" />\n    </svg>' }, language: { 0: '<svg viewBox="21 23 214 192" enable-background="new 21 23 214 192" xmlns="http://www.w3.org/2000/svg">\n        <rect display="none" fill="#D1D3D4" width="612" height="792"/>\n        <path d="M144.669,112.987c-2.917,3.234-4.405,6.647-4.405,10.199c0,2.184,0.734,3.93,2.202,5.299\n            c1.469,1.369,3.363,2.063,5.676,2.063c2.907,0,6.29-1.23,10.14-3.671c-1.468-7.997-2.342-15.062-2.609-21.134\n            C151.257,107.352,147.605,109.732,144.669,112.987z"/>\n        <path d="M164.096,103.879c0.536,6.747,1.092,12.164,1.707,16.312c3.085-3.135,6.151-8.83,9.207-17.046\n            c-0.417-0.06-1.141-0.119-2.094-0.119C169.83,103.025,166.894,103.304,164.096,103.879z"/>\n        <polygon points="77.508,114.178 95.843,114.178 86.586,89.254 "/>\n        <path d="M223.577,23.354H32.433c-5.854,0-10.616,4.742-10.616,10.596v138.054c0,5.854,4.762,10.616,10.616,10.616\n            h72.747l-9.872,32.027l70.772-32.027h57.497c5.864,0,10.606-4.763,10.606-10.616V33.949\n            C234.184,28.096,229.441,23.354,223.577,23.354z M85.901,52.702h17.065L88.055,69.966h-9.624L85.901,52.702z M106.072,140.749\n            l-5.873-15.26H73.34l-5.536,15.26H53.407l26.164-67.172h14.356l26.908,67.172H106.072z M195.746,134.24\n            c-4.563,5.179-10.478,9.227-17.76,12.184l-4.861-8.096c14.01-5.597,20.994-12.105,20.994-19.507c0-3.115-0.973-5.993-2.917-8.612\n            c-1.965-2.619-4.515-4.425-7.67-5.477c-3.998,11.668-9.188,20.142-15.587,25.439c0.536,1.746,1.31,3.453,2.342,5.14l-8.335,3.572\n            l-1.319-3.394c-4.117,2.619-8.682,3.949-13.722,3.949c-4.236,0-7.839-1.469-10.735-4.366c-2.927-2.957-4.386-6.688-4.386-11.212\n            c0-5.933,2.113-11.291,6.35-16.033c4.228-4.803,9.883-8.354,16.947-10.696c-0.09-2.063-0.109-5.278-0.109-9.584l-18.019,2.143\n            l-1.002-8.434l19.13-2.282l0.675-11.509l8.989,0.556c-0.397,2.262-0.755,5.517-1.102,9.763l27.691-3.313l1.191,8.532l-29.161,3.751\n            l0.169,8.572c2.302-0.754,5.715-1.131,10.239-1.131c7.72,0,14.466,2.262,20.211,6.807c5.725,4.544,8.603,10.259,8.603,17.125\n            C202.593,123.683,200.33,129.061,195.746,134.24z"/>\n    </svg>' }, "language-sign": { 0: '<svg viewBox="270 25 319 211" enable-background="new 270 25 319 211" xmlns="http://www.w3.org/2000/svg">\n        <rect display="none" fill="#D1D3D4" width="612" height="792"/>\n        <path d="M362.602,72.192c8.1,0,14.678-6.754,14.678-15.104c0-8.299-6.578-15.062-14.678-15.062\n            c-8.117,0-14.674,6.763-14.674,15.062C347.928,65.438,354.484,72.192,362.602,72.192z"/>\n        <path d="M349.67,98.942c-0.008,4.521-0.311,9.093-0.961,13.69c-1.338,9.411-4.024,18.271-7.756,26.465h44.016\n            c2.805-7.03,4.84-14.518,5.939-22.359c0.535-3.804,0.85-7.582,0.945-11.352c-8.809,9.67-22.994,16.054-39.134,16.795\n            c-0.237-0.621-1.454-4.96,7.427-7.944c0.014-0.026,0.048-0.035,0.057-0.035v-0.008c12.426-4.813,21.217-15.01,21.764-27.233\n            c0.194-3.735-0.465-7.358-1.707-10.774c-0.031,0-1.242,0.811-3.105,1.69c-29.084,12.802-53.867-2.147-62.175-15.769\n            c0,0-3.89-0.819-2.472,4.899C315.213,78.075,329.641,93.223,349.67,98.942z"/>\n        <path d="M429.714,25.412H288.38c-7.091,0-17.667,10.386-17.667,17.667v97.166c0,7.281,10.576,17.667,17.667,17.667\n            h35.333l59.357,26.595l-6.357-26.595h53c7.1,0,17.667-10.386,17.667-17.667V43.079C447.381,35.797,436.813,25.412,429.714,25.412z\n            M438.547,140.245c0,4.856-4.105,8.834-8.833,8.834H288.38c-4.723,0-8.833-3.978-8.833-8.834V43.079c0-4.866,4.11-8.834,8.833-8.834\n            l141.333-0.043c4.728,0,8.833,3.934,8.833,8.799V140.245z"/>\n        <path d="M512.992,147.31c-2.467,2.812-3.727,5.771-3.727,8.867c0,1.89,0.621,3.408,1.863,4.599\n            c1.242,1.198,2.847,1.794,4.805,1.794c2.459,0,5.314-1.062,8.574-3.191c-1.242-6.953-1.983-13.087-2.208-18.374\n            C518.564,142.402,515.477,144.48,512.992,147.31z"/>\n        <path d="M529.434,139.382c0.44,5.866,0.914,10.584,1.432,14.182c2.614-2.726,5.211-7.678,7.79-14.82\n            c-0.354-0.052-0.958-0.095-1.769-0.095C534.281,138.649,531.797,138.89,529.434,139.382z"/>\n        <polygon points="456.18,148.336 471.689,148.336 463.857,126.667 "/>\n        <path d="M571.047,69.579H429.714c-4.956,0-17.667,12.577-17.667,17.666v97.167c0,5.098,12.711,17.667,17.667,17.667\n            h49.868l-8.342,33.607l59.858-33.607h39.948c4.96,0,17.667-12.569,17.667-17.667V87.245\n            C588.714,82.156,576.007,69.579,571.047,69.579z M462.623,97.769h12.224l-10.679,11.913h-6.902L462.623,97.769z M480.35,171.446\n            l-4.969-13.267h-22.729l-4.685,13.267h-12.18l22.135-58.408h12.146l22.764,58.408H480.35z M556.201,165.779\n            c-3.873,4.503-8.859,8.022-15.018,10.602l-4.115-7.039c11.844-4.865,17.753-10.532,17.753-16.968c0-2.709-0.819-5.202-2.476-7.487\n            c-1.648-2.27-3.813-3.848-6.479-4.762c-3.391,10.152-7.772,17.52-13.189,22.126c0.457,1.51,1.112,3.002,1.984,4.46l-7.049,3.114\n            l-1.112-2.959c-3.485,2.286-7.35,3.434-11.61,3.434c-3.59,0-6.625-1.269-9.084-3.796c-2.477-2.563-3.719-5.806-3.719-9.748\n            c0-5.149,1.795-9.808,5.383-13.939c3.572-4.167,8.352-7.255,14.329-9.291c-0.077-1.803-0.087-4.589-0.087-8.333l-15.242,1.863\n            l-0.854-7.332l16.183-1.984l0.577-10.015l7.609,0.482c-0.346,1.976-0.647,4.797-0.94,8.497l23.421-2.881l1.018,7.418l-24.672,3.261\n            l0.146,7.445c1.941-0.647,4.831-0.983,8.661-0.983c6.53,0,12.232,1.975,17.089,5.917c4.848,3.951,7.281,8.92,7.281,14.89\n            C561.99,156.609,560.074,161.276,556.201,165.779z"/>\n    </svg>' }, info: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><g transform="translate(0, 0)"><path d="M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M8,14c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6  S11.3,14,8,14z"/><rect x="7" y="7" width="2" height="5"/><circle cx="8" cy="5" r="1"/></g></svg>', 24: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M12,0C5.383,0,0,5.383,0,12s5.383,12,12,12s12-5.383,12-12S18.617,0,12,0z M14.658,18.284 c-0.661,0.26-2.952,1.354-4.272,0.191c-0.394-0.346-0.59-0.785-0.59-1.318c0-0.998,0.328-1.868,0.919-3.957 c0.104-0.395,0.231-0.907,0.231-1.313c0-0.701-0.266-0.887-0.987-0.887c-0.352,0-0.742,0.125-1.095,0.257l0.195-0.799 c0.787-0.32,1.775-0.71,2.621-0.71c1.269,0,2.203,0.633,2.203,1.837c0,0.347-0.06,0.955-0.186,1.375l-0.73,2.582 c-0.151,0.522-0.424,1.673-0.001,2.014c0.416,0.337,1.401,0.158,1.887-0.071L14.658,18.284z M13.452,8c-0.828,0-1.5-0.672-1.5-1.5 s0.672-1.5,1.5-1.5s1.5,0.672,1.5,1.5S14.28,8,13.452,8z"/></g></svg>' }, calendar: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M19,3V1a1,1,0,0,0-2,0V3Z"></path> <path d="M7,3V1A1,1,0,0,0,5,1V3Z"></path> <path d="M21,23H3a3,3,0,0,1-3-3V7A3,3,0,0,1,3,4H21a3,3,0,0,1,3,3V20A3,3,0,0,1,21,23ZM22,9H2V20a1,1,0,0,0,1,1H21a1,1,0,0,0,1-1Z"></path> <rect x="4" y="11" width="4" height="3"></rect> <rect x="10" y="11" width="4" height="3"></rect> <rect x="4" y="16" width="4" height="3"></rect> <rect x="10" y="16" width="4" height="3"></rect> <rect x="16" y="11" width="4" height="3"></rect></g></svg>' }, "calendar-outline": { 0: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><rect x="5" y="12" width="2" height="1" fill="none" stroke-miterlimit="10"></rect> <rect x="11" y="12" width="2" height="1" fill="none" stroke-miterlimit="10"></rect> <rect x="5" y="17" width="2" height="1" fill="none" stroke-miterlimit="10"></rect> <rect x="11" y="17" width="2" height="1" fill="none" stroke-miterlimit="10"></rect> <rect x="17" y="12" width="2" height="1" fill="none" stroke-miterlimit="10"></rect> <rect data-stroke="none" x="5" y="12" width="2" height="1" stroke="none"></rect> <rect data-stroke="none" x="11" y="12" width="2" height="1" stroke="none"></rect> <rect data-stroke="none" x="5" y="17" width="2" height="1" stroke="none"></rect> <rect data-stroke="none" x="11" y="17" width="2" height="1" stroke="none"></rect> <rect data-stroke="none" x="17" y="12" width="2" height="1" stroke="none"></rect> <rect x="1" y="3" width="22" height="19" rx="2" ry="2" fill="none" stroke-miterlimit="10"></rect> <line x1="6" y1="1" x2="6" y2="4" fill="none" stroke-miterlimit="10"></line> <line x1="18" y1="1" x2="18" y2="4" fill="none" stroke-miterlimit="10"></line> <line x1="1" y1="8" x2="23" y2="8" fill="none" stroke-miterlimit="10"></line></g></svg>' }, cards: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" xml:space="preserve"><g><rect x="1" y="1" width="10" height="10"></rect> <rect x="13" y="1" transform="matrix(-1 -4.492907e-11 4.492907e-11 -1 36 12)" width="10" height="10"></rect> <rect x="1" y="13" width="10" height="10"></rect> <rect x="13" y="13" transform="matrix(-1 -4.492907e-11 4.492907e-11 -1 36 36)" width="10" height="10"></rect></g></svg>' }, table: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><path d="M15,0H1C0.4,0,0,0.4,0,1v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1V1C16,0.4,15.6,0,15,0z M14,7H9V2h5V7z M7,2 v5H2V2H7z M2,9h5v5H2V9z M9,14V9h5v5H9z"></path></g></svg>', 24: '<svg class="icon__body--stroke icon__body--stroke-only" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" xml:space="preserve"><g><line fill="none" stroke-width="2" stroke-linecap="square" stroke-miterlimit="10" x1="8" y1="1" x2="8" y2="22" stroke-linejoin="miter"></line> <line fill="none" stroke-width="2" stroke-linecap="square" stroke-miterlimit="10" x1="15" y1="1" x2="15" y2="22" stroke-linejoin="miter"></line> <line fill="none" stroke-width="2" stroke-linecap="square" stroke-miterlimit="10" x1="1" y1="8" x2="22" y2="8" stroke-linejoin="miter"></line> <line fill="none" stroke-width="2" stroke-linecap="square" stroke-miterlimit="10" x1="1" y1="15" x2="22" y2="15" stroke-linejoin="miter"></line> <rect x="1" y="1" fill="none" stroke-width="2" stroke-linecap="square" stroke-miterlimit="10" width="21" height="21" stroke-linejoin="miter"></rect></g></svg>' }, list: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g><rect x="6" y="1" width="10" height="2"></rect> <rect x="6" y="7" width="10" height="2"></rect> <rect x="6" y="13" width="10" height="2"></rect><path d="M3,0H1C0.4,0,0,0.4,0,1v2c0,0.6,0.4,1,1,1h2c0.6,0,1-0.4,1-1V1C4,0.4,3.6,0,3,0z"></path><path d="M3,6H1C0.4,6,0,6.4,0,7v2c0,0.6,0.4,1,1,1h2c0.6,0,1-0.4,1-1V7C4,6.4,3.6,6,3,6z"></path><path d="M3,12H1c-0.6,0-1,0.4-1,1v2c0,0.6,0.4,1,1,1h2c0.6,0,1-0.4,1-1v-2C4,12.4,3.6,12,3,12z"></path></g></svg>' }, email: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M13.4,14.6A2.3,2.3,0,0,1,12,15a2.3,2.3,0,0,1-1.4-.4L0,8.9V19a3,3,0,0,0,3,3H21a3,3,0,0,0,3-3V8.9Z" /> <path d="M21,2H3A3,3,0,0,0,0,5V6a1.05,1.05,0,0,0,.5.9l11,6a.9.9,0,0,0,.5.1.9.9,0,0,0,.5-.1l11-6A1.05,1.05,0,0,0,24,6V5A3,3,0,0,0,21,2Z"/></g></svg>' }, "email-outline": { 0: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><path d="M1,13v6a2,2,0,0,0,2,2H21a2,2,0,0,0,2-2V13" fill="none" stroke-miterlimit="10"/> <path d="M23,8V5a2,2,0,0,0-2-2H3A2,2,0,0,0,1,5V8l11,6Z" fill="none" stroke-miterlimit="10"/></g></svg>' }, phone: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M15.522,14.471l-2.334,2.3L7.229,10.812l2.3-2.334a1,1,0,0,0,.206-1.095L7.34,1.793a1,1,0,0,0-1.175-.572l-4.4,1.162a1,1,0,0,0-.749,1A21.146,21.146,0,0,0,7,17a21.146,21.146,0,0,0,13.621,5.983,1,1,0,0,0,1-.749l1.162-4.4a1,1,0,0,0-.572-1.175l-5.59-2.395A1,1,0,0,0,15.522,14.471Z" /></g></svg>' }, "phone-outline": { 0: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2"><path fill="none" stroke-miterlimit="10" d="M17,15l-3,3l-8-8l3-3L4,2 L1,5c0,9.941,8.059,18,18,18l3-3L17,15z"/></g></svg>' }, "phone-mobile": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M15.5 1h-8C6.12 1 5 2.12 5 3.5v17C5 21.88 6.12 23 7.5 23h8c1.38 0 2.5-1.12 2.5-2.5v-17C18 2.12 16.88 1 15.5 1zm-4 21c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5zm4.5-4H7V4h9v14z"/></g></svg>' }, location: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><g><path d="M8,0C4.1,0,1,3.1,1,7c0,1.9,0.7,3.7,2.1,5c0.1,0.1,4.1,3.7,4.2,3.8c0.4,0.3,1,0.3,1.3,0 c0.1-0.1,4.2-3.7,4.2-3.8c1.4-1.3,2.1-3.1,2.1-5C15,3.1,11.9,0,8,0z M8,9C6.9,9,6,8.1,6,7s0.9-2,2-2c1.1,0,2,0.9,2,2S9.1,9,8,9z"/></g></svg>', 24: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M12,0C7.6,0,3,3.4,3,9c0,5.3,8,13.4,8.3,13.7c0.2,0.2,0.4,0.3,0.7,0.3s0.5-0.1,0.7-0.3C13,22.4,21,14.3,21,9 C21,3.4,16.4,0,12,0z M12,12c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3S13.7,12,12,12z"/></g></svg>' }, "location-multiple": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><g><path d="M6,1C3.1,1,0,3.2,0,7c0,3.7,6,9,6,9s6-5.3,6-9C12,3.2,8.9,1,6,1z M6,9C4.9,9,4,8.1,4,7c0-1.1,0.9-2,2-2 s2,0.9,2,2C8,8.1,7.1,9,6,9z"/> <path d="M14,7c0,1-0.3,2.1-0.8,3.2C14.5,8.7,16,6.6,16,4.9C16,1.8,13.4,0,11.1,0c-0.3,0-0.7,0-1,0.1 C12.3,1.4,14,3.8,14,7z"/></g></svg>', 24: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g><path d="M16,0c-1.671,0-3.363,0.545-4.76,1.55C14.92,2.796,18,6.131,18,11 c0,2.685-1.638,5.724-3.466,8.288c0.362,0.389,0.638,0.673,0.756,0.792c0.188,0.189,0.443,0.295,0.71,0.295s0.522-0.106,0.71-0.295 C17.456,19.327,24,12.6,24,8C24,2.992,19.933,0,16,0z"/> <path d="M8,3c-3.933,0-8,2.992-8,8c0,4.6,6.544,11.327,7.29,12.08c0.188,0.189,0.443,0.295,0.71,0.295 s0.522-0.106,0.71-0.295C9.456,22.327,16,15.6,16,11C16,5.992,11.933,3,8,3z M8,13c-1.105,0-2-0.895-2-2c0-1.105,0.895-2,2-2 s2,0.895,2,2C10,12.105,9.105,13,8,13z"/></g></svg>' }, waiting: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16"><g><path d="M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M12,9H7V4h2v3h3V9z"/></g></svg>', 24: '<svg class="icon__body--stroke" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g stroke-linecap="square" stroke-linejoin="miter" stroke-width="2" ><polyline points="12 6 12 12 18 12" fill="none" stroke-miterlimit="10"/> <path data-cap="butt" d="M1,12a11,11,0,1,1,3.45,8" fill="none" stroke-miterlimit="10" stroke-linecap="butt"/> <polygon data-stroke="none" points="3 24 0.6 17.2 7.8 17.6 3 24" stroke="none"/></g></svg>' }, skype: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M10,0.9c0,0-0.1,0-0.1-0.1c0,0-0.1,0-0.1,0L10,0.9z"/> <path d="M0.9,9.9c0,0,0,0.1,0,0.1c0,0,0,0.1,0.1,0.1L0.9,9.9z"/> <path d="M23.1,14.1c0,0,0-0.1,0-0.1c0,0,0-0.1-0.1-0.1L23.1,14.1z"/> <path d="M13.9,23c0,0,0.1,0,0.1,0.1c0,0,0.1,0,0.1,0L13.9,23z"/> <path d="M23.2,14c0,0,0,0.1,0,0.1l0-0.2C23.1,13.9,23.1,14,23.2,14c0.1-0.7,0.2-1.4,0.2-2.1c0-1.5-0.3-3-0.9-4.4 C21.9,6.2,21.1,5,20,3.9c-1-1-2.3-1.9-3.6-2.4C15,0.9,13.5,0.6,12,0.6c-0.7,0-1.4,0.1-2.1,0.2c0,0,0,0,0,0c0,0,0.1,0,0.1,0.1l-0.2,0 c0,0,0.1,0,0.1,0C8.9,0.3,7.8,0,6.7,0C4.9,0,3.2,0.7,2,2c-1.3,1.3-2,3-2,4.7C0,7.9,0.3,9,0.8,10c0,0,0-0.1,0-0.1l0,0.2 c0,0,0-0.1-0.1-0.1c-0.1,0.6-0.2,1.3-0.2,2c0,1.5,0.3,3,0.9,4.4C2.1,17.7,3,18.9,4,20c1,1,2.3,1.9,3.6,2.4C9,23,10.5,23.3,12,23.3 c0.7,0,1.3-0.1,2-0.2c0,0-0.1,0-0.1-0.1l0.2,0c0,0-0.1,0-0.1,0c1,0.6,2.1,0.9,3.3,0.9c1.8,0,3.5-0.7,4.7-2c1.3-1.3,2-3,2-4.7 C24,16.1,23.7,15,23.2,14z M12.1,18.9c-4,0-5.8-2-5.8-3.5c0-0.8,0.6-1.3,1.3-1.3c1.7,0,1.3,2.5,4.5,2.5c1.6,0,2.6-0.9,2.6-1.8 c0-0.5-0.3-1.2-1.4-1.4l-3.6-0.9c-2.9-0.7-3.4-2.3-3.4-3.7c0-3,2.9-4.2,5.6-4.2c2.5,0,5.4,1.4,5.4,3.2c0,0.8-0.7,1.2-1.5,1.2 c-1.5,0-1.2-2-4.2-2c-1.5,0-2.3,0.7-2.3,1.6c0,1,1.2,1.3,2.2,1.5l2.7,0.6c2.9,0.6,3.6,2.3,3.6,3.9C17.8,17,15.9,18.9,12.1,18.9z"/></g></svg>' }, impersonated: { 0: '<svg viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M704 1536l96-448-96-128-128-64zm256 0l128-640-128 64-96 128zm160-1010q-2-4-4-6-10-8-96-8-70 0-167 19-7 2-21 2t-21-2q-97-19-167-19-86 0-96 8-2 2-4 6 2 18 4 27 2 3 7.5 6.5t7.5 10.5q2 4 7.5 20.5t7 20.5 7.5 17 8.5 17 9 14 12 13.5 14 9.5 17.5 8 20.5 4 24.5 2q36 0 59-12.5t32.5-30 14.5-34.5 11.5-29.5 17.5-12.5h12q11 0 17.5 12.5t11.5 29.5 14.5 34.5 32.5 30 59 12.5q13 0 24.5-2t20.5-4 17.5-8 14-9.5 12-13.5 9-14 8.5-17 7.5-17 7-20.5 7.5-20.5q2-7 7.5-10.5t7.5-6.5q2-9 4-27zm416 879q0 121-73 190t-194 69h-874q-121 0-194-69t-73-190q0-61 4.5-118t19-125.5 37.5-123.5 63.5-103.5 93.5-74.5l-90-220h214q-22-64-22-128 0-12 2-32-194-40-194-96 0-57 210-99 17-62 51.5-134t70.5-114q32-37 76-37 30 0 84 31t84 31 84-31 84-31q44 0 76 37 36 42 70.5 114t51.5 134q210 42 210 99 0 56-194 96 7 81-20 160h214l-82 225q63 33 107.5 96.5t65.5 143.5 29 151.5 8 148.5z"/></svg>' }, printer: { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g transform="translate(0, 0)"><rect x="3" width="10" height="3"></rect><path d="M15,5H1C0.4,5,0,5.4,0,6v6c0,0.6,0.4,1,1,1h2v2c0,0.6,0.4,1,1,1h8c0.6,0,1-0.4,1-1v-2h2c0.6,0,1-0.4,1-1V6 C16,5.4,15.6,5,15,5z M11,14H5V9h6V14z"></path></g></svg>' }, "printer-outline": { 0: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" class="icon__body--stroke"><g transform="translate(0, 0)"><polyline points="3.5 3.5 3.5 0.5 12.5 0.5 12.5 3.5" fill="none" stroke-linecap="round" stroke-linejoin="round" ></polyline><polyline points="3.5 12.5 0.5 12.5 0.5 5.5 15.5 5.5 15.5 12.5 12.5 12.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></polyline><rect x="3.5" y="9.5" width="9" height="6" fill="none" stroke-linecap="round" stroke-linejoin="round"></rect></g></svg>' }, drag: { 0: '<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">\n            <g>\n            <path d="M2,5H0V1c0-0.552,0.447-1,1-1h4v2H2V5z"></path>\n            <path d="M5,29H1c-0.553,0-1-0.448-1-1v-4h2v3h3V29z"></path>\n            <path d="M29,5h-2V2h-3V0h4c0.553,0,1,0.448,1,1V5z"></path>\n            <rect x="8" width="5" height="2"></rect>\n            <rect x="16" width="5" height="2"></rect>\n            <rect x="8" y="27" width="5" height="2"></rect>\n            <rect y="8" width="2" height="5"></rect>\n            <rect y="16" width="2" height="5"></rect>\n            <rect x="27" y="8" width="2" height="5"></rect>\n            <path d="M30.561,28.439l-6.211-6.211L30,19l-15-4l4,15l3.229-5.65l6.211,6.211c0.586,0.586,1.535,0.586,2.121,0 C31.146,29.975,31.146,29.025,30.561,28.439z"></path></g></svg>' } } } getIcon(t, e = 0) { const n = this.appIcons[t] || {}; return "string" == typeof n ? n : n && Object.keys(n).length ? n[Object.keys(n).map(t => parseInt(t, 10)).filter(t => t <= e).sort((t, e) => t > e ? -1 : t < e ? 1 : 0)[0]] || (console.warn(`Icon named ${t} with preferred size of ${e} does not exist!`), "") : (console.warn(`Icon named ${t} does not exist!`), "") } addIconDefinitions(t) { return this.appIcons = Object.assign(Object.assign({}, this.appIcons), t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(), ea = (() => { class t { constructor(t, e) { this._iconsProvider = t, this._renderer = e } renderIcon() { var t; if (null != this.icon && (this._renderer.setProperty(this.iconContent.nativeElement, "innerHTML", this._iconsProvider.getIcon(this.icon, null !== (t = this.size) && void 0 !== t ? t : 0)), this.iconContent.nativeElement.children.length > 0 && null != this.size)) { const t = this.iconContent.nativeElement.children[0]; null != t && (this.addIconBodyClass(t), this._renderer.setAttribute(t, "height", this.size.toString()), this._renderer.setAttribute(t, "width", "logo" === this.icon ? (this.size * (65 / 48)).toString() : this.size.toString())) } } ngOnChanges(t) { (t.icon || t.size) && this.renderIcon() } addIconBodyClass(t) { const e = t.getAttribute("class"), n = new RegExp("icon__body(?!--)", "i"); null == e || "" === e ? this._renderer.setAttribute(t, "class", "icon__body") : e.match(n) || this._renderer.setAttribute(t, "class", `icon__body ${e}`) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(ta), r.Rb(r.F)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-icon"]], viewQuery: function (t, e) { if (1 & t && r.Nc(vs, 3), 2 & t) { let t; r.xc(t = r.fc()) && (e.iconContent = t.first) } }, inputs: { icon: "icon", size: "size", cssClass: "cssClass" }, features: [r.Ab], decls: 2, vars: 2, consts: [[1, "icon", 3, "ngClass"], ["iconContent", ""]], template: function (t, e) { 1 & t && r.Sb(0, "span", 0, 1), 2 & t && r.oc("ngClass", e.cssClass || r.sc(1, ys)) }, directives: [s.l], encapsulation: 2, changeDetection: 0 }), t })(), na = (() => { class t { constructor(t, e, n, s) { var o, c; this.container = t, this.formService = e, this.actionButtons = n, this.cdr = s, this.isBusyActionSubject = new qt.a(!1), this.isBusyInputSubject = new qt.a(!1), this.unsubscribe$ = new i.a, this.isBusy$ = Object(Gt.a)([this.isBusyActionSubject.asObservable(), this.isBusyInputSubject.asObservable(), null !== (c = null === (o = this.formService) || void 0 === o ? void 0 : o.isBusy$) && void 0 !== c ? c : Object(a.a)(!1)]).pipe(Object(h.a)(([t, e, n]) => t || e || n && this.isPrimary), Object(J.a)({ refCount: !0, bufferSize: 1 })), this.busyText = "Please wait...", this.responsiveBehavior = "none", this.isAction = !1, this.isDisabled = !1, this._isBusyValue = !1, this.iconOnly = !1, this.action = new r.n, this.confirm = new r.n, this.error = new r.n, this.complete = new r.n } set isBusy(t) { this.isBusyInputSubject.next(t) } get isBusy() { return this._isBusyValue } get showAsAction() { return this.isAction || null != this.actionButtons } ngOnInit() { null != this.container && null != this.container.control && this.container.control instanceof $t.i && (this.formGroup = this.container.control), this.subscribeBusy(), null != this.formGroup && this.isPrimary && this.formService && this.subscribeFormServiceActions(), null != this.formGroup && null == this.formService && console.warn("Pattern reactive forms support missing. Consider importing PatternFormsModule.") } ngOnChanges(t) { this.showAsAction && (this.isPrimary || this.isBusy) && console.error("[@apps/pattern-web/ptrn-button]: action buttons should not be either primary or busy") } ngOnDestroy() { this.unsubscribe$.next(), this.unsubscribe$.complete() } onClick(t) { this.buttonElement.nativeElement.focus(), null != this.formGroup && this.isPrimary && this.formService || this.onAction(t) } onAction(t) { if (0 === this.action.observers.length) return; let e; if (this.action.emit({ mouseEvent: t, formGroup: this.formGroup, busyUntil: t => e = t }), null != e) return this.isBusyActionSubject.next(!0), e = e.pipe(Object(J.a)({ refCount: !0, bufferSize: 1 }), Object(Z.a)(this.unsubscribe$), Object(d.a)(1)), e.subscribe(t => { this.isBusyActionSubject.next(!1), this.complete.emit(t) }), e; this.complete.emit() } onPropertyChange() { this.cdr.markForCheck() } get hasIcon() { return null != this.contentIcon || null != this.icon } get iconSize() { var t; return (null === (t = this.contentIcon) || void 0 === t ? void 0 : t.size) || 16 } subscribeFormServiceActions() { this.formService.actions$.pipe(Object(u.a)(t => "[FormService] FormValidateSubmitAction" === t.type || "[FormService] FormValidateFailureAction" === t.type || "[FormService] FormValidateConfirmAction" === t.type || "[FormService] FormConfirmSubmitAction" === t.type || "[FormService] FormEndProcessingAction" === t.type), Object(Zt.a)(0), Object(Z.a)(this.unsubscribe$)).subscribe(t => { switch (t.type) { case "[FormService] FormValidateSubmitAction": case "[FormService] FormConfirmSubmitAction": this.onAction(); break; case "[FormService] FormValidateFailureAction": this.error.emit({ formGroup: this.formGroup }); break; case "[FormService] FormValidateConfirmAction": this.confirm.emit({ formGroup: this.formGroup }); break; case "[FormService] FormEndProcessingAction": this.complete.emit(t.payload) } }) } subscribeBusy() { this.isBusy$.pipe(Object(Z.a)(this.unsubscribe$), Object(B.a)(), Object(l.a)(0)).subscribe(t => { this._isBusyValue = t, this.cdr.markForCheck() }) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb($t.c, 8), r.Rb(Co, 8), r.Rb(Jo, 8), r.Rb(r.h)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-button"]], contentQueries: function (t, e, n) { if (1 & t && r.Kb(n, ea, 1), 2 & t) { let t; r.xc(t = r.fc()) && (e.contentIcon = t.first) } }, viewQuery: function (t, e) { if (1 & t && r.Nc(ws, 1), 2 & t) { let t; r.xc(t = r.fc()) && (e.buttonElement = t.first) } }, inputs: { busyText: "busyText", responsiveBehavior: "responsiveBehavior", isAction: "isAction", isDisabled: "isDisabled", iconOnly: "iconOnly", isBusy: "isBusy", cssClass: "cssClass", type: "type", isPrimary: "isPrimary", icon: "icon", link: "link", linkTarget: "linkTarget" }, outputs: { action: "action", confirm: "confirm", error: "error", complete: "complete" }, exportAs: ["ptrnButton"], features: [r.Ab], ngContentSelectors: Mn, decls: 9, vars: 2, consts: [[3, "type", "class", "button--has-icon", "button--has-icon@medium-up", "button--primary", "button--action", "button--loading", "button--disabled", "button--icon-only", "button--icon-only@small", "button--text-only@small", "ngClass", "disabled", "click", 4, "ngIf", "ngIfElse"], ["anchorElement", ""], ["buttonContent", ""], ["iconTemplate", ""], ["contentTemplate", ""], [3, "type", "ngClass", "disabled", "click"], ["buttonElement", ""], [4, "ngTemplateOutlet"], [3, "ptrnLink", "target", "ngClass", "isDisabled"], ["class", "button__loading-indicator", 4, "ngIf"], [4, "ngIf"], ["class", "button__text", 3, "innerHTML", 4, "ngIf"], [1, "button__loading-indicator"], [3, "size", "thickness"], [3, "ngTemplateOutlet", 4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet"], [1, "button__text", 3, "innerHTML"], ["class", "button__icon button__icon--has-label", 4, "ngIf"], ["class", "button__icon button__icon--no-label", 4, "ngIf"], [1, "button__text"], [1, "button__icon", "button__icon--has-label"], [3, "icon", "size"], [1, "button__icon", "button__icon--no-label"]], template: function (t, e) { if (1 & t && (r.nc(), r.Gc(0, Os, 3, 25, "button", 0), r.Gc(1, xs, 2, 26, "ng-template", null, 1, r.Hc), r.Gc(3, As, 3, 3, "ng-template", null, 2, r.Hc), r.Gc(5, Ps, 4, 3, "ng-template", null, 3, r.Hc), r.Gc(7, Ds, 1, 0, "ng-template", null, 4, r.Hc)), 2 & t) { const t = r.yc(2); r.oc("ngIf", null == e.link)("ngIfElse", t) } }, directives: function () { return [s.o, s.l, s.s, Lc, uc, ea] }, encapsulation: 2, changeDetection: 0 }), Object(Wt.b)([Xi("onPropertyChange")], t.prototype, "isAction", void 0), Object(Wt.b)([Xi("onPropertyChange")], t.prototype, "isPrimary", void 0), Object(Wt.b)([Xi("onPropertyChange")], t.prototype, "isDisabled", void 0), Object(Wt.b)([Xi("onPropertyChange")], t.prototype, "link", void 0), t })(); function sa(t) { return null == t ? new Date("") : "string" == typeof t || t instanceof String ? function (t, e) { Object(cn.a)(1, arguments); var n = e || {}, s = null == n.additionalDigits ? 2 : an(n.additionalDigits); if (2 !== s && 1 !== s && 0 !== s) throw new RangeError("additionalDigits must be 0, 1 or 2"); if ("string" != typeof t && "[object String]" !== Object.prototype.toString.call(t)) return new Date(NaN); var r, i = pn(t); if (i.date) { var o = fn(i.date, s); r = gn(o.restDateString, o.year) } if (isNaN(r) || !r) return new Date(NaN); var a, c = r.getTime(), l = 0; if (i.time && (l = bn(i.time), isNaN(l) || null === l)) return new Date(NaN); if (!i.timezone) { var u = new Date(c + l), h = new Date(0); return h.setFullYear(u.getUTCFullYear(), u.getUTCMonth(), u.getUTCDate()), h.setHours(u.getUTCHours(), u.getUTCMinutes(), u.getUTCSeconds(), u.getUTCMilliseconds()), h } return a = vn(i.timezone), isNaN(a) ? new Date(NaN) : new Date(c + l + a) }(t) : new Date(t) } var ra = function (t) { return t.Small = "(min-width: 0px) and (max-width: 767px)", t.Medium = "(min-width: 768px) and (max-width: 992px)", t.Large = "(min-width: 993px)", t }({}); function ia() { return window } let oa = (() => { class t { constructor(t, e) { this._platformProvider = t, this.breakpointObserver = e, this._loadedLibraries = {}, this.initBreakpointObserver() } set direction(t) { const e = ia(); null != e && e.document.querySelector("html").setAttribute("dir", t) } get width() { const t = ia(); if (null != t) return t.innerWidth } addEventListener(t, e, n) { const s = ia(); return s ? (s.document.addEventListener(t, e, n), () => { s.document.removeEventListener(t, e) }) : () => { } } scrollToTop() { const t = ia(); null != t && this.scrollToElement(t.document.querySelector("body")) } navigate(t) { const e = ia(); null != e && e.location.assign(t) } goBack() { const t = ia(); null != t && t.history.back() } alert(t) { const e = ia(); null != e && e.alert(t) } getClipboardText(t) { if (null != t.clipboardData) return t.clipboardData.getData("text/plain"); const e = ia(); if (null != e) { const t = e.clipboardData; if (t && t.getData) return t.getData("Text") } return console.warn("Pattern unable to read contents of clipboard, please check any browser security\n                  settings as this could prevent the clipboard from being read"), "" } pasteText(t, e) { this.select(t), this.execCommand("delete"), this.execCommand(this._platformProvider.isMSIE ? "paste" : "insertText", !1, e) } select(t) { if (this._platformProvider.isMobileApple) { const e = ia(); if (null != e) { const n = t.contentEditable, s = t.readOnly; t.contentEditable = "true", t.readOnly = !0; const r = e.document.createRange(); r.selectNodeContents(t); const i = e.document.getSelection(); null != i && (i.removeAllRanges(), i.addRange(r)), t.setSelectionRange(0, 999999), t.contentEditable = n, t.readOnly = s } } else t.select() } print() { if (!this._platformProvider.isChromium || !this.execCommand("print")) { const t = ia(); if (null == t) return !1; t.print() } return !0 } execCommand(t, e, n) { const s = ia(); return null != s && s.document.execCommand(t, e, n) } scrollTo(t, e = !1) { const n = ia(); if (!n) return Promise.resolve(); if (!t) return Promise.reject("Must pass valid selector to scroll to"); "#" !== t[0] && (t = "#" + t), /^\d+$/.test(t[1]) && (t = `#\\3${t[1]} ${t.substr(2)}`); const s = n.document.querySelector(t); if (!s) return Promise.reject(`Element with selector: ${t} does not exist`); let r = s.classList.contains("deferred-emphasis"); return !r && e && (s.classList.add("deferred-emphasis"), r = !0), this.scrollToElement(s).then(() => { r && s.classList.add("deferred-emphasis--active") }) } scrollToPosition(t, e) { const n = ia(); return n ? new Promise(s => { const r = () => { n.pageXOffset === t && n.pageYOffset === e && (n.removeEventListener("scroll", r), s()) }; n.addEventListener("scroll", r), n.scrollTo(t, e) }) : Promise.resolve() } scrollToElement(t, e) { const n = ia(); if (!n || !t) return Promise.resolve(); if (!t) return Promise.resolve(); if (this._platformProvider.isJsDom) return Promise.resolve(); const s = Object.assign(Object.assign({}, { topOffset: -50, focus: !0, smooth: !0 }), e || {}), r = s.topOffset || 0, i = this.getScrollableElement(t), o = new Promise(e => { setTimeout(() => { const o = Math.max(t.offsetTop + r, 0); if (null == i) return void e(); const a = "HTML" === i.tagName ? n : i; if ("function" == typeof a.scrollTo && this._platformProvider.supportsSmoothScroll && "IntersectionObserver" in n) { const n = new IntersectionObserver(t => { t[0].intersectionRatio <= 0 || (n.disconnect(), e()) }); n.observe(t), a.scrollTo({ top: o, behavior: s.smooth ? "smooth" : "auto" }) } else { console.warn("Using legacy scrolling"); try { i && (s.smooth ? this.smoothScroll(i, o).then(() => e()) : (i.scrollTop = o, e())) } catch (c) { console.warn(c) } } }, 0) }); return s.focus && (n.document.activeElement && n.document.activeElement.blur(), setTimeout(() => { const e = this.findFocusableElement(t); e && e.focus({ preventScroll: !0 }) }, s.smooth ? 500 : 10)), o } get verticalScrollPosition$() { return this.verticalScrollPositionObservable = this.verticalScrollPositionObservable || this.createVerticalScrollObservable(), this.verticalScrollPositionObservable } get windowFocus$() { return this.windowFocusObservable = this.windowFocusObservable || this.createWindowFocusObservable(), this.windowFocusObservable } get isScrolledToBottom() { const t = ia(); return null != t && !!t.document && t.innerHeight + t.scrollY >= t.document.body.offsetHeight } loadResource(t, e, n, s) { const r = ia(); if (!r) return Promise.reject("No window object"); if (!r.document) return Promise.reject("No document object"); const i = (r.document.getElementsByTagName("head") || [])[0]; switch (t) { case "javascript": return this._loadedLibraries[e] || (this._loadedLibraries[e] = new Promise((t, o) => { const a = r.document.createElement("script"); a.src = e, a.type = "text/javascript", a.async = !1, n && (a.integrity = n, a.crossOrigin = "anonymous"), a.onerror = o, a.onload = () => { t(s ? r[s] : void 0) }, i.appendChild(a) })), this._loadedLibraries[e]; case "css": return new Promise((t, s) => { const o = r.document.createElement("link"); o.href = e, o.rel = "stylesheet", o.type = "text/css", n && (o.integrity = n, o.crossOrigin = "anonymous"), o.onerror = s, o.onload = t, i.appendChild(o) }); default: return Promise.reject(`Type ${t} not supported`) } } getNewLegalNoticesClient(t) { const e = ia(); if (e && e.LegalNoticesClient) return new e.LegalNoticesClient(t) } createVerticalScrollObservable() { const t = ia(); return t && t.scroll ? N(t, "scroll").pipe(Object(h.a)(() => t.scrollY || t.pageYOffset)) : Xt.a } createWindowFocusObservable() { const t = ia(); return t ? N(t, "focus") : Xt.a } getScrollableElement(t) { let e = null; return null != t && (e = this.findScrollableParent(t), null == e && (e = this.findMainScrollableElement())), e } findScrollableParent(t) { for (; !this.isScrollable(t) && null != (t = t.parentElement);); return t } findMainScrollableElement() { const t = ia(); if (!t) return null; const e = this.findScrollableChild(t.document.body); return null != e ? e : this.findScrollableParent(t.document.body) } findScrollableChild(t) { let e = null, n = 0; if ("SCRIPT" === t.nodeName) return null; for (; null == e && n < t.childElementCount;) { const s = t.children[n]; if (this.isScrollable(s)) return e = s, s; e = this.findScrollableChild(s), n++ } return e } isScrollable(t) { const e = ia(), n = e ? e.document.documentElement : void 0, s = t.clientHeight < t.scrollHeight, r = "visible" === getComputedStyle(t, void 0).overflow; return s && !r || t.scrollTop > 0 || t === n || t.classList.contains("ptrn-modal-dialog__content") } findFocusableElement(t) { const e = ["a", "input", "button", '[tabindex="-1"]', '[tabindex="0"]'], n = t; return void 0 !== e.find(t => (n.matches || n.matchesSelector || n.mozMatchesSelector || n.msMatchesSelector || n.oMatchesSelector || n.webkitMatchesSelector).call(n, t)) ? t : e.map(e => t.querySelector(e)).find(t => null != t) } smoothScroll(t, e) { const n = ia(); if (!n) return Promise.resolve(); const s = n.performance.now(); let r; r = "function" == typeof n.requestAnimationFrame ? n.requestAnimationFrame : t => setTimeout(t, 15); const i = t.scrollTop; return new Promise(o => { const a = () => { const c = n.performance.now() - s; t.scrollTop = this.position(i, e, c, 500), c <= 500 ? r(a) : o() }; a() }) } position(t, e, n, s) { let r = e; return n <= s && (r = t + (e - t) * this.easeInOutCubic(n / s)), r } easeInOutCubic(t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1 } initBreakpointObserver() { this.breakpoint$ = this.breakpointObserver.observe(`${ra.Small}, ${ra.Medium}, ${ra.Large}`).pipe(Object(u.a)(t => t.matches), Object(h.a)(t => Object.keys(t.breakpoints).find(e => !0 === t.breakpoints[e])), Object(B.a)()) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(Go), r.bc(An)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(Go), Object(r.bc)(An)) }, token: t, providedIn: "root" }), t })(), aa = (() => { class t { constructor(t) { this._elementRef = t } onClick(t) { t.stopPropagation() } triggerClick(t) { this._elementRef.nativeElement.click() } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.l)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["", "ptrnActionTarget", ""]], hostBindings: function (t, e) { 1 & t && r.ec("click", function (t) { return e.onClick(t) }) } }), t })(), ca = (() => { class t { onClick(t, e) { const n = e.tagName.toUpperCase(); "A" !== n && "BUTTON" !== n && "INPUT" !== n && "LABEL" !== n && null != this.targetAction && this.targetAction.triggerClick(e) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = r.Mb({ type: t, selectors: [["", "ptrnActionArea", ""]], contentQueries: function (t, e, n) { if (1 & t && r.Kb(n, aa, 1), 2 & t) { let t; r.xc(t = r.fc()) && (e.targetAction = t.first) } }, hostBindings: function (t, e) { 1 & t && r.ec("click", function (t) { return e.onClick(t, t.target) }) } }), t })(); function la(t, ...e) { return null != t && (t = (t = (t = t.replace(/<!--(.*?)-->/g, "")).replace(e.length > 0 ? new RegExp(`<(?!/?(${e.join("|")})s*/?)[^>]+>`, "g") : /<(?:.|\s)*?>/g, "")).replace(/&nbsp;/g, " ").replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&apos;/g, "'")), t || null } let ua = (() => { class t { constructor(t) { this.translateService = t, this.onLanguageChangeSubject = new i.a, this.unsubscribe = new i.a, this.templateMatcher = /{{\s?([^{}\s]*)\s?}}/g, this.language$ = this.onLanguageChangeSubject.asObservable(), this.isEnabled = !!this.translateService, this.init() } get currentLanguage() { return this.translateService ? this.translateService.currentLang : (console.debug("TranslationService.currentLanguage: ngx-translate not available"), "en") } get(t, e, n = !1) { return this.translateService ? (e = this.transformTranslationParams(e), this.translateService.get(t, e).pipe(Object(h.a)(t => n ? la(t) : t))) : (console.warn("TranslationService.get: ngx-translate not available"), Object(a.a)(t)) } setTranslation(t, e, n) { return this.translateService.setTranslation(t, e, n) } setLanguage(t) { return this.translateService ? this.translateService.use(t) : (console.warn("TranslationService.setLanguage: ngx-translate not available"), Object(a.a)(void 0)) } setDefaultLanguage(t) { this.translateService ? this.translateService.setDefaultLang(t) : console.warn("TranslationService.setDefaultLanguage: ngx-translate not available") } translate(t, e, n = !1) { if (!this.translateService) return console.warn("TranslationService.translate: ngx-translate not available"), t; e = this.transformTranslationParams(e); const s = this.translateService.instant(t, e); return n ? la(s) : s } interpolate(t, e) { return null != this.translateService ? this.translateService.parser.interpolate(t, e) : null != e ? t.replace(this.templateMatcher, (t, n) => { const s = this.getValueFromParams(e, n); return null != s ? s : t }) : t } ngOnDestroy() { this.unsubscribe.next(), this.unsubscribe.complete() } init() { this.isEnabled && this.translateService.onLangChange.pipe(Object(Z.a)(this.unsubscribe)).subscribe(t => this.onLanguageChangeSubject.next({ language: t.lang, translations: t.translations })) } getValueFromParams(t, e) { const n = "string" == typeof e ? e.split(".") : [e]; e = ""; do { e += n.shift(), null == t || null == t[e] || "object" != typeof t[e] && n.length ? n.length ? e += "." : t = void 0 : (t = t[e], e = "") } while (n.length); return t } transformTranslationParams(t) { if (null != t) return Array.isArray(t) ? t.reduce((t, e, n) => (t[`${n + 1}`] = e, t), {}) : "string" == typeof t || "number" == typeof t ? { 1: `${t}` } : t } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(Ln.d, 8)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(Ln.d, 8)) }, token: t, providedIn: "root" }), t })(), ha = (() => { class t { constructor(t) { this.windowService = t, this.popover = new r.n } registerVisible(t) { this.popover.emit(t) } registerClickOutsideListener(t) { const e = e => { !t.popperContent.nativeElement.contains(e.target) && t.isPopperVisible && t.toggleVisibility() }, n = this.windowService.addEventListener("click", e), s = this.windowService.addEventListener("touchend", e); return () => { n(), s() } } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(oa)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(oa)) }, token: t, providedIn: "root" }), t })(); var da = function (t) { return t[t.IDLE = 0] = "IDLE", t[t.UPLOADING = 1] = "UPLOADING", t[t.UPLOADED = 2] = "UPLOADED", t[t.INVALID = 3] = "INVALID", t[t.ERROR = 4] = "ERROR", t }({}); const pa = ["H1", "H2", "H3", "H4", "H5", "H6"], fa = ["notification__title", "ptrn-modal-dialog--title", "smart-heading"].map(t => `:not([class=${t}])`).join(""); let ga = (() => { class t { constructor(t) { this.element = t } get mainElement() { return this.element.nativeElement } queryHeaders() { return pa.map(t => Array.from(this.mainElement.querySelectorAll(`${t}${fa}`))).reduce((t, e) => t.concat(e), []).map(t => ({ element: t, path: this.elementPath(t) })).sort((t, e) => this.compareElementPath(t.path, e.path)) } elementPath(t) { const e = []; let n = t; for (; null != n.parentElement && n !== this.mainElement;)e.push(this.childIndex(n)), n = n.parentElement; return e.reverse() } compareElementPath(t, e) { let n = 0; for (; n < t.length && n < e.length;) { if (t[n] < e[n]) return -1; if (t[n] > e[n]) return 1; n++ } return 0 } childIndex(t) { const e = t.parentElement; return Array.prototype.indexOf.call(null == e ? void 0 : e.children, t) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.l)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["main"]] }), t })(), ma = (() => { class t { constructor(t, e) { this._element = t, this._main = e, this.cssClass = "", this.link = null, this.level = "sibling" } ngOnInit() { this._setHeaderLevel() } _setHeaderLevel() { let t = this.numericLevel, e = 1; const n = this.previousHeader; n && (e = Number(n.tagName.slice(-1))), t = Math.min(Math.max(t || 0, -1), 1), this.headingLevel = Math.min(Math.max(e + t, 2), 6) } get numericLevel() { switch (this.level) { case "parent": return -1; case "sibling": return 0; case "child": return 1 } } get previousHeader() { if (!this._main) return null; const t = this._main.elementPath(this._element.nativeElement), e = this._main.queryHeaders(); let n = null; for (const s of e) { const e = this._main.compareElementPath(s.path, t); if (-1 === e) n = s; else if (1 === e) break } return n || (n = e[e.length - 1]), n ? n.element : null } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.l), r.Rb(ga, 8)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-heading"]], inputs: { cssClass: "cssClass", link: "link", level: "level" }, ngContentSelectors: Mn, decls: 10, vars: 6, consts: [[3, "ngSwitch"], ["class", "smart-heading", 3, "ngClass", 4, "ngSwitchCase"], ["contentWithLink", ""], ["content", ""], [1, "smart-heading", 3, "ngClass"], [4, "ngIf", "ngIfThen", "ngIfElse"], [3, "ptrnLink"], [4, "ngTemplateOutlet"]], template: function (t, e) { 1 & t && (r.nc(), r.Vb(0, 0), r.Gc(1, Fs, 2, 4, "h2", 1), r.Gc(2, Bs, 2, 4, "h3", 1), r.Gc(3, Hs, 2, 4, "h4", 1), r.Gc(4, $s, 2, 4, "h5", 1), r.Gc(5, qs, 2, 4, "h6", 1), r.Ub(), r.Gc(6, Xs, 2, 2, "ng-template", null, 2, r.Hc), r.Gc(8, Zs, 3, 0, "ng-template", null, 3, r.Hc)), 2 & t && (r.oc("ngSwitch", e.headingLevel), r.Cb(1), r.oc("ngSwitchCase", 2), r.Cb(1), r.oc("ngSwitchCase", 3), r.Cb(1), r.oc("ngSwitchCase", 4), r.Cb(1), r.oc("ngSwitchCase", 5), r.Cb(1), r.oc("ngSwitchCase", 6)) }, directives: function () { return [s.q, s.r, s.l, s.o, Lc, s.s] }, encapsulation: 2, changeDetection: 0 }), t })(); const ba = new r.r("pattern.config"), _a = new r.r("pattern.root.config"), va = { "zh-TW": "cmn-hant", "zh-HK": "cmn-hant", "zh-Hant": "cmn-hant", zh: "cmn-hans", "zh-CN": "cmn-hans", "zh-Hans": "cmn-hans" }, ya = { "cmn-hant": "zh-Hant", "cmn-hans": "zh-Hans", no: "nb", "pt-pt": "pt-PT" }; function wa() { return window } let Ca = (() => { class t { constructor(t, e) { this.document = t, this.isBrowser = Object(s.y)(e) } cookieExists(t) { if (!this.isBrowser) return !1; const e = encodeURIComponent(t); let n = this.getCookieRegExp(e), s = n.test(this.document.cookie); return s || (n = this.getCookieRegExp(t), s = n.test(this.document.cookie)), s } getCookie(t) { if (!this.isBrowser) return; const e = encodeURIComponent(t); let n = this.getCookieRegExp(e), s = n.exec(this.document.cookie); return null == s && (n = this.getCookieRegExp(t), s = n.exec(this.document.cookie)), null != s ? this.safeDecodeURIComponent(s[1]) : void 0 } setCookie(t, e, n = "/") { this.isBrowser && (this.document.cookie = `${encodeURIComponent(t)}=${encodeURIComponent(e)};path=${n};`) } removeStorageValue(t, e = "sessionStorage") { const n = wa(); return !!this.storageAvailable(n, e) && (n[e].removeItem(t), !0) } setStorageValue(t, e, n = "sessionStorage") { const s = wa(); return !!this.storageAvailable(s, n) && (s[n].setItem(t, e), !0) } getStorageValue(t, e = "sessionStorage") { const n = wa(); return this.storageAvailable(n, e) ? n[e].getItem(t) : null } storageAvailable(t, e = "sessionStorage") { if (!this.isBrowser || null == t) return !1; const n = t[e], s = "__storage_test__"; try { return n.setItem(s, s), n.removeItem(s), !0 } catch (r) { return r instanceof DOMException && (22 === r.code || 1014 === r.code || "QuotaExceededError" === r.name || "NS_ERROR_DOM_QUOTA_REACHED" === r.name) && 0 !== n.length } } getCookieRegExp(t) { const e = t.replace(/([\[\]\{\}\(\)\|\=\;\+\?\,\.\*\^\$])/gi, "\\$1"); return new RegExp("(?:^" + e + "|;\\s*" + e + ")=(.*?)(?:;|$)", "g") } safeDecodeURIComponent(t) { try { return decodeURIComponent(t) } catch (rl) { return t } } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(s.e), r.bc(r.C)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(s.e), Object(r.bc)(r.C)) }, token: t, providedIn: "root" }), t })(), Oa = (() => { class t { constructor(e, n) { this.window = e, this.config = n, this.supportedLanguages = [t.englishLanguageData], this.supportedLanguageMap = { en: this.supportedLanguages[0] } } init() { return null == this.config.languagesBaseUrl ? Promise.resolve() : this.loadSupportedLanguages("pattern.f356e73c420ef8355e2238328b10418653608293.js", "sha384-MzA0nR2iRsUGCtHaxQrU6jxOZh5ed3y3jGTeEt0SDhXJpVEYRKvqnEn37U/lVDxy") } getSupportedLanguages() { return this.supportedLanguages } getSupportedLanguagesMap() { return this.supportedLanguageMap } loadSupportedLanguages(t, e) { const n = `${this.config.languagesBaseUrl}${t}`; return this.window.loadResource("javascript", n, e, "patternLanguages").then(t => { if (null == t || null == t.default) return void console.warn(`[LanguagesProvider] :: empty language pack returned from ${n}`); const e = t.default.reduce((t, e) => (t.push({ symbol: e[0], direction: e[1], langcode: e[2], name: e[3], vernacularName: e[4], languageGuid: e[5] }), t), []); this.setSupportedLanguages(e) }).catch(t => { console.warn(`[LanguagesProvider] :: error loading langauge pack from ${n}`) }) } setSupportedLanguages(t) { this.supportedLanguages = null != this.config.languages ? t.filter(t => this.config.languages.indexOf(t.symbol) >= 0) : t, this.supportedLanguageMap = this.supportedLanguages.reduce((t, e) => (t[e.symbol] = e, t), {}) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(oa), r.bc(ba)) }, t.englishLanguageData = { symbol: "en", langcode: "E", direction: "ltr", name: "English", vernacularName: "English" }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(oa), Object(r.bc)(ba)) }, token: t, providedIn: "root" }), t })(), Sa = (() => { class t { constructor(t, e, n, s) { this.browserStorage = t, this._languagesProvider = e, this.config = n, this.translationService = s, this.unsubscribe = new i.a, this.readySubject = new qt.a(!1), this.currentLanguageSubject = new qt.a("en"), this.currentLanguageDataSubject = new qt.a(Oa.englishLanguageData), this.ready$ = this.readySubject.asObservable(), this.currentLanguage$ = this.currentLanguageSubject.asObservable().pipe(Object(B.a)()), this.currentLanguageData$ = this.currentLanguageDataSubject.asObservable().pipe(Object(B.a)()), this.translationService.isEnabled && this.translationService.language$.pipe(Object(Z.a)(this.unsubscribe)).subscribe(t => this.onTranslationServiceLanguageChanged(t)) } get currentLanguage() { return this.currentLanguageSubject.value } get currentLanguageData() { return this.currentLanguageDataSubject.value } get isReady() { return this.readySubject.value } init() { var t; const e = this.resolveCurrentLanguage(), n = null !== (t = this.getLanguageData(e)) && void 0 !== t ? t : null; this.currentLanguageSubject.next(e), this.currentLanguageDataSubject.next(n), this.translationService.isEnabled && (this.translationService.setDefaultLanguage("en"), this.translationService.currentLanguage === this.currentLanguage || !this.config.disableLanguageRouting && null != this.config.languagesBaseUrl || this.translationService.setLanguage(this.currentLanguage)), this.readySubject.next(!0) } ngOnDestroy() { this.unsubscribe.next(), this.unsubscribe.complete() } setLanguage(t, e = !1) { const n = this.getLanguageMap()[t]; null != n ? (e && (this.browserStorage.setCookie("ptrn.lang", t), this.browserStorage.setStorageValue("pattern.selectedLanguage", t, "localStorage")), this.addRecentLanguage(t), this.currentLanguage !== t && (this.currentLanguageSubject.next(t), this.currentLanguageDataSubject.next(n)), this.translationService.isEnabled && this.translationService.currentLanguage !== this.currentLanguage && this.translationService.setLanguage(this.currentLanguage)) : console.warn(`Language code ${t} is not included in the supported languages of this application`) } addRecentLanguage(t) { var e; let n; n = (null !== (e = JSON.parse(this.browserStorage.getStorageValue("ptrn.langsRecent"))) && void 0 !== e ? e : []).filter(e => e !== t), n.unshift(t), n.length = Math.min(n.length, 4), this.browserStorage.setStorageValue("ptrn.langsRecent", JSON.stringify(n)) } getRecentLanguages() { var t; let e, n; e = null !== (t = JSON.parse(this.browserStorage.getStorageValue("ptrn.langsRecent"))) && void 0 !== t ? t : [this.currentLanguage]; const s = this._languagesProvider.getSupportedLanguagesMap(); return n = e.filter(t => null != s[t]).map(t => s[t]), n } getLanguageSymbols() { return Object.keys(this._languagesProvider.getSupportedLanguagesMap()) } getLanguages() { return this._languagesProvider.getSupportedLanguages() } getLanguageMap() { return this._languagesProvider.getSupportedLanguagesMap() } getBrowserLanguage(t = !0) { if (null == window || null == window.navigator) return "en"; const e = window.navigator; let n = window.navigator.languages ? window.navigator.languages[0] : null; return n = n || e.language || e.browserLanguage || e.userLanguage || "en", va[n] ? va[n] : (t && (-1 !== n.indexOf("-") ? n = n.split("-")[0] : -1 !== n.indexOf("_") && (n = n.split("_")[0])), n) } getLanguageData(t) { return this._languagesProvider.getSupportedLanguagesMap()[t] } onTranslationServiceLanguageChanged(t) { var e; const n = null !== (e = this.browserStorage.getCookie("ptrn.lang")) && void 0 !== e ? e : this.browserStorage.getStorageValue("pattern.selectedLanguage", "localStorage"); null != t && t.language !== n && this.setLanguage(t.language, !1) } resolveCurrentLanguage() { var t; const e = null !== (t = this.browserStorage.getCookie("ptrn.lang")) && void 0 !== t ? t : this.browserStorage.getStorageValue("pattern.selectedLanguage", "localStorage"), n = this.getLanguageMap(); if (null != n[e]) return e; let s = this.getBrowserLanguage(!1); return null != n[s] ? s : null != n[s.toLocaleLowerCase()] ? s.toLocaleLowerCase() : (s = this.getBrowserLanguage(!0), null != n[s] ? s : null != n[s.toLocaleLowerCase()] ? s.toLocaleLowerCase() : "en") } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(Ca), r.bc(Oa), r.bc(ba), r.bc(ua)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(Ca), Object(r.bc)(Oa), Object(r.bc)(ba), Object(r.bc)(ua)) }, token: t, providedIn: "root" }), t })(), xa = (() => { class t { constructor(t, e, n) { this.languageService = t, this.windowService = e, this.config = n, this._localeSubject = new qt.a("en-US"), this._locale$ = this._localeSubject.asObservable() } get localeId() { return this._localeSubject.getValue() } get locale$() { return this._locale$ } getBrowserLocale() { const t = navigator; return (null == t ? "en-US" : t.language || t.browserLanguage || t.systemLanguage || t.userLanguage).replace(/_/g, "-") } resolveLocale() { var t, e; const n = this.languageService.currentLanguage, s = this.languageService.getLanguageData(n); let r = n; null != s && (r = null !== (e = null !== (t = ya[s.symbol]) && void 0 !== t ? t : s.macroLanguage) && void 0 !== e ? e : n); const i = new RegExp(/-[a-zA-Z]+$/), o = i.exec(this.getBrowserLocale()); return i.test(r) || null == o ? r : r + o[0] } getLocaleData() { return this.windowService.loadResource("javascript", `${this.config.localesBaseUrl}pattern-locales.ab3daac06d5f8493250f.js`, "sha384-ftXqZwkXuX7S+OI8zmUMdNM78H9fH24wVX6rjdNtGg+1sEtzRJZM5cmZS8TmPpX2", "patternLocales").then(t => { if (null == t || null == t.default) throw new Error("Empty patternLocales library returned."); return t.default }) } initializeLocale() { return this.config ? this._loadLocalePromise = new Promise(t => { const e = this.resolveLocale(); return "en-US" === e ? ("en-US" !== this.localeId && this._localeSubject.next("en-US"), console.debug("CultureProvider :: Locale set to default [en-US]"), void t()) : null == this.config.localesBaseUrl ? (console.warn(`CultureProvider :: Cannot load locale ${e}, localesBaseUrl is not defined on PatternConfiguration`), void t()) : void this.getLocaleData().then(n => { let r = 0, i = n[e]; const o = t => (r++, t && t.indexOf("-") >= 0 ? (t = t.replace(/-[a-zA-Z]+$/, t => ""), n[t] ? (console.debug(`CultureProvider :: Locale [${t}] found in ${r} attempts.`), i = n[t], t) : (console.debug(`CultureProvider :: Locale [${t}] not found.`), o(t))) : (console.debug("CultureProvider :: Locale resolved to [en]"), i = n.en, "en-US")); null == i ? (console.debug(`CultureProvider :: Locale [${e}] not available, resolving to generic.`), this._localeSubject.next(o(e))) : (console.debug(`CultureProvider :: Locale resolved to [${e}]`), this._localeSubject.next(e)), Object(s.z)(i.default), t() }).catch(n => { console.warn(`CultureProvider :: Error loading pattern-locales from ${this.config.localesBaseUrl} for ${e}`, n.message), t() }).catch(n => { console.warn(`CultureProvider :: Error loading parent locale for ${e}`, n.message), t() }) }) : Promise.resolve() } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(Sa), r.bc(oa), r.bc(ba)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(Sa), Object(r.bc)(oa), Object(r.bc)(ba)) }, token: t, providedIn: "root" }), t })(); const Ea = [{ base: " ", chars: "\xa0" }, { base: "0", chars: "\u07c0" }, { base: "A", chars: "\u24b6\uff21\xc0\xc1\xc2\u1ea6\u1ea4\u1eaa\u1ea8\xc3\u0100\u0102\u1eb0\u1eae\u1eb4\u1eb2\u0226\u01e0\xc4\u01de\u1ea2\xc5\u01fa\u01cd\u0200\u0202\u1ea0\u1eac\u1eb6\u1e00\u0104\u023a\u2c6f" }, { base: "AA", chars: "\ua732" }, { base: "AE", chars: "\xc6\u01fc\u01e2" }, { base: "AO", chars: "\ua734" }, { base: "AU", chars: "\ua736" }, { base: "AV", chars: "\ua738\ua73a" }, { base: "AY", chars: "\ua73c" }, { base: "B", chars: "\u24b7\uff22\u1e02\u1e04\u1e06\u0243\u0181" }, { base: "C", chars: "\u24b8\uff23\ua73e\u1e08\u0106C\u0108\u010a\u010c\xc7\u0187\u023b" }, { base: "D", chars: "\u24b9\uff24\u1e0a\u010e\u1e0c\u1e10\u1e12\u1e0e\u0110\u018a\u0189\u1d05\ua779" }, { base: "Dh", chars: "\xd0" }, { base: "DZ", chars: "\u01f1\u01c4" }, { base: "Dz", chars: "\u01f2\u01c5" }, { base: "E", chars: "\u025b\u24ba\uff25\xc8\xc9\xca\u1ec0\u1ebe\u1ec4\u1ec2\u1ebc\u0112\u1e14\u1e16\u0114\u0116\xcb\u1eba\u011a\u0204\u0206\u1eb8\u1ec6\u0228\u1e1c\u0118\u1e18\u1e1a\u0190\u018e\u1d07" }, { base: "F", chars: "\ua77c\u24bb\uff26\u1e1e\u0191\ua77b" }, { base: "G", chars: "\u24bc\uff27\u01f4\u011c\u1e20\u011e\u0120\u01e6\u0122\u01e4\u0193\ua7a0\ua77d\ua77e\u0262" }, { base: "H", chars: "\u24bd\uff28\u0124\u1e22\u1e26\u021e\u1e24\u1e28\u1e2a\u0126\u2c67\u2c75\ua78d" }, { base: "I", chars: "\u24be\uff29\xcc\xcd\xce\u0128\u012a\u012c\u0130\xcf\u1e2e\u1ec8\u01cf\u0208\u020a\u1eca\u012e\u1e2c\u0197" }, { base: "J", chars: "\u24bf\uff2a\u0134\u0248\u0237" }, { base: "K", chars: "\u24c0\uff2b\u1e30\u01e8\u1e32\u0136\u1e34\u0198\u2c69\ua740\ua742\ua744\ua7a2" }, { base: "L", chars: "\u24c1\uff2c\u013f\u0139\u013d\u1e36\u1e38\u013b\u1e3c\u1e3a\u0141\u023d\u2c62\u2c60\ua748\ua746\ua780\u043b" }, { base: "LJ", chars: "\u01c7" }, { base: "Lj", chars: "\u01c8" }, { base: "M", chars: "\u24c2\uff2d\u1e3e\u1e40\u1e42\u2c6e\u019c\u03fb" }, { base: "N", chars: "\ua7a4\u0220\u24c3\uff2e\u01f8\u0143\xd1\u1e44\u0147\u1e46\u0145\u1e4a\u1e48\u019d\ua790\u1d0e" }, { base: "NJ", chars: "\u01ca" }, { base: "Nj", chars: "\u01cb" }, { base: "O", chars: "\u24c4\uff2f\xd2\xd3\xd4\u1ed2\u1ed0\u1ed6\u1ed4\xd5\u1e4c\u022c\u1e4e\u014c\u1e50\u1e52\u014e\u022e\u0230\xd6\u022a\u1ece\u0150\u01d1\u020c\u020e\u01a0\u1edc\u1eda\u1ee0\u1ede\u1ee2\u1ecc\u1ed8\u01ea\u01ec\xd8\u01fe\u0186\u019f\ua74a\ua74c" }, { base: "OE", chars: "\u0152" }, { base: "OI", chars: "\u01a2" }, { base: "OO", chars: "\ua74e" }, { base: "OU", chars: "\u0222" }, { base: "P", chars: "\u24c5\uff30\u1e54\u1e56\u01a4\u2c63\ua750\ua752\ua754" }, { base: "Q", chars: "\u24c6\uff31\ua756\ua758\u024a" }, { base: "R", chars: "\u24c7\uff32\u0154\u1e58\u0158\u0210\u0212\u1e5a\u1e5c\u0156\u1e5e\u024c\u2c64\ua75a\ua7a6\ua782" }, { base: "S", chars: "\u24c8\uff33\u1e9e\u015a\u1e64\u015c\u1e60\u0160\u1e66\u1e62\u1e68\u0218\u015e\u2c7e\ua7a8\ua784" }, { base: "T", chars: "\u24c9\uff34\u1e6a\u0164\u1e6c\u021a\u0162\u1e70\u1e6e\u0166\u01ac\u01ae\u023e\ua786" }, { base: "Th", chars: "\xde" }, { base: "TZ", chars: "\ua728" }, { base: "U", chars: "\u24ca\uff35\xd9\xda\xdb\u0168\u1e78\u016a\u1e7a\u016c\xdc\u01db\u01d7\u01d5\u01d9\u1ee6\u016e\u0170\u01d3\u0214\u0216\u01af\u1eea\u1ee8\u1eee\u1eec\u1ef0\u1ee4\u1e72\u0172\u1e76\u1e74\u0244" }, { base: "V", chars: "\u24cb\uff36\u1e7c\u1e7e\u01b2\ua75e\u0245" }, { base: "VY", chars: "\ua760" }, { base: "W", chars: "\u24cc\uff37\u1e80\u1e82\u0174\u1e86\u1e84\u1e88\u2c72" }, { base: "X", chars: "\u24cd\uff38\u1e8a\u1e8c" }, { base: "Y", chars: "\u24ce\uff39\u1ef2\xdd\u0176\u1ef8\u0232\u1e8e\u0178\u1ef6\u1ef4\u01b3\u024e\u1efe" }, { base: "Z", chars: "\u24cf\uff3a\u0179\u1e90\u017b\u017d\u1e92\u1e94\u01b5\u0224\u2c7f\u2c6b\ua762" }, { base: "a", chars: "\u24d0\uff41\u1e9a\xe0\xe1\xe2\u1ea7\u1ea5\u1eab\u1ea9\xe3\u0101\u0103\u1eb1\u1eaf\u1eb5\u1eb3\u0227\u01e1\xe4\u01df\u1ea3\xe5\u01fb\u01ce\u0201\u0203\u1ea1\u1ead\u1eb7\u1e01\u0105\u2c65\u0250\u0251" }, { base: "aa", chars: "\ua733" }, { base: "ae", chars: "\xe6\u01fd\u01e3" }, { base: "ao", chars: "\ua735" }, { base: "au", chars: "\ua737" }, { base: "av", chars: "\ua739\ua73b" }, { base: "ay", chars: "\ua73d" }, { base: "b", chars: "\u24d1\uff42\u1e03\u1e05\u1e07\u0180\u0183\u0253\u0182" }, { base: "c", chars: "\uff43\u24d2\u0107\u0109\u010b\u010d\xe7\u1e09\u0188\u023c\ua73f\u2184" }, { base: "d", chars: "\u24d3\uff44\u1e0b\u010f\u1e0d\u1e11\u1e13\u1e0f\u0111\u018c\u0256\u0257\u018b\u13e7\u0501\ua7aa" }, { base: "dh", chars: "\xf0" }, { base: "dz", chars: "\u01f3\u01c6" }, { base: "e", chars: "\u24d4\uff45\xe8\xe9\xea\u1ec1\u1ebf\u1ec5\u1ec3\u1ebd\u0113\u1e15\u1e17\u0115\u0117\xeb\u1ebb\u011b\u0205\u0207\u1eb9\u1ec7\u0229\u1e1d\u0119\u1e19\u1e1b\u0247\u01dd" }, { base: "f", chars: "\u24d5\uff46\u1e1f\u0192" }, { base: "ff", chars: "\ufb00" }, { base: "fi", chars: "\ufb01" }, { base: "fl", chars: "\ufb02" }, { base: "ffi", chars: "\ufb03" }, { base: "ffl", chars: "\ufb04" }, { base: "g", chars: "\u24d6\uff47\u01f5\u011d\u1e21\u011f\u0121\u01e7\u0123\u01e5\u0260\ua7a1\ua77f\u1d79" }, { base: "h", chars: "\u24d7\uff48\u0125\u1e23\u1e27\u021f\u1e25\u1e29\u1e2b\u1e96\u0127\u2c68\u2c76\u0265" }, { base: "hv", chars: "\u0195" }, { base: "i", chars: "\u24d8\uff49\xec\xed\xee\u0129\u012b\u012d\xef\u1e2f\u1ec9\u01d0\u0209\u020b\u1ecb\u012f\u1e2d\u0268\u0131" }, { base: "j", chars: "\u24d9\uff4a\u0135\u01f0\u0249" }, { base: "k", chars: "\u24da\uff4b\u1e31\u01e9\u1e33\u0137\u1e35\u0199\u2c6a\ua741\ua743\ua745\ua7a3" }, { base: "l", chars: "\u24db\uff4c\u0140\u013a\u013e\u1e37\u1e39\u013c\u1e3d\u1e3b\u017f\u0142\u019a\u026b\u2c61\ua749\ua781\ua747\u026d" }, { base: "lj", chars: "\u01c9" }, { base: "m", chars: "\u24dc\uff4d\u1e3f\u1e41\u1e43\u0271\u026f" }, { base: "n", chars: "\u24dd\uff4e\u01f9\u0144\xf1\u1e45\u0148\u1e47\u0146\u1e4b\u1e49\u019e\u0272\u0149\ua791\ua7a5\u0509" }, { base: "nj", chars: "\u01cc" }, { base: "o", chars: "\u24de\uff4f\xf2\xf3\xf4\u1ed3\u1ed1\u1ed7\u1ed5\xf5\u1e4d\u022d\u1e4f\u014d\u1e51\u1e53\u014f\u022f\u0231\xf6\u022b\u1ecf\u0151\u01d2\u020d\u020f\u01a1\u1edd\u1edb\u1ee1\u1edf\u1ee3\u1ecd\u1ed9\u01eb\u01ed\xf8\u01ff\ua74b\ua74d\u0275\u0254\u1d11" }, { base: "oe", chars: "\u0153" }, { base: "oi", chars: "\u01a3" }, { base: "oo", chars: "\ua74f" }, { base: "ou", chars: "\u0223" }, { base: "p", chars: "\u24df\uff50\u1e55\u1e57\u01a5\u1d7d\ua751\ua753\ua755\u03c1" }, { base: "q", chars: "\u24e0\uff51\u024b\ua757\ua759" }, { base: "r", chars: "\u24e1\uff52\u0155\u1e59\u0159\u0211\u0213\u1e5b\u1e5d\u0157\u1e5f\u024d\u027d\ua75b\ua7a7\ua783" }, { base: "s", chars: "\u24e2\uff53\u015b\u1e65\u015d\u1e61\u0161\u1e67\u1e63\u1e69\u0219\u015f\u023f\ua7a9\ua785\u1e9b\u0282" }, { base: "ss", chars: "\xdf" }, { base: "t", chars: "\u24e3\uff54\u1e6b\u1e97\u0165\u1e6d\u021b\u0163\u1e71\u1e6f\u0167\u01ad\u0288\u2c66\ua787" }, { base: "th", chars: "\xfe" }, { base: "tz", chars: "\ua729" }, { base: "u", chars: "\u24e4\uff55\xf9\xfa\xfb\u0169\u1e79\u016b\u1e7b\u016d\xfc\u01dc\u01d8\u01d6\u01da\u1ee7\u016f\u0171\u01d4\u0215\u0217\u01b0\u1eeb\u1ee9\u1eef\u1eed\u1ef1\u1ee5\u1e73\u0173\u1e77\u1e75\u0289" }, { base: "v", chars: "\u24e5\uff56\u1e7d\u1e7f\u028b\ua75f\u028c" }, { base: "vy", chars: "\ua761" }, { base: "w", chars: "\u24e6\uff57\u1e81\u1e83\u0175\u1e87\u1e85\u1e98\u1e89\u2c73" }, { base: "x", chars: "\u24e7\uff58\u1e8b\u1e8d" }, { base: "y", chars: "\u24e8\uff59\u1ef3\xfd\u0177\u1ef9\u0233\u1e8f\xff\u1ef7\u1e99\u1ef5\u01b4\u024f\u1eff" }, { base: "z", chars: "\u24e9\uff5a\u017a\u1e91\u017c\u017e\u1e93\u1e95\u01b6\u0225\u0240\u2c6c\ua763" }], Ta = {}, ka = {}; for (const il of Ea) { const t = il.chars; for (const e of t) Ta[e] = il.base, il.base.length > 1 && (ka[e] = il.base) } function ja(t) { return t.replace(/[^\u0000-\u007e]/g, t => Ta[t] || t) } class Aa { constructor(t = "en-US", e = { numeric: !0, ignorePunctuation: !0, sensitivity: "base" }) { this.collator = new Intl.Collator(t, e) } compare(t, e) { return this.collator.compare(t, e) } contains(t, e) { const n = ja(e).toLocaleLowerCase(), s = ja(t).toLocaleLowerCase(); return -1 !== n.indexOf(s) } removeDiacritics(t) { return ja(t) } fillSpaceForDiacritics(t) { return function (t) { return t.replace(/[^\u0000-\u007e]/g, t => { const e = ka[t]; return e ? `${t}${"\u237d".repeat(e.length - 1)}` : t }) }(t) } removeSpacesForDiacritics(t) { return function (t) { return t.replace(/\u237D/g, "") }(t) } } new RegExp("__PTRN__WRAPPER__BEGIN__", "g"), new RegExp("__PTRN__WRAPPER__END__", "g"); let Ra = (() => { class t { constructor(t) { this.languageService = t, this.language = "en", this.supportedLanguages = null, this.showFilter = !0, this.labelLanguage = "Language", this.placeholder = "Type or select a language", this.noResults = "No results found.", this.languageChange = new r.n, this.filterText = "", this.bestMatchOptions = { keys: t => [t.name, t.vernacularName, t.symbol], debounceTime: 100 } } get selectedLanguage() { return this._selectedLanguage ? Object.assign(Object.assign({}, this._selectedLanguage), { selected: !0 }) : this._selectedLanguage } ngOnInit() { this.availableLanguages = this._getAvailableLanguages(), this.recentLanguages = this._getRecentLanguages(), this._selectedLanguage = this.availableLanguages.find(t => t.symbol === this.language) } ngOnChanges(t) { null == t.languages && null == t.supportedLanguages || (this.availableLanguages = this._getAvailableLanguages()), null != t.language && null != this.availableLanguages && (this._selectedLanguage = this.availableLanguages.find(t => t.symbol === this.language), this.filterText = ""), this.recentLanguages = this._getRecentLanguages() } changeLanguage(t, e) { t.preventDefault(), this.languageChange.emit(e) } isLanguageSelected(t) { return null != this.selectedLanguage && t.symbol === this.selectedLanguage.symbol } languageTrackBy(t, e) { return e.langcode } _getAvailableLanguages() { var t; const e = null !== (t = this.supportedLanguages) && void 0 !== t ? t : this.languageService.getLanguages(); return null != this.languages ? this.languages.map(t => e.find(e => e.symbol === t)).filter(t => null != t) : e } _getRecentLanguages() { const t = this.languageService.getRecentLanguages(); return null != this.languages ? this.languages.map(e => t.find(t => t.symbol === e)).filter(t => null != t) : t } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(Sa)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-language"]], inputs: { language: "language", supportedLanguages: "supportedLanguages", showFilter: "showFilter", labelLanguage: "labelLanguage", placeholder: "placeholder", noResults: "noResults", languages: "languages" }, outputs: { languageChange: "languageChange" }, features: [r.Ab], decls: 4, vars: 5, consts: [["languageTemplate", ""], ["class", "language", 4, "ngIf"], [1, "grid__item", "grid__item--16", "grid__item--8@medium-up", "grid__item--4@large-up"], ["ptrnActionArea", "", 1, "card", "card--full-height", "card--clickable", "grid", "grid--cross-center", "data", "padding-1"], ["class", "margin-horizontal-05", 4, "ngIf"], [1, "data"], [1, "data__label", 3, "innerHTML"], [1, "data__value", 3, "dir", "innerHTML", "lang"], ["ptrnActionTarget", "", 1, "sr-only", 3, "innerHTML", "click"], [1, "margin-horizontal-05"], ["icon", "check", "cssClass", "g600", 3, "size"], [1, "language"], [1, "field", "margin-bottom-1"], ["for", "languageSearchTerm", 1, "field__label", 3, "innerHTML"], ["autocomplete", "off", "id", "languageSearchTerm", 1, "field__input", "field__input--grow", "container--small", 3, "ngModel", "placeholder", "ngModelChange"], [1, "list", "grid", "grid--wrap-gutter", "grid--no-bleed"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "language__separator"], ["class", "language__no-results", "role", "alert", 3, "innerHTML", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "alert", 1, "language__no-results", 3, "innerHTML"]], template: function (t, e) { 1 & t && (r.Gc(0, Qs, 7, 8, "ng-template", null, 0, r.Hc), r.Gc(2, rr, 11, 12, "div", 1), r.ic(3, "bestMatch")), 2 & t && (r.Cb(2), r.oc("ngIf", r.lc(3, 1, e.availableLanguages, e.filterText, e.bestMatchOptions))) }, directives: function () { return [s.o, ca, nt, aa, ea, $t.d, $t.q, $t.s, s.n, s.s] }, pipes: function () { return [Hc, zc] }, encapsulation: 2, changeDetection: 0 }), t })(), La = (() => { class t { constructor(t) { this.windowService = t, this.languageCode = "E", this.scriptIsLoaded = !1, this.isLoading = !1 } ngAfterViewInit() { this.initialize() } ngOnChanges(t) { this.initialize() } initialize() { return Object(Wt.a)(this, void 0, void 0, function* () { if (this.isLoading) return; this.isLoading = !0; let t, e = Promise.resolve(), n = Promise.resolve(); this.scriptIsLoaded || (e = this.windowService.loadResource("css", "https://code-a.akamaihd.net/legal-notices-client/v1.0.1/css/legal-notices-client.css", "sha384-I0uhARcw4Zatn4J+bFTJQ723tiDOahSUTQQIm0jk77J8MG9/V36xbgFMKT3Ebj7O"), n = this.windowService.loadResource("javascript", "https://code-a.akamaihd.net/legal-notices-client/v1.0.1/js/legal-notices-client.min.js", "sha384-pSneJ8/+u4tM3/7JE4Wp1/7vMDnrZeZmolRaX6HUgE4MbYMuppeBTpCvzrVIZIx7").then(e => { e && "function" == typeof e && (t = e) })); try { yield Promise.all([e, n]).catch(t => console.warn("Error including legal notices client", t)); const s = { languageCode: this.languageCode }; if (this.site && (s.site = this.site), this.baseUrl && (s.baseURL = this.baseUrl), this.languageClassesTemplate && (s.languageClassesTemplate = this.languageClassesTemplate), this.policyDocumentDomain && (s.policyDocumentDomain = this.policyDocumentDomain), this.legalNoticesClientInstance) this.legalNoticesClientInstance && this.legalNoticesClientInstance.setUserConfig(s); else { if (this.legalNoticesClientInstance = t ? new t(s) : this.windowService.getNewLegalNoticesClient(s), !this.legalNoticesClientInstance) throw new Error("Legal notices client is undefined"); yield this.legalNoticesClientInstance.runOnce() } } catch (s) { console.warn("Error loading legal notices client", s) } this.isLoading = !1 }) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(oa)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-legal-notice"]], inputs: { languageCode: "languageCode", site: "site", baseUrl: "baseUrl", policyDocumentDomain: "policyDocumentDomain", languageClassesTemplate: "languageClassesTemplate" }, features: [r.Ab], decls: 0, vars: 0, template: function (t, e) { }, encapsulation: 2, changeDetection: 0 }), t })(), Ia = (() => { class t { constructor() { this.cssClass = "", this.typeLabel = "" } ngOnInit() { this.setIcon() } setIcon() { switch (this.type) { case "error": this.icon = "error-outline"; break; case "warning": this.icon = "warning-outline"; break; case "success": this.icon = "check-circle-outline"; break; case "info": case "note": this.icon = "info" } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-message"]], inputs: { cssClass: "cssClass", typeLabel: "typeLabel", type: "type" }, exportAs: ["ptrnMessage"], ngContentSelectors: Mn, decls: 4, vars: 8, consts: [[3, "icon", "cssClass", "size"], [1, "message__body"]], template: function (t, e) { 1 & t && (r.nc(), r.Xb(0, "p"), r.Sb(1, "ptrn-icon", 0), r.Xb(2, "span", 1), r.mc(3), r.Wb(), r.Wb()), 2 & t && (r.Ib("message message--", e.type, " ", e.cssClass, ""), r.Cb(1), r.qc("cssClass", "message__icon message__icon--", e.type, ""), r.oc("icon", e.icon)("size", 20), r.Db("aria-label", e.typeLabel)) }, directives: [ea], encapsulation: 2, changeDetection: 0 }), t })(), Pa = (() => { class t { constructor() { this.contentClass = !0 } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-modal-content"]], hostVars: 2, hostBindings: function (t, e) { 2 & t && r.Jb("ptrn-modal-dialog__content", e.contentClass) }, exportAs: ["ptrnModalContent"], ngContentSelectors: Mn, decls: 2, vars: 0, consts: [[1, "ptrn-modal-dialog__content-wrapper"]], template: function (t, e) { 1 & t && (r.nc(), r.Xb(0, "div", 0), r.mc(1), r.Wb()) }, encapsulation: 2, changeDetection: 0 }), t })(); class Da { constructor(t, e) { this.onNext = t, this.onClose = e } close(t) { this.onNext(null != t ? t : null), this.onClose() } } const Ma = new r.r("ModalData"), Na = new r.r("ModalRef"); let Fa = (() => { class t { constructor(t) { this.router = t, this.showModal = new qt.a(!1), this.isVisible$ = this.showModal.pipe(Object(B.a)()), this.modalResult$ = null, this.modalOptions = null, this.template = null, this.templateContext = null, this.modalComponent = null, this.providers = null, this.injector = null, this.isVisible$.pipe(Object(u.a)(t => !t && null != this.modalResult$)).subscribe(() => { var t; null === (t = this.modalResult$) || void 0 === t || t.complete(), this.modalResult$ = null, this.modalOptions = null, this.template = null, this.templateContext = null, this.modalComponent = null, this.providers = null, this.injector = null }), this.router.events.pipe(Object(u.a)(t => t instanceof In.e)).subscribe(() => { this.showModal.next(!1) }) } changeVisible(t) { this.showModal.next(t) } open({ componentOrTemplateRef: t, options: e, data: n, injector: s }) { if (this.modalResult$) throw new Error("There is already a site modal opened."); this.modalResult$ = new i.a, this.modalOptions = e; const o = new Da(t => { var e; return null === (e = this.modalResult$) || void 0 === e ? void 0 : e.next(t) }, () => { var t; return null === (t = this.modalResult$) || void 0 === t ? void 0 : t.complete() }); return t instanceof r.N ? (this.template = t, this.templateContext = { data: n, $implicit: o }) : (this.modalComponent = t, this.providers = [{ provide: Ma, useValue: n }, { provide: Na, useValue: o }], this.injector = s), this.showModal.next(!0), this.modalResult$.pipe(function (...t) { return e => Object(Yt.a)(e, Object(a.a)(...t)) }(null), Object(Qt.a)(), Object(Jt.a)(() => this.showModal.next(!1))) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(In.i)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(In.i)) }, token: t, providedIn: "root" }), t })(), Va = (() => { class t { constructor(t, e, n, s) { this.siteModal = t, this.templateRef = e, this.cdr = n, this.injector = s, this.closeAriaLabel = "Close", this.close$ = new i.a } static ngTemplateContextGuard(t, e) { return !0 } open(t) { return this.siteModal.open({ componentOrTemplateRef: this.templateRef, options: { cssClass: this.cssClass, modalTitle: this.modalTitle, canDismiss: this.canDismiss, closeAriaLabel: this.closeAriaLabel }, data: t, injector: this.injector }).pipe(Object(Z.a)(this.close$), Object(Jt.a)(() => this.cdr.markForCheck())) } openAsContainer(t) { return this.siteModal.open({ componentOrTemplateRef: this.templateRef, options: { isContainerElement: !0 }, data: t, injector: this.injector }).pipe(Object(Z.a)(this.close$), Object(Jt.a)(() => this.cdr.markForCheck())) } close() { this.close$.next() } ngOnDestroy() { this.close$.next(), this.close$.complete() } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(Fa), r.Rb(r.N), r.Rb(r.h), r.Rb(r.s)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["ng-template", "ptrnModal", ""]], inputs: { closeAriaLabel: "closeAriaLabel", cssClass: "cssClass", modalTitle: "modalTitle", canDismiss: "canDismiss" }, exportAs: ["ptrnModal"] }), t })(); const Ba = new r.r("pattern.container"); var Ua = function (t) { return t.AltLeft = "AltLeft", t.AltRight = "AltRight", t.ArrowDown = "ArrowDown", t.ArrowUp = "ArrowUp", t.ArrowLeft = "ArrowLeft", t.ArrowRight = "ArrowRight", t.CapsLock = "CapsLock", t.ControlLeft = "ControlLeft", t.ControlRight = "ControlRight", t.End = "End", t.Enter = "Enter", t.Escape = "Escape", t.Home = "Home", t.ShiftLeft = "ShiftLeft", t.ShiftRight = "ShiftRight", t.Tab = "Tab", t }({}); let Ha = (() => { class t { constructor(t, e, n) { this.cdr = e, this.renderer = n, this.closeAriaLabel = "Close", this.visibleChange = new r.n, this.document = t, this.bodyElement = this.document.body } registerContent(t) { if (null != this.modalContentTemplate) throw new Error("ptrnContentTemplate already registered. Only one ptrnContentTemplate is allowed. Make sure ptrnContentTemplate is used at the top level if possible and there are no additional nested usages of ptrnContentTemplate."); this.modalContentTemplate = t, this.cdr.markForCheck() } unregisterContent(t) { this.modalContentTemplate === t && (this.modalContentTemplate = void 0, this.cdr.markForCheck()) } registerContainer(t) { if (null != this.modalContainerTemplate) throw new Error("ptrnContainerTemplate already registered. Only one ptrnContainerTemplate is allowed. Make sure ptrnContainerTemplate is used at the top level if possible and there are no additional nested usages of ptrnContainerTemplate."); this.modalContainerTemplate = t, this.cdr.markForCheck() } unregisterContainer(t) { this.modalContainerTemplate === t && (this.modalContainerTemplate = void 0, this.cdr.markForCheck()) } get visible() { return this.isVisible } set visible(t) { if (t !== this.isVisible) { if (t && this.document) this.previouslyFocusedElement = this.document.activeElement, setTimeout(() => { const t = this.bodyElement.querySelector("ptrn-modal-header"); null != t && null != this.dialogElement && (this.renderer.setAttribute(this.dialogElement.nativeElement, "aria-labeledby", t.id), t.focus()) }); else if (!t && this.previouslyFocusedElement) { const t = this.previouslyFocusedElement; "function" == typeof t.focus && setTimeout(() => { t.focus(), this.previouslyFocusedElement = null }) } this.isVisible = t, this.cdr.markForCheck() } } handleKeydown(t) { t.code === Ua.Escape && (this.close(), t.preventDefault()) } ngOnChanges() { this.updateBodyClass() } ngOnDestroy() { this.visible && (this.visible = !1, this.updateBodyClass(), this.visibleChange.emit(!1)) } closeModal() { this.close() } close() { this.visible = !1, this.updateBodyClass(), this.visibleChange.emit(this.visible), this.cdr.markForCheck() } updateBodyClass() { null != this.bodyElement && (!0 === this.visible ? this.bodyElement.classList.add("body--modal-on") : this.bodyElement.classList.remove("body--modal-on")) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(s.e), r.Rb(r.h), r.Rb(r.F)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-modal"]], viewQuery: function (t, e) { if (1 & t && r.Nc(ir, 1), 2 & t) { let t; r.xc(t = r.fc()) && (e.dialogElement = t.first) } }, hostBindings: function (t, e) { 1 & t && r.ec("keydown", function (t) { return e.handleKeydown(t) }, !1, r.Ac) }, inputs: { closeAriaLabel: "closeAriaLabel", visible: "visible", cssClass: "cssClass", modalTitle: "modalTitle", canDismiss: "canDismiss" }, outputs: { visibleChange: "visibleChange" }, exportAs: ["ptrnModal"], features: [r.Bb([{ provide: Ki, useExisting: Object(r.V)(() => t) }, { provide: Ba, useExisting: Object(r.V)(() => t) }]), r.Ab], ngContentSelectors: dr, decls: 2, vars: 2, consts: [["role", "dialog", "class", "ptrn-modal-dialog", "cdkTrapFocus", "", 4, "ngIf"], ["class", "ptrn-modal-overlay", 3, "click", 4, "ngIf"], ["role", "dialog", "cdkTrapFocus", "", 1, "ptrn-modal-dialog"], ["dialogElement", ""], [4, "ngTemplateOutlet"], [3, "ngClass", 4, "ngIf"], [3, "ngClass"], [3, "modalTitle", "canDismiss", "closeAriaLabel"], [1, "ptrn-modal-overlay", 3, "click"]], template: function (t, e) { 1 & t && (r.nc(hr), r.Gc(0, lr, 4, 2, "div", 0), r.Gc(1, ur, 1, 0, "div", 1)), 2 & t && (r.oc("ngIf", e.visible), r.Cb(1), r.oc("ngIf", e.visible)) }, directives: function () { return [s.o, L, s.s, s.l, $a, Pa] }, encapsulation: 2, changeDetection: 0 }), t })(), za = 0, $a = (() => { class t { constructor(t, e) { this.modalComponent = t, this.modalDirective = e, this.headerClass = !0, this.id = "ptrn-modal-" + za++, this.tabindex = "-1" } onClose() { var t, e; null === (t = this.modalComponent) || void 0 === t || t.close(), null === (e = this.modalDirective) || void 0 === e || e.close() } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(Ha, 8), r.Rb(Va, 8)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-modal-header"]], hostVars: 4, hostBindings: function (t, e) { 2 & t && (r.ac("id", e.id)("tabindex", e.tabindex), r.Jb("ptrn-modal-dialog__header", e.headerClass)) }, inputs: { modalTitle: "modalTitle", canDismiss: "canDismiss", closeAriaLabel: "closeAriaLabel" }, exportAs: ["ptrnModalHeader"], ngContentSelectors: Mn, decls: 7, vars: 5, consts: [[1, "ptrn-modal-dialog__header-wrapper"], [1, "ptrn-modal-dialog__heading-wrapper"], ["class", "ptrn-modal-dialog__heading", 3, "innerHTML", 4, "ngIf"], ["class", "ptrn-modal-dialog__heading", 4, "ngIf"], ["type", "button", 1, "ptrn-modal-dialog--close", 3, "hidden", "click"], ["icon", "close", "cssClass", "ptrn-modal-dialog__close-icon g700", 3, "size"], [1, "ptrn-modal-dialog__heading", 3, "innerHTML"], [1, "ptrn-modal-dialog__heading"]], template: function (t, e) { 1 & t && (r.nc(), r.Xb(0, "header"), r.Xb(1, "div", 0), r.Xb(2, "div", 1), r.Gc(3, pr, 1, 1, "h5", 2), r.Gc(4, fr, 2, 0, "h5", 3), r.Wb(), r.Xb(5, "button", 4), r.ec("click", function () { return e.onClose() }), r.Sb(6, "ptrn-icon", 5), r.Wb(), r.Wb(), r.Wb()), 2 & t && (r.Cb(3), r.oc("ngIf", e.modalTitle), r.Cb(1), r.oc("ngIf", !e.modalTitle), r.Cb(1), r.oc("hidden", !e.canDismiss), r.Db("aria-label", e.closeAriaLabel), r.Cb(1), r.oc("size", 32)) }, directives: [s.o, ea], encapsulation: 2, changeDetection: 0 }), t })(), Wa = (() => { class t { constructor(t) { this.windowService = t, this.announce = !0, this.cssClass = "", this.dismissible = !1, this.dismissLabel = "Dismiss notification", this.dismissed = !1, this.level = "sibling", this.notificationTitle = "", this.typeLabel = "", this.dismissedChange = new r.n } ngOnInit() { this.setIcon() } get hasHeading() { return "" !== this.notificationTitle && null != this.notificationTitle } get role() { return this.announce ? "alert" : "section" } onDismiss() { this.dismissed = !0, this.dismissedChange.emit(!0) } setIcon() { switch (this.type) { case "error": this.icon = "error"; break; case "warning": this.icon = "warning"; break; case "success": this.icon = "check-circle"; break; case "info": this.icon = "info"; break; case "reminder": this.icon = "notifications" }this.iconSize$ = this.windowService.breakpoint$.pipe(Object(h.a)(t => t === ra.Small ? null == this.notificationTitle || "" === this.notificationTitle ? 18 : 24 : null == this.notificationTitle || "" === this.notificationTitle ? 24 : 32)) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(oa)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-notification"]], inputs: { announce: "announce", cssClass: "cssClass", dismissible: "dismissible", dismissLabel: "dismissLabel", dismissed: "dismissed", level: "level", notificationTitle: "notificationTitle", typeLabel: "typeLabel", type: "type" }, outputs: { dismissedChange: "dismissedChange" }, exportAs: ["ptrnNotification"], ngContentSelectors: Mn, decls: 3, vars: 1, consts: [["notificationContent", ""], [3, "class", 4, "ngIf"], [1, "notification__header"], ["class", "notification__icon", "role", "img", 4, "ngIf"], ["class", "notification__title", "cssClass", "notification__title-text", 3, "level", 4, "ngIf"], ["class", "notification__body notification__body--without-heading", 4, "ngIf"], ["class", "notification__close", 3, "click", 4, "ngIf"], ["class", "notification__body notification__body--with-heading", 4, "ngIf"], ["role", "img", 1, "notification__icon"], [3, "icon", "size", "cssClass"], ["cssClass", "notification__title-text", 1, "notification__title", 3, "level"], [3, "innerHTML"], [1, "notification__body", "notification__body--without-heading"], [4, "ngTemplateOutlet"], [1, "notification__close", 3, "click"], ["icon", "close", "cssClass", "g900", 3, "size"], [1, "notification__body", "notification__body--with-heading"]], template: function (t, e) { 1 & t && (r.nc(), r.Gc(0, gr, 1, 0, "ng-template", null, 0, r.Hc), r.Gc(2, Or, 7, 10, "section", 1)), 2 & t && (r.Cb(2), r.oc("ngIf", !e.dismissed)) }, directives: function () { return [s.o, ea, ma, s.s] }, pipes: function () { return [zc, s.b] }, encapsulation: 2, changeDetection: 0 }), t })(), qa = (() => { class t extends Qo { constructor(t, e, n, s) { super(n, e, s), this.cdr = t, this.container = e, this.parentField = n, this.formService || console.warn("FieldErrorComponent [WARNING]: Please use the ptrnForm directive on your form") } ngAfterViewInit() { this.subscribeToControlStatus(this.parentFormControl, "errors", t => new Ji(this.path, this.name, t)), this.initializeDisplayStyleObservable("fields", "errors"), this.cdr.detectChanges() } getValidationMessage() { var t; return null === (t = this.messageElement) || void 0 === t ? void 0 : t.nativeElement.innerHTML.trim() } getValidatedElement() { return this.parentField ? null : this.messageElement.nativeElement } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.h), r.Rb(Oo), r.Rb(Zo, 8), r.Rb(Co, 8)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-field-error"]], viewQuery: function (t, e) { if (1 & t && r.Nc(fs, 1), 2 & t) { let t; r.xc(t = r.fc()) && (e.messageElement = t.first) } }, features: [r.Bb([{ provide: Qo, useExisting: Object(r.V)(() => t) }]), r.zb], ngContentSelectors: ms, decls: 8, vars: 5, consts: [[1, "field-messages__message", "field-messages__message--error"], [1, "field-messages__message-icon", "field-messages__message--error-icon"], ["icon", "error-outline", 3, "size"], [3, "cdkObserveContent"], ["msg", ""]], template: function (t, e) { 1 & t && (r.nc(gs), r.Gc(0, Sr, 1, 0, "ng-template"), r.Xb(1, "p", 0), r.ic(2, "async"), r.Xb(3, "span", 1), r.Sb(4, "ptrn-icon", 2), r.Wb(), r.Xb(5, "span", 3, 4), r.ec("cdkObserveContent", function () { return e.onMessageChanged("errors") }), r.mc(7), r.Wb(), r.Wb()), 2 & t && (r.Cb(1), r.Fc("display", r.jc(2, 3, e.display$) ? "" : "none"), r.Cb(3), r.oc("size", 20)) }, directives: [ea, x], pipes: [s.b], encapsulation: 2, changeDetection: 0 }), t })(); class Ga { constructor(t) { this._countries = t, this._phoneUtil = libphonenumber.PhoneNumberUtil.getInstance() } static getInstanceAsync(t, e) { return Object(Wt.a)(this, void 0, void 0, function* () { return this._instancePromise ? (t && t.length > 0 && ((yield this._instancePromise).countries = t), this._instancePromise) : (this._instancePromise = new Promise(n => Object(Wt.a)(this, void 0, void 0, function* () { return yield e.loadResource("javascript", "https://cdh.azureedge.net/libs/google-libphonenumber@3.2.10/dist/libphonenumber.min.js", "sha384-Icz+2NcqeeYqd1BUfaF/PFw5m9r0QMFA3hjV0CwOaL2eYbHaSkPgJFc6cZmzVCS1", "libphonenumber").then(t => t), n(new Ga(t)) })), this._instancePromise) }) } set countries(t) { this._countries = t } get countries() { return this._countries } parse(t, e) { return e && e.code ? this._parseWithCountry(t, e) : this._parseWithoutCountry(t) } _parseWithCountry(t, e) { const n = this._searchCountryByCode(e.code); try { const s = this._phoneUtil.parse(t, null == n ? void 0 : n.code), r = this._phoneUtil.format(s, libphonenumber.PhoneNumberFormat.INTERNATIONAL), i = this._phoneUtil.format(s, libphonenumber.PhoneNumberFormat.NATIONAL); return { countryDialCode: n, internationalNumber: r, nationalNumber: this._getFormattedPhoneNumber(e.code, i), originalNumber: t } } catch (s) { console.warn(`[Pattern] GooglePhoneParser: could not parse ${t}:`, s.message) } return { countryDialCode: n, internationalNumber: `${null == n ? void 0 : n.dialCode} ${t}`.trim(), nationalNumber: t || "", originalNumber: t || "" } } _parseWithoutCountry(t) { if (!t) return null; try { const e = this._phoneUtil.parseAndKeepRawInput(t), n = this._phoneUtil.getRegionCodeForNumber(e) || this._phoneUtil.getRegionCodeForCountryCode(e.getCountryCode()), s = this._searchCountryByCode(n), r = this._phoneUtil.format(e, libphonenumber.PhoneNumberFormat.INTERNATIONAL), i = this._phoneUtil.format(e, libphonenumber.PhoneNumberFormat.NATIONAL); return { countryDialCode: s, internationalNumber: r, nationalNumber: this._getFormattedPhoneNumber(s ? s.code : n, i), originalNumber: t } } catch (e) { console.warn(`[Pattern] GooglePhoneParser: could not parse ${t}:`, e.message) } return { originalNumber: t } } getExampleNumber(t) { let e; if (t && t.code) try { const n = this._phoneUtil.getExampleNumber(t.code); e = this._phoneUtil.format(n, libphonenumber.PhoneNumberFormat.NATIONAL) } catch (n) { console.warn("[Pattern] GooglePhoneParser: no example number for the given country", n.message), e = "" } else e = ""; return e } getDisplayValue(t) { return (null == t ? void 0 : t.internationalNumber) || null } _getFormattedPhoneNumber(t, e) { let n = ""; if (null === t) return e; const s = new libphonenumber.AsYouTypeFormatter(t); e.split("").forEach(t => n = s.inputDigit(t)); try { const e = this._phoneUtil.parse(n, t); if (this._phoneUtil.isValidNumberForRegion(e, t)) return this._phoneUtil.format(e, libphonenumber.PhoneNumberFormat.NATIONAL) } catch (r) { console.warn(`[Pattern] GooglePhoneParser: could not parse or format into the national format ${e}:`, r.message) } return n } _searchCountryByCode(t) { return this._countries.find(e => e.code === t) } } let Xa = (() => { class t { constructor(t, e) { this.cd = t, this.windowService = e, this.formattedPhone = "", this.phone$ = new i.a, this.countries$ = new i.a; const n = this.countries$.pipe(Object(Q.a)(t => Object(Kt.a)(Ga.getInstanceAsync(t, this.windowService)))); this.updateValueSubscription = Object(Gt.a)([n, this.phone$]).subscribe(([t, e]) => this.updateValue(t, e)) } transform(e, n) { return null != e && ("string" == typeof (s = e) || s instanceof String) && e.length ? (n = n || t.EMPTY_COUNTRIES, e === this.lastPhone && n === this.lastCountries || (this.lastPhone !== e && this.phone$.next(e), this.lastCountries !== n && this.countries$.next(n), this.lastPhone = e, this.lastCountries = n), this.formattedPhone) : ""; var s } updateValue(t, e) { const n = t.parse(e), s = null == n ? null : t.getDisplayValue(n); this.formattedPhone = null != s ? s : e, this.cd.markForCheck() } ngOnDestroy() { this.updateValueSubscription.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(r.dc(), r.Rb(oa)) }, t.\u0275pipe = r.Qb({ name: "phone", type: t, pure: !1 }), t.EMPTY_COUNTRIES = [], t })(), Ka = (() => { class t { constructor(t) { this._element = t } get element() { return this._element } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.l)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["", "ptrnPopoverTarget", ""]] }), t })(), Za = (() => { class t { constructor(t, e) { this._renderer = t, this._popoverService = e, this.closeOnClickOutside = !0, this._listeners = [], this.toggleVisibility = t => { t && this.isClickable && this.isPopperVisible && this.popperContent.nativeElement.contains(t.target) ? t.stopPropagation() : (this.isPopperVisible = !this.isPopperVisible, this._setState(), this.isClickable && this._popoverService.registerVisible(this)) }, this._setState = () => { this.isPopperVisible ? this._renderer.removeAttribute(this.popperContent.nativeElement, "hidden") : this._renderer.setAttribute(this.popperContent.nativeElement, "hidden", "true"), this.popper.update() } } set show(t) { this.isPopperVisible = !1 !== t && "false" !== t } set click(t) { this.isClickable = !1 !== t && "false" !== t } set hover(t) { this.canHover = !1 !== t && "false" !== t } onClick(t) { this.closeOnClickOutside && t.stopPropagation() } ngOnInit() { this._init() } ngOnDestroy() { this._listeners.forEach(t => t()), null != this.subscription && this.subscription.unsubscribe() } _init() { const t = this.popoverTarget.element.nativeElement; this.popper = on(t, this.popperContent.nativeElement, { placement: this.placement || "auto", strategy: "fixed" }), this.canHover && (this._listeners.push(this._renderer.listen(t, "mouseenter", this.toggleVisibility)), this._listeners.push(this._renderer.listen(t, "mouseleave", this.toggleVisibility))), this.isClickable && (this._listeners.push(this._renderer.listen(t, "click", this.toggleVisibility)), this.subscription = this._popoverService.popover.subscribe(t => { this.isPopperVisible && t !== this && (this.isPopperVisible = !1, this._setState()) })), this.closeOnClickOutside && this._listeners.push(this._popoverService.registerClickOutsideListener(this)), this._setState() } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.F), r.Rb(ha)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-popover"]], contentQueries: function (t, e, n) { if (1 & t && r.Kb(n, Ka, 3), 2 & t) { let t; r.xc(t = r.fc()) && (e.popoverTarget = t.first) } }, viewQuery: function (t, e) { if (1 & t && r.Nc(Ms, 3), 2 & t) { let t; r.xc(t = r.fc()) && (e.popperContent = t.first) } }, hostBindings: function (t, e) { 1 & t && r.ec("click", function (t) { return e.onClick(t) }) }, inputs: { closeOnClickOutside: "closeOnClickOutside", show: "show", click: "click", hover: "hover", placement: "placement" }, exportAs: ["ptrnPopover"], ngContentSelectors: Er, decls: 5, vars: 0, consts: [[1, "popper"], ["popoverContent", ""], ["data-popper-arrow", "", 1, "popper__arrow"]], template: function (t, e) { 1 & t && (r.nc(xr), r.mc(0), r.Xb(1, "div", 0, 1), r.mc(3, 1), r.Sb(4, "div", 2), r.Wb()) }, encapsulation: 2, changeDetection: 0 }), t })(); function Ya(t, e, n, s) { const r = t.classList; Object.keys(r).filter(t => r[t].indexOf("dir-") > -1 || r[t].indexOf("lang-") > -1).map(t => r[t]).forEach(e => { s.removeClass(t, e) }), e ? (s.addClass(t, `lang-${e}`), t.setAttribute("lang", e)) : t.removeAttribute("lang"), n ? (s.addClass(t, `dir-${n}`), t.setAttribute("dir", n)) : t.removeAttribute("dir") } let Qa = (() => { class t { constructor(t, e) { this.window = t, this.router = e, this.isSideNavOpen$ = new qt.a(!1), this.sideNavBehavior = "sticky", this.breakpoint = ra.Large, this.router.events.pipe(Object(u.a)(t => t instanceof In.g), Object(te.a)(this.window.breakpoint$)).subscribe(([t, e]) => { "open" !== this.sideNavBehavior && e === ra.Large || this.isSideNavOpen$.next(e === ra.Large) }), this.window.breakpoint$.subscribe(t => { this.breakpoint = t, this.isSideNavOpen$.next(t === ra.Large) }) } openSideNav() { this.isSideNavOpen$.next(!0) } closeSideNav(t = !1) { t && this.breakpoint === ra.Large || this.isSideNavOpen$.next(!1) } setSideNavBehavior(t) { this.sideNavBehavior = t } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(oa), r.bc(In.i)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(oa), Object(r.bc)(In.i)) }, token: t, providedIn: "root" }), t })(), Ja = (() => { class t { constructor(t, e) { this.element = t, this.serializer = e, this.modelChange = new r.n, this.initComplete = !1 } ngAfterContentInit() { this.assignModel(), this.initComplete = !0, this.modelChange.emit(this.model) } ngOnChanges(t) { this.initComplete && ((t.link || t.target || t.queryParamsHandling) && this.assignModel(), this.modelChange.emit(this.model)) } ngAfterViewChecked() { null != this.model && this.model.content !== this.content && (this.model.content = this.content || "", this.modelChange.emit(this.model)) } assignModel() { var t, e; const n = { link: this.link, content: this.content || "", isExternal: !1, target: this.target, queryParamsHandling: this.queryParamsHandling || "" }; if (this.link && ("string" == typeof this.link || this.link instanceof String)) if (this.link.startsWith("http")) this.model = Object.assign(Object.assign({}, n), { isExternal: !0, target: this.target || "_blank" }); else { const s = this.serializer.parse(this.link), r = s.queryParams, i = s.fragment || void 0, o = null !== (e = null === (t = s.root.children[In.h]) || void 0 === t ? void 0 : t.segments.map(t => t.path)) && void 0 !== e ? e : []; this.link.startsWith("/") && o.length > 0 && (o[0] = `/${o[0]}`), this.model = Object.assign(Object.assign({}, n), { link: o, queryParams: r, fragment: i }) } else this.model = Object.assign({}, n) } get content() { if (null != this.element && null != this.element.nativeElement) return this.element.nativeElement.textContent } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.l), r.Rb(In.q)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-side-nav-item"]], inputs: { link: "link", target: "target", queryParamsHandling: "queryParamsHandling" }, outputs: { modelChange: "modelChange" }, features: [r.Ab], ngContentSelectors: Mn, decls: 1, vars: 0, template: function (t, e) { 1 & t && (r.nc(), r.mc(0)) }, encapsulation: 2, changeDetection: 0 }), t })(), tc = (() => { class t { constructor(t) { this.siteService = t, this.inputModel$ = new qt.a(null), this.heading$ = new qt.a(void 0) } set heading(t) { this.heading$.next(t) } set model(t) { this.inputModel$.next(t) } ngAfterContentInit() { const t = Object(Gt.a)([this.items.changes.pipe(Object(Y.a)([]), Object(h.a)(() => this.items.toArray()), Object(Q.a)(t => { const e = t.map(t => t.modelChange); return Object(ft.a)(...e).pipe(Object(Y.a)([]), Object(h.a)(() => t)) })), this.heading$]).pipe(Object(h.a)(([t, e]) => ({ heading: e, items: t.map(t => t.model) }))); this.sectionModel$ = Object(Gt.a)([this.inputModel$, t]).pipe(Object(h.a)(([t, e]) => null != t ? t : e)) } routerLinkActiveOptions(t) { let e = ""; return "string" == typeof t || t instanceof String ? e = t : Array.isArray(t) ? e = t.join("/") : t instanceof In.r && (e = t.toString()), { exact: "/" === e } } onSideNavItemClick(t) { t.isActive && this.siteService.closeSideNav(!0) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(Qa)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-side-nav-section"]], contentQueries: function (t, e, n) { if (1 & t && r.Kb(n, Ja, 0), 2 & t) { let t; r.xc(t = r.fc()) && (e.items = t) } }, inputs: { heading: "heading", model: "model" }, decls: 2, vars: 3, consts: [["class", "side-nav__section", 4, "ngIf"], [1, "side-nav__section"], ["class", "side-nav__header", 3, "innerHTML", 4, "ngIf"], [1, "side-nav__items"], ["class", "side-nav__item", "routerLinkActive", "side-nav__item--active", 3, "routerLinkActiveOptions", 4, "ngFor", "ngForOf"], [1, "side-nav__header", 3, "innerHTML"], ["routerLinkActive", "side-nav__item--active", 1, "side-nav__item", 3, "routerLinkActiveOptions"], ["rla", "routerLinkActive"], [4, "ngIf", "ngIfElse"], ["noLinkTmpl", ""], ["externalLinkTmpl", ""], ["class", "side-nav__link", 3, "ptrnLink", "queryParams", "fragment", "target", "queryParamsHandling", "click", 4, "ngIf", "ngIfElse"], [1, "side-nav__link", 3, "ptrnLink", "queryParams", "fragment", "target", "queryParamsHandling", "click"], ["href", "javascript:void(0)", 1, "side-nav__link"], [1, "side-nav__link", 3, "target", "href"]], template: function (t, e) { 1 & t && (r.Gc(0, Ir, 4, 2, "section", 0), r.ic(1, "async")), 2 & t && r.oc("ngIf", r.jc(1, 1, e.sectionModel$)) }, directives: function () { return [s.o, s.n, In.j, Lc] }, pipes: function () { return [s.b] }, encapsulation: 2, changeDetection: 0 }), t })(), ec = (() => { class t { constructor() { this.modelBased = !0 } ngAfterContentInit() { null == this.model && (this.modelBased = !1, this.model = { sections: null == this.sections ? [] : this.sections.map(t => t.model) }) } get resolvedSections() { return this.modelBased ? this.model.sections : this.sections.map(t => t.model) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-side-nav"]], contentQueries: function (t, e, n) { if (1 & t && r.Kb(n, tc, 0), 2 & t) { let t; r.xc(t = r.fc()) && (e.sections = t) } }, inputs: { model: "model" }, ngContentSelectors: Fr, decls: 5, vars: 2, consts: [[1, "side-nav"], [1, "side-nav__arrow"], [4, "ngIf"], [3, "model", 4, "ngFor", "ngForOf"], [3, "model"]], template: function (t, e) { 1 & t && (r.nc(Nr), r.Xb(0, "nav", 0), r.Sb(1, "div", 1), r.mc(2), r.Gc(3, Pr, 1, 0, "ng-content", 2), r.Gc(4, Mr, 2, 1, "ng-container", 2), r.Wb()), 2 & t && (r.Cb(3), r.oc("ngIf", !e.modelBased), r.Cb(1), r.oc("ngIf", e.modelBased)) }, directives: [s.o, s.n, tc], encapsulation: 2, changeDetection: 0 }), t })(), nc = (() => { class t { get routerLink() { return null == this.link || "" === this.link ? null : [this.link] } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-top-nav-branding"]], inputs: { link: "link", title: "title", shortTitle: "shortTitle", jwOrgBranding: "jwOrgBranding" }, ngContentSelectors: Mn, decls: 3, vars: 2, consts: [[4, "ngIf", "ngIfElse"], ["logoTemplate", ""], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 67 50", "width", "65", "height", "48"], ["d", "M0 0h50v50H0z", 1, "theme"], ["d", "M14.19 25.67a4.2 4.2 0 0 0 3.58-1.5 6.36 6.36 0 0 0 1.15-4V8.29H16.7v11.93a4.25 4.25 0 0 1-.7 2.54 2.27 2.27 0 0 1-2 .94 4.09 4.09 0 0 1-1.74-.38 7.87 7.87 0 0 1-1.62-1l-.95 1.75a9 9 0 0 0 1.91 1.15 6.2 6.2 0 0 0 2.54.46M25 25.5h1.9l4.06-12.87 3.63 12.87h1.93l4.19-17.21h-2.29s-2.73 12.42-2.91 13.07L31.9 8.94H30l-3.79 12.42-2.76-13.07h-2.39zM19.75 33.13a5.79 5.79 0 0 0-1-1.88A4.68 4.68 0 0 0 17.12 30a4.75 4.75 0 0 0-2-.43A4.84 4.84 0 0 0 13 30a4.62 4.62 0 0 0-1.6 1.21 5.44 5.44 0 0 0-1 1.9 7.71 7.71 0 0 0-.4 2.51 8.68 8.68 0 0 0 .33 2.47 5.66 5.66 0 0 0 1 1.91 4.54 4.54 0 0 0 1.59 1.25 4.93 4.93 0 0 0 2.16.45 4.8 4.8 0 0 0 2.11-.45A4.63 4.63 0 0 0 18.76 40a5.89 5.89 0 0 0 1-1.93 8.4 8.4 0 0 0 .35-2.48 7.94 7.94 0 0 0-.36-2.46zm-1.22 4.51a5.17 5.17 0 0 1-.77 1.58 3.72 3.72 0 0 1-1.18 1 3.2 3.2 0 0 1-1.5.37 3.15 3.15 0 0 1-1.53-.38 3.72 3.72 0 0 1-1.2-1 5.16 5.16 0 0 1-.76-1.58 7.53 7.53 0 0 1 0-4 4.58 4.58 0 0 1 .76-1.55 3.65 3.65 0 0 1 1.19-1 3.29 3.29 0 0 1 3.07 0 3.55 3.55 0 0 1 1.18 1 5.21 5.21 0 0 1 .76 1.55 7.3 7.3 0 0 1 0 4zM27.19 36.42l.21-.05a4.13 4.13 0 0 0 1.05-.37 3 3 0 0 0 .85-.65 2.91 2.91 0 0 0 .57-.93 3.25 3.25 0 0 0 .21-1.2 3.32 3.32 0 0 0-.33-1.53 3 3 0 0 0-.87-1.05A3.93 3.93 0 0 0 27.6 30a5.54 5.54 0 0 0-1.53-.21h-3.84V41.5h1.25v-4.89h2.37l3.08 4.89h1.52zm-3.71-.89v-4.65H26a3 3 0 0 1 2 .62 2.13 2.13 0 0 1 .78 1.75 2 2 0 0 1-.78 1.69 3.41 3.41 0 0 1-2.11.59zM38.06 41.55a5.44 5.44 0 0 0 1-.32 4.34 4.34 0 0 0 .83-.45q.33-.24.6-.48v-5h-4v1.06h2.81v3.42a4.06 4.06 0 0 1-.9.55 3.33 3.33 0 0 1-1.42.29 3.53 3.53 0 0 1-1.58-.37 3.83 3.83 0 0 1-1.26-1 4.83 4.83 0 0 1-.83-1.56 6.62 6.62 0 0 1-.29-2 6.48 6.48 0 0 1 .29-2 5.31 5.31 0 0 1 .82-1.57 3.89 3.89 0 0 1 1.23-1 3.26 3.26 0 0 1 1.51-.36 3.63 3.63 0 0 1 1.66.36 7.38 7.38 0 0 1 1.17.77l.74-1a5.87 5.87 0 0 0-1.59-.89 5.55 5.55 0 0 0-2-.34 4.92 4.92 0 0 0-3.77 1.71A6.07 6.07 0 0 0 32 33.24a7.07 7.07 0 0 0-.39 2.38 7.86 7.86 0 0 0 .37 2.5A5.64 5.64 0 0 0 33 40a4.84 4.84 0 0 0 1.67 1.22 5.46 5.46 0 0 0 2.17.43 4.91 4.91 0 0 0 1.22-.1zM7.38 39.75h1.75v1.75H7.38z", 1, "logo"], ["d", "M63.56 39.36a5.53 5.53 0 0 0-2.93-2.93 5.54 5.54 0 0 0-4.28 0 5.55 5.55 0 0 0-2.92 2.93 5.57 5.57 0 0 0 0 4.29 5.57 5.57 0 0 0 1.18 1.75 5.67 5.67 0 0 0 1.74 1.17 5.54 5.54 0 0 0 4.28 0 5.71 5.71 0 0 0 1.75-1.17 5.57 5.57 0 0 0 1.18-1.75 5.45 5.45 0 0 0 0-4.29zm-.71 4a4.85 4.85 0 0 1-2.52 2.52 4.72 4.72 0 0 1-1.84.37 4.67 4.67 0 0 1-1.83-.37 4.94 4.94 0 0 1-1.49-1 4.86 4.86 0 0 1-1-1.5 4.74 4.74 0 0 1 0-3.67 4.79 4.79 0 0 1 1-1.51 4.94 4.94 0 0 1 1.49-1 4.67 4.67 0 0 1 1.83-.37 4.72 4.72 0 0 1 1.84.37 4.86 4.86 0 0 1 1.5 1 4.79 4.79 0 0 1 1 1.51 4.74 4.74 0 0 1 0 3.67z", 1, "trademark"], ["d", "M59.53 42.09a1.86 1.86 0 0 0 .82-.55 1.62 1.62 0 0 0 .35-1.09 1.54 1.54 0 0 0-.19-.79 1.64 1.64 0 0 0-.51-.56 2 2 0 0 0-.69-.32 3.18 3.18 0 0 0-.82-.11h-2.1v5.7h1.12v-2.11h.86l1.66 2.11h1.36zm-.3-1.09a1.47 1.47 0 0 1-.81.2h-.89v-1.5h.93a1.37 1.37 0 0 1 .77.19.64.64 0 0 1 .28.56.62.62 0 0 1-.28.55z", 1, "trademark"]], template: function (t, e) { if (1 & t && (r.nc(), r.Gc(0, Vr, 2, 0, "ng-container", 0), r.Gc(1, Br, 11, 0, "ng-template", null, 1, r.Hc)), 2 & t) { const t = r.yc(2); r.oc("ngIf", !e.jwOrgBranding)("ngIfElse", t) } }, directives: [s.o], encapsulation: 2, changeDetection: 0 }), t })(), sc = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-top-nav-extended-branding"]], ngContentSelectors: Mn, decls: 1, vars: 0, template: function (t, e) { 1 & t && (r.nc(), r.mc(0)) }, encapsulation: 2, changeDetection: 0 }), t })(), rc = (() => { class t { constructor(t, e) { this.element = t, this.route = e } get routerLink() { return [this.link] } get content() { return null != this.element && null != this.element.nativeElement ? this.element.nativeElement.innerText : null } get active() { return this.route.isActive(this.link, !1) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.l), r.Rb(In.i)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-top-nav-tab"]], inputs: { link: "link" }, ngContentSelectors: Mn, decls: 1, vars: 0, template: function (t, e) { 1 & t && (r.nc(), r.mc(0)) }, encapsulation: 2, changeDetection: 0 }), t })(), ic = (() => { class t { constructor(t) { this.platform = t, this.isMobile = !1 } ngOnInit() { this.isMobile = this.platform.isMobile } get hasTabs() { return null != this.tabs && this.tabs.length > 0 } get hasExtendedBranding() { return null != this.extendedBranding } get showTitle() { var t, e; return !this.hasTabs && (null != (null === (t = this.branding) || void 0 === t ? void 0 : t.title) || null != (null === (e = this.branding) || void 0 === e ? void 0 : e.shortTitle)) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(Go)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-top-nav"]], contentQueries: function (t, e, n) { if (1 & t && (r.Kb(n, nc, 1), r.Kb(n, sc, 1), r.Kb(n, rc, 0)), 2 & t) { let t; r.xc(t = r.fc()) && (e.branding = t.first), r.xc(t = r.fc()) && (e.extendedBranding = t.first), r.xc(t = r.fc()) && (e.tabs = t) } }, inputs: { hasSideNav: "hasSideNav" }, ngContentSelectors: ti, decls: 16, vars: 12, consts: [[1, "top-nav"], [1, "top-nav__primary-items"], ["for", "side-nav__is-collapsed", 1, "top-nav__branding-label"], ["class", "top-nav__hamburger", 4, "ngIf"], [1, "top-nav__logo"], ["brandingTemplate", ""], ["class", "top-nav__branding", 3, "routerLink", 4, "ngIf"], [4, "ngIf"], ["class", "top-nav__extended-branding", 4, "ngIf"], ["class", "top-nav__title", 3, "innerHTML", 4, "ngIf"], ["class", "top-nav__items", 4, "ngIf"], [1, "top-nav__secondary-items"], [1, "top-nav__hamburger"], ["icon", "menu", "cssClass", "g50 g50-stroke", 3, "size"], [1, "top-nav__branding", 3, "routerLink"], [4, "ngTemplateOutlet"], [1, "top-nav__extended-branding"], [1, "top-nav__title", 3, "innerHTML"], [1, "top-nav__items"], ["class", "top-nav__item", 3, "ngClass", 4, "ngFor", "ngForOf"], [1, "top-nav__item", 3, "ngClass"], [1, "top-nav__link", 3, "routerLink"]], template: function (t, e) { 1 & t && (r.nc(Jr), r.Xb(0, "nav", 0), r.Xb(1, "div", 1), r.Xb(2, "label", 2), r.Gc(3, Ur, 2, 1, "div", 3), r.Xb(4, "div", 4), r.Gc(5, Hr, 1, 0, "ng-template", null, 5, r.Hc), r.Gc(7, Wr, 2, 3, "a", 6), r.Gc(8, Gr, 2, 1, "ng-container", 7), r.Wb(), r.Gc(9, Xr, 2, 0, "div", 8), r.Wb(), r.Gc(10, Kr, 1, 1, "h1", 9), r.Gc(11, Qr, 2, 1, "ul", 10), r.Wb(), r.Xb(12, "aside", 11), r.mc(13), r.mc(14, 1), r.mc(15, 2), r.Wb(), r.Wb()), 2 & t && (r.Cb(2), r.Jb("top-nav__branding-label--trademarked", null == e.branding ? null : e.branding.jwOrgBranding)("top-nav__branding-label--custom-icon", !(null != e.branding && e.branding.jwOrgBranding))("top-nav__branding-label--has-side-nav", e.hasSideNav), r.Cb(1), r.oc("ngIf", e.hasSideNav), r.Cb(4), r.oc("ngIf", !e.hasSideNav), r.Cb(1), r.oc("ngIf", e.hasSideNav), r.Cb(1), r.oc("ngIf", e.hasSideNav || e.hasExtendedBranding), r.Cb(1), r.oc("ngIf", e.showTitle), r.Cb(1), r.oc("ngIf", e.hasTabs)) }, directives: [s.o, ea, In.k, s.s, s.n, s.l], encapsulation: 2 }), t })(), oc = (() => { class t { constructor(t, e, n, s, r, o, c, d, p) { this.window = t, this.router = e, this.serializer = n, this.cdr = s, this.siteService = r, this.renderer = o, this.languageService = c, this.document = d, this.config = p, this.sideNavBehavior = "sticky", this.unsubscribe = new i.a, this.savedVerticalScrollPos = 0, this.hasPrimaryActions = !1, this.routerBusy$ = !0 === p.disableNavigationSpinner ? Object(a.a)(!1) : this.router.events.pipe(Object(u.a)(t => t instanceof In.g || t instanceof In.e || t instanceof In.d || t instanceof In.f), Object(h.a)(t => t instanceof In.g)), this.router.events.pipe(Object(Z.a)(this.unsubscribe), Object(u.a)(t => t instanceof In.e), Object(te.a)(this.window.breakpoint$)).subscribe(([t, e]) => { const n = this.serializer.parse(t.url), s = n.root.hasChildren() ? n.root.children.primary : null; if (s && this.lastNavigatedSegmentGroup) try { if (this.lastNavigatedSegmentGroup.segments.map(t => t.path).join("/") === s.segments.map(t => t.path).join("/")) return } catch (r) { console.warn(`Error parsing url: ${r}`), this.lastNavigatedSegmentGroup = null } this.lastNavigatedSegmentGroup = s }), this.router.events.pipe(Object(Z.a)(this.unsubscribe), Object(u.a)(t => t instanceof In.e && !!this.router.routerState && !!this.router.routerState.root), Object(Q.a)(() => this.router.routerState.root.fragment), Object(B.a)(), Object(u.a)(t => !!t && !this.disableScrollToFragment), Object(Zt.a)(500)).subscribe(t => { this.window.scrollTo(t, !0).catch(t => console.warn("Unable to scroll to fragment :", t)) }), this.shouldShowScrollToTop$ = this.window.verticalScrollPosition$.pipe(Object(Y.a)(0), Object(h.a)(t => this.showScrollToTop && t > 50), Object(B.a)()), this.scrollToTopVisible$ = Object(Gt.a)([this.shouldShowScrollToTop$, this.window.breakpoint$]).pipe(Object(l.a)(500), Object(h.a)(([t, e]) => t && (!this.hasPrimaryActions || e !== ra.Small))) } ngOnInit() { this.siteService.setSideNavBehavior(this.sideNavBehavior), this.siteService.isSideNavOpen$.pipe(Object(Z.a)(this.unsubscribe), Object(te.a)(this.window.breakpoint$.pipe(Object(Y.a)(ra.Large)), this.window.verticalScrollPosition$.pipe(Object(Y.a)(0)))).subscribe(([t, e, n]) => { this.sideNavIsCollapsed = !t, this.sideNavIsCollapsed ? this.window.scrollToPosition(0, this.savedVerticalScrollPos) : this.savedVerticalScrollPos = n, this.cdr.markForCheck() }), this.languageService.currentLanguage$.pipe(Object(Z.a)(this.unsubscribe)).subscribe(t => this.setLanguageAttributes(t)) } ngAfterContentInit() { null != this.topNav && (this.topNav.hasSideNav = this.hasSideNav, this.sideNavs.changes.pipe(Object(Z.a)(this.unsubscribe)).subscribe(() => { this.topNav.hasSideNav = this.hasSideNav, this.cdr.markForCheck() })) } ngOnDestroy() { this.unsubscribe.next() } togglePrimaryActionsBodyClass(t) { this.hasPrimaryActions = t, this.hasPrimaryActions ? this.renderer.addClass(this.document.body, "has-primary-actions") : this.renderer.removeClass(this.document.body, "has-primary-actions") } sideNavOutletActivated(t) { this.sideNavOutletActive = !0, this.topNav.hasSideNav = !0 } sideNavOutletDeactivated(t) { this.sideNavOutletActive = !1, this.topNav.hasSideNav = this.hasSideNav } scrollToTop() { this.window.scrollToTop() } onSideNavCollapseChange(t) { t ? this.siteService.closeSideNav() : this.siteService.openSideNav() } get hasSideNav() { return null != this.sideNavs && this.sideNavs.length > 0 || null != this.sideNavModel || this.sideNavOutletActive } setLanguageAttributes(t) { const e = this.languageService.getLanguageData(t), n = (null == e ? void 0 : e.direction) ? null == e ? void 0 : e.direction : "ltr"; Ya(this.document.documentElement, t, n, this.renderer), Ya(this.document.body, t, n, this.renderer) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(oa), r.Rb(In.i), r.Rb(In.q), r.Rb(r.h), r.Rb(Qa), r.Rb(r.F), r.Rb(Sa), r.Rb(s.e), r.Rb(ba)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-site"]], contentQueries: function (t, e, n) { if (1 & t && (r.Kb(n, ic, 1), r.Kb(n, ec, 0)), 2 & t) { let t; r.xc(t = r.fc()) && (e.topNav = t.first), r.xc(t = r.fc()) && (e.sideNavs = t) } }, inputs: { sideNavBehavior: "sideNavBehavior", sideNavModel: "sideNavModel", disableLegalNotice: "disableLegalNotice", showScrollToTop: "showScrollToTop", disableScrollToFragment: "disableScrollToFragment", scrollToTopLabel: "scrollToTopLabel" }, ngContentSelectors: ui, decls: 17, vars: 11, consts: [[1, "layout", 3, "ngClass"], ["type", "checkbox", "id", "side-nav__is-collapsed", 1, "side-nav__is-collapsed", 3, "ngModel", "ngModelChange"], [1, "layout__content"], [4, "ngIf"], [3, "model", 4, "ngIf"], ["name", "ptrn-side-nav", 3, "activate", "deactivate"], [1, "layout__main"], ["for", "side-nav__is-collapsed"], [1, "site__dimmer"], [4, "ngIf", "ngIfElse"], ["resolvingSpinnerTmpl", ""], [3, "model"], ["name", "ptrn-site-message"], ["type", "button", "class", "button button--icon-only scroll-to-top", 3, "click", 4, "ngIf"], ["type", "button", 1, "button", "button--icon-only", "scroll-to-top", 3, "click"], ["class", "sr-only", 4, "ngIf"], ["icon", "chevron-up", "cssClass", "g50", 3, "size"], [1, "sr-only"], [1, "grid", "grid--no-bleed", "grid--main-center", "grid--cross-center", "spinner__resolving", "spinner--top-nav-offset"], [3, "size", "thickness"]], template: function (t, e) { if (1 & t && (r.nc(ci), r.Xb(0, "section", 0), r.Xb(1, "input", 1), r.ec("ngModelChange", function (t) { return e.sideNavIsCollapsed = t })("ngModelChange", function (t) { return e.onSideNavCollapseChange(t) }), r.Wb(), r.mc(2), r.Xb(3, "section", 2), r.Gc(4, ei, 1, 0, "ng-content", 3), r.Gc(5, ni, 1, 1, "ptrn-side-nav", 4), r.Xb(6, "router-outlet", 5), r.ec("activate", function (t) { return e.sideNavOutletActivated(t) })("deactivate", function (t) { return e.sideNavOutletDeactivated(t) }), r.Wb(), r.Xb(7, "main", 6), r.Xb(8, "label", 7), r.Sb(9, "div", 8), r.Wb(), r.Gc(10, ii, 5, 3, "ng-container", 9), r.ic(11, "async"), r.Gc(12, oi, 3, 4, "ng-template", null, 10, r.Hc), r.Wb(), r.Wb(), r.mc(14, 1), r.Gc(15, ai, 1, 0, "ptrn-legal-notice", 3), r.Wb(), r.Sb(16, "ptrn-site-modal-outlet")), 2 & t) { const t = r.yc(13); r.oc("ngClass", r.tc(9, li, e.hasSideNav)), r.Cb(1), r.oc("ngModel", e.sideNavIsCollapsed), r.Cb(3), r.oc("ngIf", !e.sideNavModel && !e.sideNavOutletActive), r.Cb(1), r.oc("ngIf", !!e.sideNavModel && !e.sideNavOutletActive), r.Cb(5), r.oc("ngIf", !0 !== r.jc(11, 7, e.routerBusy$))("ngIfElse", t), r.Cb(5), r.oc("ngIf", !e.disableLegalNotice) } }, directives: function () { return [s.l, $t.b, $t.q, $t.s, s.o, In.m, ga, Zc, ec, ea, uc, La] }, pipes: function () { return [s.b] }, styles: [".spinner__resolving[_ngcontent-%COMP%] {\n        position: fixed;\n        width: 100%;\n        height: 100%;\n        z-index: -1;\n      }\n\n      .spinner--top-nav-offset[_ngcontent-%COMP%] {\n        margin-top: -48px;\n      }\n\n      .spinner--side-nav-offset[_ngcontent-%COMP%] {\n        margin-left: -110px;\n      }"], data: { animation: [Object(Pn.j)("fadeInAnimation", [Object(Pn.i)(":enter", [Object(Pn.h)({ opacity: 0 }), Object(Pn.e)("300ms ease-in", Object(Pn.h)({ opacity: .85 }))]), Object(Pn.i)(":leave", [Object(Pn.h)({ opacity: .85 }), Object(Pn.e)("300ms ease-out", Object(Pn.h)({ opacity: 0 }))])])] }, changeDetection: 0 }), t })(), ac = 0, cc = (() => { class t { constructor(t, e) { this.parentField = t, this.cdr = e, this.touchFriendly = !1, this.valueChange = new r.n, this._displayValue = null, this._value = null, this._disabled = !1, this._propagateChange = () => { }, this._onTouched = () => { } } set radioElements(t) { this._radioElements = t, this.focusChanges = Object(ft.a)(this._radioElements.map(t => t.focused$)).pipe(Object(ee.a)()), this.applyRadioName(this.name) } set name(t) { this._name = t, this.applyRadioName(this._name) } get name() { var t, e; return null !== (t = this._name) && void 0 !== t ? t : null === (e = this.parentField) || void 0 === e ? void 0 : e.path } set value(t) { this._value !== t && (this._value = t, this.updateState()) } get value() { return this._value } get displayValue() { return this._displayValue } set disabled(t) { this._disabled = t, this.updateState() } get disabled() { return this._disabled } get _elementRef() { return this._radioElements.length > 0 ? this._radioElements.first._elementRef : null } get inputElementRef() { return this._elementRef } get hasLabel() { return null != this.label } ngAfterViewInit() { if (null !== this._value && !this._displayValue) { const t = this._radioElements.find(t => t.value === this._value); this._displayValue = t ? t.displayValue || t.value : null, this.cdr.detectChanges() } this.applyRadioName(this.name) } writeValue(t) { this.value = t } registerOnChange(t) { this._propagateChange = t } registerOnTouched(t) { this._onTouched = t } setDisabledState(t) { this.disabled = t, this.updateState() } applyRadioName(t) { this._radioElements && this._radioElements.forEach(e => { e.applyRadioName(t) }) } updateState() { this._radioElements && this._radioElements.forEach(t => { t.updateState() }) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(So, 8), r.Rb(r.h)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-radio-group"]], contentQueries: function (t, e, n) { if (1 & t && r.Kb(n, lc, 0), 2 & t) { let t; r.xc(t = r.fc()) && (e.radioElements = t) } }, inputs: { touchFriendly: "touchFriendly", name: "name", value: "value", disabled: "disabled", listClass: "listClass", listItemClass: "listItemClass", selectedItemClass: "selectedItemClass", cssClass: "cssClass", label: "label", isInline: "isInline" }, outputs: { valueChange: "valueChange" }, exportAs: ["ptrnRadioGroup"], features: [r.Bb([{ provide: $t.o, useExisting: Object(r.V)(() => t), multi: !0 }])], ngContentSelectors: Mn, decls: 4, vars: 5, consts: [[1, "field__radio-button-list", 3, "ngClass"], ["class", "field__radio-button-list-label", 3, "innerHTML", 4, "ngIf"], [1, "field__selections", 3, "ngClass"], [1, "field__radio-button-list-label", 3, "innerHTML"]], template: function (t, e) { 1 & t && (r.nc(), r.Xb(0, "fieldset", 0), r.Gc(1, hi, 1, 1, "legend", 1), r.Xb(2, "ul", 2), r.mc(3), r.Wb(), r.Wb()), 2 & t && (r.oc("ngClass", e.cssClass), r.Cb(1), r.oc("ngIf", e.hasLabel), r.Cb(1), r.Jb("field__selections--inline", e.isInline), r.oc("ngClass", e.listClass)) }, directives: [s.l, s.o], encapsulation: 2, changeDetection: 0 }), t })(), lc = (() => { class t { constructor(t, e) { this._radioGroup = t, this.cdr = e, this._index = ac++, this._disabled = !1, this._value = null, this.touchFriendly = !1 } set radioInputElement(t) { this._elementRef = t, this.focused$ = Object(ft.a)(N(t.nativeElement, "focus"), N(t.nativeElement, "blur")) } set value(t) { this._value = t } get value() { return this._value } set displayValue(t) { this._displayValue = t } get displayValue() { return this._displayValue || this.labelElement.nativeElement.textContent } set disabled(t) { this._disabled !== t && (this._disabled = t) } get disabled() { return this._disabled || this._radioGroup.disabled } get isInline() { return this._radioGroup.isInline } ngOnInit() { this.touchFriendly = this._radioGroup.touchFriendly } applyRadioName(t) { this._name !== t && (this._name = t, this.cdr.detectChanges()) } updateState() { this.cdr.detectChanges() } get checked() { return this._value === this._radioGroup.value } get itemClasses() { return [this._radioGroup.listItemClass || "", this.checked && this._radioGroup.selectedItemClass || ""] } _onChange(t) { t.stopPropagation(), this._radioGroup && (this._radioGroup.value = this.value, this._radioGroup.valueChange.emit(this.value), this._radioGroup._displayValue = this.displayValue || this.value, this._radioGroup._propagateChange(this.value), this._radioGroup._onTouched()) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(cc), r.Rb(r.h)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-radio-item"]], viewQuery: function (t, e) { if (1 & t && (r.Nc(di, 3), r.Nc(pi, 1)), 2 & t) { let t; r.xc(t = r.fc()) && (e.radioInputElement = t.first), r.xc(t = r.fc()) && (e.labelElement = t.first) } }, hostVars: 2, hostBindings: function (t, e) { 2 & t && r.Jb("list__item", e.isInline) }, inputs: { value: "value", displayValue: "displayValue", disabled: "disabled" }, ngContentSelectors: Mn, decls: 6, vars: 22, consts: [["type", "radio", 3, "id", "checked", "change"], ["radioInputElement", ""], [1, "field__radio-button-label", 3, "for"], ["labelContent", ""]], template: function (t, e) { 1 & t && (r.nc(), r.Xb(0, "li"), r.Xb(1, "input", 0, 1), r.ec("change", function (t) { return e._onChange(t) }), r.Wb(), r.Xb(3, "label", 2, 3), r.mc(5), r.Wb(), r.Wb()), 2 & t && (r.Hb("field__selection ", e.itemClasses.join(" "), ""), r.Cb(1), r.Jb("field__checkbox", !e.touchFriendly)("field__button-input", e.touchFriendly), r.rc("id", "", e._name, "-radio-item-", e._index, ""), r.oc("checked", e.checked), r.Db("disabled", !!e.disabled || null)("name", e._name), r.Cb(2), r.Jb("field__radio-button-label", !e.touchFriendly)("field__button-input-label", e.touchFriendly)("field__button-input-label--radio", e.touchFriendly)("field__radio-button-label--disabled", !e.touchFriendly && e.disabled), r.rc("for", "", e._name, "-radio-item-", e._index, "")) }, encapsulation: 2, changeDetection: 0 }), t })(), uc = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-spinner"]], inputs: { size: "size", thickness: "thickness" }, decls: 2, vars: 10, consts: [[1, "spinner"], [1, "spinner__inner-block"]], template: function (t, e) { 1 & t && (r.Xb(0, "div", 0), r.Sb(1, "div", 1), r.Wb()), 2 & t && (r.Fc("width", e.size, "px")("height", e.size, "px"), r.Cb(1), r.Fc("width", e.size, "px")("height", e.size, "px")("border-width", e.thickness, "px")) }, encapsulation: 2, changeDetection: 0 }), t })(), hc = (() => { class t { constructor(t, e, n) { this.formService = t, this._formGroupDirective = e, this._formGroupName = n, this.alwaysConfirm = !1, this.isBusy = !1, this.success = new r.n, this.confirm = new r.n, this.error = new r.n, this.complete = new r.n, this._submitSubject$ = new i.a, this._unsubscribe$ = new i.a, this._touched = !1 } onSubmit() { this.formService.dispatch(new io), this._submitSubject$.next() } get resolvedFormGroup() { return null != this.formGroup ? this.formGroup : null != this._formGroupDirective ? this.formGroup = this._formGroupDirective.form : null != this._formGroupName ? this.formGroup = this._formGroupName.control : null } ngOnChanges(t) { t.readOnly && this.formService.dispatch(t.readOnly.currentValue ? new ho : new po), t.isBusy && this.formService.dispatch(t.isBusy.currentValue ? new fo : new go) } ngAfterContentInit() { var t; null === (t = this.resolvedFormGroup) || void 0 === t || t.valueChanges.pipe(Object(Z.a)(this._unsubscribe$)).subscribe(t => { var e, n; !(null === (e = this.resolvedFormGroup) || void 0 === e ? void 0 : e.touched) && (null === (n = this.resolvedFormGroup) || void 0 === n ? void 0 : n.pristine) && this.formService.dispatch(new ro) }), this._subscribeSubmitSubject(), this._subscribeFormServiceActions() } ngAfterViewChecked() { null != this.resolvedFormGroup && this.resolvedFormGroup.touched !== this._touched && (this._touched = this.resolvedFormGroup.touched, this.formService.dispatch(this._touched ? new no : new so)) } ngOnDestroy() { this._unsubscribe$.next(), this._unsubscribe$.complete() } _subscribeFormServiceActions() { this.formService.actions$.pipe(Object(u.a)(t => "[FormService] FormValidateAction" === t.type), Object(Zt.a)(1), Object(Q.a)(() => { var t, e, n; return null !== (n = null === (t = this.resolvedFormGroup) || void 0 === t ? void 0 : t.statusChanges.pipe(Object(Y.a)(null === (e = this.resolvedFormGroup) || void 0 === e ? void 0 : e.status), Object(u.a)(t => "PENDING" !== t), Object(d.a)(1))) && void 0 !== n ? n : Xt.a }), Object(te.a)(this.formService.state$), Object(Z.a)(this._unsubscribe$)).subscribe(([t, e]) => { var n; (null === (n = this.resolvedFormGroup) || void 0 === n ? void 0 : n.valid) ? this.alwaysConfirm || this._hasWarnings(e) ? (this.formService.dispatch(new co), this.confirm.emit(this.resolvedFormGroup)) : (this.formService.dispatch(new lo), this.onSuccess()) : (this.formService.dispatch(new ao), this.error.emit(this.resolvedFormGroup)) }) } _subscribeSubmitSubject() { this._submitSubject$.pipe(Object(te.a)(this.formService.state$), Object(Z.a)(this._unsubscribe$)).subscribe(([t, e]) => { e.status === _o.EDIT || e.status === _o.ERROR ? this.formService.dispatch(new oo) : e.status === _o.CONFIRM && (this.formService.dispatch(new uo), this.onSuccess()) }) } _hasWarnings(t) { const e = t.fields || {}, n = t.groups || {}, s = Object.keys(e).some(t => { const n = e[t].warnings || {}; return Object.keys(n).some(t => null != n[t]) }), r = Object.keys(n).some(t => { const e = n[t].warnings || {}; return Object.keys(e).some(t => null != e[t]) }); return s || r } onSuccess() { var t; let e; this.success.emit({ formGroup: null !== (t = this.resolvedFormGroup) && void 0 !== t ? t : void 0, busyUntil: t => e = t }), null != e ? (this.formService.dispatch(new mo), e.pipe(Object(J.a)({ refCount: !0, bufferSize: 1 }), Object(Z.a)(this._unsubscribe$), Object(d.a)(1)).subscribe(t => { this.formService.dispatch(new bo(t)), this.complete.emit(t) })) : this.complete.emit() } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(Co), r.Rb($t.j, 10), r.Rb($t.k, 10)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["form", "formGroup", ""], ["form", "formGroupName", ""], ["", "ptrnForm", ""]], hostBindings: function (t, e) { 1 & t && r.ec("submit", function () { return e.onSubmit() }) }, inputs: { alwaysConfirm: "alwaysConfirm", isBusy: "isBusy", formGroup: ["ptrnForm", "formGroup"], readOnly: "readOnly" }, outputs: { success: "success", confirm: "confirm", error: "error", complete: "complete" }, exportAs: ["ptrnForm"], features: [r.Bb([Co]), r.Ab] }), t })(), dc = (() => { class t { ngOnInit() { var t; switch (null === (t = this.toast) || void 0 === t ? void 0 : t.type) { case "error": this.iconName = "error"; break; case "info": this.iconName = "info"; break; case "success": this.iconName = "check-circle"; break; case "warning": this.iconName = "warning" } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-toast"]], inputs: { toast: "toast" }, exportAs: ["ptrnToast"], decls: 7, vars: 5, consts: [["role", "alert", 1, "ptrn-toast"], [3, "cssClass", "icon", "size"], [1, "ptrn-toast__content-wrapper"], [1, "ptrn-toast__title"], [1, "ptrn-toast__content"]], template: function (t, e) { 1 & t && (r.Xb(0, "div", 0), r.Sb(1, "ptrn-icon", 1), r.Xb(2, "div", 2), r.Xb(3, "h1", 3), r.Ic(4), r.Wb(), r.Xb(5, "p", 4), r.Ic(6), r.Wb(), r.Wb(), r.Wb()), 2 & t && (r.Cb(1), r.qc("cssClass", "ptrn-toast__icon ptrn-toast__icon--", null == e.toast ? null : e.toast.type, ""), r.oc("icon", e.iconName)("size", 24), r.Cb(3), r.Kc(" ", null == e.toast ? null : e.toast.title, " "), r.Cb(2), r.Kc(" ", null == e.toast ? null : e.toast.body, " ")) }, directives: [ea], encapsulation: 2, changeDetection: 0 }), t })(), pc = (() => { class t { constructor(t) { this.translationService = t, this.toastsSubject = new i.a, this.toasts$ = this.toastsSubject.asObservable() } pop(t, e, n, s) { try { const r = this.getToast(t, e, n, s); return this.toastsSubject.next(r), r } catch (r) { return console.error(r), null } } getToast(t, e, n, s) { var r, i, o; const a = "object" == typeof t ? t : { type: t, title: e, body: n }; return { type: a.type, id: null !== (r = a.id) && void 0 !== r ? r : qi(), title: null !== (i = la(this.applyTranslation(a.title, s))) && void 0 !== i ? i : void 0, body: null !== (o = la(this.applyTranslation(a.body, s))) && void 0 !== o ? o : void 0 } } applyTranslation(t, e) { let n = t; return this.translationService.isEnabled && null != n && "" !== n.trim() && (n = this.translationService.translate(n, e)), n || "" } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(ua)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(ua)) }, token: t, providedIn: "root" }), t })(), fc = (() => { class t { constructor(t, e) { this.toasterService = t, this.cd = e, this.toasts = [], this.timeoutIds = new Map } ngOnInit() { this.toastSubscriber = this.toasterService.toasts$.subscribe(t => this.addToast(t)) } ngOnDestroy() { var t; null === (t = this.toastSubscriber) || void 0 === t || t.unsubscribe() } stopTimer(t) { const e = this.toastIdOrDefault(t), n = this.timeoutIds.get(e); n && (window.clearTimeout(n), this.timeoutIds.delete(e)) } restartTimer(t) { this.timeoutIds.get(this.toastIdOrDefault(t)) || this.configureTimer(t) } trackByToastId(t, e) { return null == e ? void 0 : e.id } addToast(t) { this.configureTimer(t), this.toasts.unshift(t), this.cd.markForCheck() } configureTimer(t) { const e = window.setTimeout(() => { this.removeToast(t), this.cd.markForCheck() }, 5e3); this.timeoutIds.set(this.toastIdOrDefault(t), e) } removeToast(t) { const e = this.toasts.indexOf(t); if (e < 0) return; const n = this.toastIdOrDefault(t), s = this.timeoutIds.get(n); this.toasts.splice(e, 1), s && (window.clearTimeout(s), this.timeoutIds.delete(n)) } toastIdOrDefault(t) { return t.id || "" } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(pc), r.Rb(r.h)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-toasts"]], decls: 2, vars: 2, consts: [["id", "toast-container", 1, "toast-bottom-right", "toasts"], [3, "class", "mouseover", "mouseout", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseover", "mouseout"], [3, "toast"]], template: function (t, e) { 1 & t && (r.Xb(0, "div", 0), r.Gc(1, fi, 2, 5, "div", 1), r.Wb()), 2 & t && (r.Cb(1), r.oc("ngForOf", e.toasts)("ngForTrackBy", e.trackByToastId)) }, directives: [s.n, dc], encapsulation: 2, data: { animation: [Object(Pn.j)("toastState", [Object(Pn.g)("flyRight, flyLeft, slideDown, slideUp, fade", Object(Pn.h)({ opacity: 1, transform: "translate(0,0)" })), Object(Pn.i)("void => flyRight", [Object(Pn.h)({ opacity: 0, transform: "translateX(100%)" }), Object(Pn.e)("0.25s ease-in")]), Object(Pn.i)("flyRight => void", [Object(Pn.e)("0.25s 10ms ease-out", Object(Pn.h)({ opacity: 0, transform: "translateX(100%)" }))])])] }, changeDetection: 0 }), t })(); const gc = new RegExp(/^(https?:\/\/|mailto:).+/gi); function mc(t) { var e; return null != t && !!(null === (e = t.match(gc)) || void 0 === e ? void 0 : e.length) } const bc = (t, e) => { if (t.key !== e.key || null == t.params && null != e.params || null != t.params && null == e.params || typeof t.params != typeof e.params) return !1; if (null == t.params && null == e.params) return !0; if (Array.isArray(t.params)) { const n = t.params, s = e.params; for (let t = 0; t < n.length; t++)if (n[t] !== s[t]) return !1 } else { if ("string" == typeof t.params || "number" == typeof t.params) return t.params === e.params; { const n = t.params, s = e.params, r = Object.keys(n), i = Object.keys(s); if (r.length !== i.length) return !1; for (let t = 0; t < r.length; t++)if (n[r[t]] !== s[i[t]]) return !1 } } return !0 }; function _c(t, e) { const n = { language: e.currentLanguage }; return Object(Gt.a)([t.pipe(Object(B.a)(bc)), e.language$.pipe(Object(Y.a)(n))]).pipe(Object(u.a)(([t]) => null != t.key && "" !== t.key.trim()), Object(Q.a)(([t, n]) => e.isEnabled ? null != n.language && null != t.key ? e.get(t.key, t.params) : Object(a.a)(null) : Object(a.a)(t.key)), Object(B.a)()) } let vc = (() => { class t { constructor(t, e, n, s, r, o) { this.elementRef = t, this.translationService = e, this.renderer = n, this.sanitizer = s, this.router = r, this.cdr = o, this.unsubscribe$ = new i.a, this.addedClickListener = !1 } set param(t) { this.params = { 1: t } } ngOnInit() { this.change$ = new qt.a(this.current), _c(this.change$, this.translationService).pipe(Object(Z.a)(this.unsubscribe$)).subscribe(t => { const e = this.sanitizer.sanitize(r.J.HTML, t); null != e && e.indexOf(" href=") > 0 && !this.addedClickListener && (this.addClickListener(), this.addedClickListener = !0), this.renderer.setProperty(this.elementRef.nativeElement, "innerHTML", e ? e.trim() : ""), this.cdr.markForCheck() }) } ngAfterContentInit() { null != this.key && "" !== this.key.trim() || (this.key = this.elementRef.nativeElement.textContent.trim(), this.renderer.setProperty(this.elementRef.nativeElement, "innerHTML", ""), this.change$.next(this.current)) } ngOnChanges(t) { (t.key && !t.key.firstChange || t.param && !t.param.firstChange || t.params && !t.params.firstChange) && null != this.change$ && this.change$.next(this.current) } ngOnDestroy() { this.unsubscribe$.next(), this.unsubscribe$.complete() } get current() { return { key: this.key, params: this.params } } addClickListener() { this.elementRef.nativeElement.addEventListener("click", t => { const e = function (t) { let e = t, n = 0; for (; e && n++ < 3;) { if (e instanceof HTMLAnchorElement) return e; e = e.parentElement } return null }(t.target); if (e) { const n = e.getAttribute("href"); if (!mc(n)) return !!(0 !== t.button || t.ctrlKey || t.shiftKey || t.metaKey) || "" != e.target && "_self" != e.target || (t.preventDefault(), this.router.navigate([n]), !1) } return !0 }) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.l), r.Rb(ua), r.Rb(r.F), r.Rb(Dn.b), r.Rb(In.i), r.Rb(r.h)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-translate"], ["", "ptrnTranslate", ""]], inputs: { param: "param", params: "params", key: ["ptrnTranslate", "key"] }, features: [r.Ab], ngContentSelectors: Mn, decls: 1, vars: 0, template: function (t, e) { 1 & t && (r.nc(), r.mc(0)) }, encapsulation: 2, changeDetection: 0 }), t })(), yc = (() => { class t { constructor() { this.maxResults = null, this.inputChange$ = new i.a, this.resultIndex$ = new qt.a(0), this.selectResult$ = new i.a, this.resultsChange$ = new i.a } get hasResults() { var t; return !!(null === (t = this._results) || void 0 === t ? void 0 : t.length) } selectResult(t, e = !1) { this.selectResult$.next({ index: t, fromClick: e }) } setResultIndex(t) { this.resultIndex$.next(t) } updateInput(t) { this.inputChange$.next(t) } updateResults(t) { this._results = t, this.resultsChange$.next(this._results), this._results.forEach((t, e) => { this.maxResults && (t.show = e <= this.maxResults - 1), t.index = e }) } ngOnDestroy() { this.inputChange$.complete(), this.resultIndex$.complete(), this.selectResult$.complete(), this.resultsChange$.complete() } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = r.Nb({ token: t, factory: t.\u0275fac }), t })(), wc = (() => { class t { constructor(t, e, n) { this.typeaheadService = t, this.element = e, this._cdr = n, this.show = !0, this.markedTextClass = "", this.markText = !0, this.cssClass = "", this._unsubscribe$ = new i.a, this._marked = !1, this._markAllTextContent = (t, e) => { t.childNodes.forEach(n => { var s; if (n.nodeType === Node.TEXT_NODE) { const r = null === (s = n.textContent) || void 0 === s ? void 0 : s.replace(new RegExp(`(${e})`, "gi"), `<mark class="${this.markedTextClass} typeahead-results__marked-text">$1</mark>`), i = document.createElement("span"); i.classList.add("typeahead-results__marked-text-wrapper"), null != r && (i.innerHTML = r), t.replaceChild(i, n) } else this._markAllTextContent(n, e) }) } } get index() { return this._index } set index(t) { this._index = t, this._cdr.detectChanges() } ngAfterContentInit() { this.markText && this._setupResultMarking() } ngOnDestroy() { this._unsubscribe$.next(), this._unsubscribe$.complete() } handleSelectResult() { this.typeaheadService.selectResult(this.index, !0) } _setupResultMarking() { this.typeaheadService.inputChange$.pipe(Object(Z.a)(this._unsubscribe$)).subscribe(t => { if (!this.show) return; const e = this.element.nativeElement.firstElementChild; this._originalContent = this._originalContent || e.firstElementChild.cloneNode(!0), this._marked && e.replaceChild(this._originalContent.cloneNode(!0), e.firstElementChild), this._markAllTextContent(e, t), this._marked = !0 }) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(yc), r.Rb(r.l), r.Rb(r.h)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-typeahead-result"]], inputs: { show: "show", markedTextClass: "markedTextClass", markText: "markText", cssClass: "cssClass", value: "value" }, exportAs: ["ptrnTypeaheadResult"], ngContentSelectors: Mn, decls: 1, vars: 1, consts: [["role", "option", "class", "typeahead-results__item", 3, "id", "ngClass", "active", "click", 4, "ngIf"], ["role", "option", 1, "typeahead-results__item", 3, "id", "ngClass", "click"]], template: function (t, e) { 1 & t && (r.nc(), r.Gc(0, gi, 5, 10, "li", 0)), 2 & t && r.oc("ngIf", e.show) }, directives: [s.o, s.l], pipes: [s.b], encapsulation: 2, changeDetection: 0 }), t })(), Cc = 0, Oc = (() => { class t { constructor(t, e, n, s, o, a, c, l) { this._document = t, this._renderer = e, this._cdr = n, this._window = s, this._platformProvider = o, this._overlay = a, this._vcr = c, this._typeaheadService = l, this._index = Cc++, this.autoResolve = !0, this.debounceTime = 400, this.noResultsText = "No Results", this.typeSearchText = "Type search text above to find results", this.moreResultsText = "More results exist. Type more text to narrow your search results.", this.voiceOverResultsText = "Results are found", this.isBusy = !1, this.scrollableSize = 8, this.maxResults = null, this.browsable = !1, this.cssClass = "", this.search = new r.n, this.itemSelected = new r.n, this.autocompleteValue = "off", this.showDropdownButton = !1, this.showResults = !1, this._resultIndex = 0, this._autoResolveOnNextBlur = !1, this.searchSubject = new qt.a(""), this.search$ = this.searchSubject.asObservable(), this._voiceOverText$ = new i.a, this.voiceOverText$ = this._voiceOverText$.asObservable(), this._hasFocus = !1, this._focusOnSelect = !1, this._showTypeInstruction = !1, this._lastKeyDown = null, this._searchEvent$ = new qt.a(null), this._unsubscribe$ = new i.a, this._shouldCheckResults = !1, this.typeaheadClass = !0, this._typeaheadService.typeaheadIndex = this._index, this._subscribeSearchAndSelection(), this._initializeVoiceOverMessageResetObservable() } get _element() { return this._inputElementRef.nativeElement } set resultIndex(t) { this._resultIndex = t, this._typeaheadService.setResultIndex(this._resultIndex) } get resultIndex() { return this._resultIndex } get inputElementRef() { return this._inputElementRef } get showMoreResultsText() { return !!this.maxResults && this.results.length > this.maxResults } get _resultsLength() { return this.maxResults && this.maxResults < this.results.length ? this.maxResults : this.results.length } onClick(t) { t !== this._inputElementRef.nativeElement && (this._clearTextAndValue(), this.showResults = !1, this._closeOverlay(), this._cdr.markForCheck()) } onWindowResize() { this._overlayRef && this._overlayRef.hasAttached() && this._updateOverlaySize() } ngOnInit() { this.browsable && (this.showDropdownButton = !0), this.placeholder = this.placeholder || "", this._typeaheadService.maxResults = this.maxResults } ngAfterViewInit() { this._overlayRef = this._overlay.create({ hasBackdrop: !1, panelClass: "typeahead-results-container", maxHeight: 42 * this.scrollableSize, scrollStrategy: this._overlay.scrollStrategies.reposition(), positionStrategy: this._getOverlayPosition() }), this._typeaheadService.resultsChange$.pipe(Object(Z.a)(this._unsubscribe$)).subscribe(t => { if (this._autoResolveOnNextBlur = !1, !this._hasFocus || this._showTypeInstruction && !this.browsable) this.showResults = !1, this.isBusy = !1, this._cdr.markForCheck(); else if (0 === t.length) this.showResults = !1, this._openOverlay(this._noResultsBoxTemplate); else if (this.showResults = !0, this._openOverlay(this._resultsBoxTemplate), this.resultIndex = 0, 1 === this.results.length && this.autoResolve) this._autoResolveOnNextBlur = !0; else { const t = this.results.toArray()[0].element.nativeElement.textContent; this._announceVoiceOverMessage(`${this.results.length} ${this.voiceOverResultsText} ${t}`) } }), this._platformProvider.isMobileApple && this._applyIOSPosition() } ngAfterContentChecked() { this._shouldCheckResults && !this.isBusy && this.results && (this._shouldCheckResults = !1, this._typeaheadService.updateResults(this.results.toArray()), this._typeaheadService.updateInput(this._element.value)) } ngOnDestroy() { this._overlayRef && this._overlayRef.dispose(), this._unsubscribe$.next(), this._unsubscribe$.complete() } set value(t) { this._value !== t && (this._value = t, this._propagateChange && this._propagateChange(this._value), this.itemSelected.emit(this._value)) } get value() { return this._value } writeValue(t) { this.value = t, this._setInputElementValue(this.value) } registerOnChange(t) { this._propagateChange = t } registerOnTouched(t) { this._propagateTouched = t } setDisabledState(t) { this.disabled = t, this._cdr.markForCheck() } onFocus(t) { this._hasFocus = !0, this.browsable ? this._focusOnSelect || this._searchEvent$.next("") : this._checkTypeInstruction(), this._element.value && this._window.select(this._element), this._focusOnSelect = !1 } onTouched(t) { this._hasFocus = !1, this.browsable || this._checkTypeInstruction(), null == t.relatedTarget && "Tab" !== this._lastKeyDown || (this._lastKeyDown = null, this._searchEvent$.next(null), this._autoResolveOnNextBlur && this._typeaheadService.hasResults ? this._typeaheadService.selectResult(0) : this._clearTextAndValue(), this.showResults = !1, this._closeOverlay(), this._cdr.markForCheck()), this._propagateTouched && this._propagateTouched(), this._focusOnSelect = !1 } onInput(t) { this._searchEvent$.next(this._element.value), this.browsable || this._checkTypeInstruction() } onDropdownClick(t) { t.stopPropagation(), this._inputElementRef.nativeElement.focus() } onKeydown(t) { const e = t.key; if (this._lastKeyDown = e, "Escape" !== e && "Esc" !== e || (this._clearTextAndValue(!0), this.showResults ? (this.showResults = !1, this._element.focus()) : this._element.blur(), this._closeOverlay()), this._validateKey(e) && this.showResults) { switch (e) { case "Down": case "ArrowDown": if (this.results && this.results.length > 0) { this.resultIndex = (this.resultIndex + 1) % this._resultsLength, this._scrollToResult(); const t = this.results.toArray()[this.resultIndex].element.nativeElement.textContent; this._announceVoiceOverMessage(t) } break; case "Up": case "ArrowUp": if (this.results && this.results.length > 0) { this.resultIndex = 0 === this.resultIndex ? this._resultsLength - 1 : this.resultIndex - 1, this._scrollToResult(); const t = this.results.toArray()[this.resultIndex].element.nativeElement.textContent; this._announceVoiceOverMessage(t) } break; case "Home": { this.resultIndex = 0, this._scrollToResult(); const t = this.results.toArray()[this.resultIndex].element.nativeElement.textContent; this._announceVoiceOverMessage(t); break } case "End": if (this.results && this.results.length > 0) { this.resultIndex = this._resultsLength - 1, this._scrollToResult(); const t = this.results.toArray()[this.resultIndex].element.nativeElement.textContent; this._announceVoiceOverMessage(t) } break; case "Enter": this.results && this.results.length > 0 && this._typeaheadService.selectResult(this.resultIndex) }t.preventDefault(), this._cdr.markForCheck() } } get displayValue() { return this._element.value } _clearTextAndValue(t) { (t || this._element.value !== this._textValue) && (this._element.value = this._textValue = "", this.value = null) } _setInputElementValue(t) { const e = this.displayWith ? this.displayWith(t) : t; this._element.value = this._textValue = null != e ? e : "" } _subscribeSearchAndSelection() { this._searchEvent$.pipe(ne(t => t ? G(this.debounceTime) : Xt.a), Object(Z.a)(this._unsubscribe$)).subscribe(t => { this._shouldCheckResults = !0, this.search.emit(t), this.searchSubject.next(t) }), this._typeaheadService.selectResult$.pipe(Object(Z.a)(this._unsubscribe$)).subscribe(t => { this.value = this.results.toArray()[t.index].value, this._setInputElementValue(this.value), this._autoResolveOnNextBlur ? this._autoResolveOnNextBlur = !1 : (this._focusOnSelect = !0, t.fromClick || this._window.select(this._element)), this.showResults = !1, this._closeOverlay(), this._cdr.markForCheck() }) } _openOverlay(t) { this._overlayRef.detach(); const e = new ut(t, this._vcr); this._overlayRef.attach(e), this._updateOverlaySize(), this.browsable && (this.showDropdownButton = !1, this._cdr.markForCheck()) } _closeOverlay() { this._overlayRef.detach(), this.browsable && (this.showDropdownButton = !0, this._cdr.markForCheck()) } _updateOverlaySize() { const t = this._inputElementRef.nativeElement.getBoundingClientRect(); this._overlayRef.updateSize({ maxHeight: 42 * (this.scrollableSize + (this.showMoreResultsText ? 1 : 0)), width: t.width }) } _checkTypeInstruction() { const t = this._hasFocus && !this._element.value; t !== this._showTypeInstruction && (this._showTypeInstruction = t, this._showTypeInstruction ? this._openOverlay(this._typeInstructionBoxTemplate) : this._closeOverlay()) } _validateKey(t) { switch (t) { case "Down": case "ArrowDown": case "Up": case "ArrowUp": case "Home": case "End": case "Enter": case "Esc": case "Escape": return !0 }return !1 } _getOverlayPosition() { return this._overlay.position().flexibleConnectedTo(this._inputElementRef).setOrigin(this._inputElementRef).withPositions([{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top", offsetY: 0 }, { originX: "start", originY: "top", overlayX: "start", overlayY: "bottom", offsetY: 0 }]).withPush(!1).withGrowAfterOpen(!0).withFlexibleDimensions(!0) } _scrollToResult() { const t = this._overlayRef.overlayElement.firstElementChild; null != t && (t.scrollTop = this._getResultScrollPosition(this.resultIndex, t.scrollHeight / this._resultsLength, t.scrollTop, this._overlayRef.overlayElement.scrollHeight - (this.showMoreResultsText ? 42 : 0))) } _getResultScrollPosition(t, e, n, s) { const r = t * e; return r < n ? r : r > n + s - e ? r + e - s : n } _announceVoiceOverMessage(t) { this._platformProvider.isMobileApple && this._voiceOverText$.next(t) } _initializeVoiceOverMessageResetObservable() { this._platformProvider.isMobileApple && this._voiceOverText$.pipe(Object(Z.a)(this._unsubscribe$), Object(u.a)(t => "" !== t), Object(l.a)(1e3)).subscribe(() => this._voiceOverText$.next("")) } _applyIOSPosition() { const t = this._document.body.querySelector(".cdk-overlay-container"); this._renderer.addClass(t, "typeahead-results-container--ios"), this._overlayRef.getConfig().positionStrategy.positionChanges.pipe(Object(Zt.a)(0), Object(Z.a)(this._unsubscribe$)).subscribe(t => { const e = this._document.body.getBoundingClientRect(), n = this._overlayRef.hostElement.getBoundingClientRect(), s = this._inputElementRef.nativeElement.getBoundingClientRect(); "bottom" === t.connectionPair.originY ? this._overlayRef.hostElement.style.top = `${s.top - e.top + s.height}px` : "top" === t.connectionPair.originY && (this._overlayRef.hostElement.style.top = s.top - e.top - n.height + "px") }) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(s.e), r.Rb(r.F), r.Rb(r.h), r.Rb(oa), r.Rb(Go), r.Rb(Ut), r.Rb(r.R), r.Rb(yc)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-typeahead"]], contentQueries: function (t, e, n) { if (1 & t && r.Kb(n, wc, 0), 2 & t) { let t; r.xc(t = r.fc()) && (e.results = t) } }, viewQuery: function (t, e) { if (1 & t && (r.Nc(mi, 3), r.Nc(bi, 3), r.Nc(_i, 3), r.Nc(vi, 3)), 2 & t) { let t; r.xc(t = r.fc()) && (e._typeInstructionBoxTemplate = t.first), r.xc(t = r.fc()) && (e._noResultsBoxTemplate = t.first), r.xc(t = r.fc()) && (e._resultsBoxTemplate = t.first), r.xc(t = r.fc()) && (e._inputElementRef = t.first) } }, hostVars: 2, hostBindings: function (t, e) { 1 & t && r.ec("click", function (t) { return e.onClick(t.target) }, !1, r.zc)("resize", function () { return e.onWindowResize() }, !1, r.Ac), 2 & t && r.Jb("typeahead", e.typeaheadClass) }, inputs: { autoResolve: "autoResolve", debounceTime: "debounceTime", noResultsText: "noResultsText", typeSearchText: "typeSearchText", moreResultsText: "moreResultsText", voiceOverResultsText: "voiceOverResultsText", isBusy: "isBusy", scrollableSize: "scrollableSize", maxResults: "maxResults", browsable: "browsable", cssClass: "cssClass", placeholder: "placeholder", disabled: "disabled", displayWith: "displayWith" }, outputs: { search: "search", itemSelected: "itemSelected" }, exportAs: ["ptrnTypeahead"], features: [r.Bb([{ provide: $t.o, useExisting: Object(r.V)(() => t), multi: !0 }, yc])], ngContentSelectors: Ei, decls: 15, vars: 18, consts: [["role", "combobox", "aria-haspopup", "listbox", 3, "ngClass"], ["type", "text", "aria-autocomplete", "list", 1, "field__input", "field__input--grow", 3, "placeholder", "disabled", "autocomplete", "focus", "blur", "input", "keydown"], ["typeaheadInput", ""], [1, "typeahead__spinner", 3, "hidden", "size", "thickness"], ["icon", "chevron-down", "cssClass", "clickable p700 typeahead__icon", 3, "size", "click", 4, "ngIf"], ["aria-live", "assertive", 1, "typeahead-voiceover-text"], ["typeInstructionBox", ""], ["noResultsBox", ""], ["resultsBox", ""], ["icon", "chevron-down", "cssClass", "clickable p700 typeahead__icon", 3, "size", "click"], ["role", "alert", 1, "typeahead-results", "typeahead-results--empty", 3, "id", "innerHTML"], ["role", "listbox", 1, "typeahead-results", 3, "id"], ["role", "alert", "class", "typeahead-results typeahead-results--more-results", 3, "innerHTML", 4, "ngIf"], ["role", "alert", 1, "typeahead-results", "typeahead-results--more-results", 3, "innerHTML"]], template: function (t, e) { 1 & t && (r.nc(xi), r.Xb(0, "div", 0), r.Xb(1, "input", 1, 2), r.ec("focus", function (t) { return e.onFocus(t) })("blur", function (t) { return e.onTouched(t) })("input", function (t) { return e.onInput(t) })("keydown", function (t) { return e.onKeydown(t) }), r.ic(3, "stripHtml"), r.Wb(), r.Sb(4, "ptrn-spinner", 3), r.Gc(5, yi, 1, 1, "ptrn-icon", 4), r.Xb(6, "div", 5), r.Ic(7), r.ic(8, "async"), r.Wb(), r.Wb(), r.Gc(9, wi, 1, 2, "ng-template", null, 6, r.Hc), r.Gc(11, Ci, 1, 2, "ng-template", null, 7, r.Hc), r.Gc(13, Si, 3, 2, "ng-template", null, 8, r.Hc)), 2 & t && (r.Eb("aria-owns", "typeahead-", e._index, "-result-box"), r.oc("ngClass", e.cssClass), r.Db("aria-expanded", e.showResults), r.Cb(1), r.Eb("aria-controls", "typeahead-", e._index, "-result-box"), r.Fb("aria-activedescendant", "typeahead-", e._index, "-result-item-", e.resultIndex, ""), r.oc("placeholder", r.jc(3, 14, e.placeholder))("disabled", e.disabled)("autocomplete", e.autocompleteValue), r.Cb(3), r.oc("hidden", !e.isBusy)("size", 16)("thickness", 2), r.Cb(1), r.oc("ngIf", !e.isBusy && e.showDropdownButton), r.Cb(2), r.Jc(r.jc(8, 16, e.voiceOverText$))) }, directives: function () { return [s.l, uc, s.o, ea] }, pipes: function () { return [zc, s.b] }, encapsulation: 2, changeDetection: 0 }), t })(); class Sc extends String { constructor(t) { super(), this.service = t } toString() { return this.service.localeId } } function xc(t, e, n, s, r) { return () => Object(Wt.a)(this, void 0, void 0, function* () { null != r && !0 !== r.disableLanguageRouting && null != r.languagesBaseUrl && n.init(t.get(In.i)), yield s.init(), e.init() }) } let Ec = (() => { class t { constructor(t) { this.cultureProvider = t } canActivate(t, e) { return this.canActivate$.pipe(Object(Q.a)(t => t ? Object(Kt.a)(this.cultureProvider.initializeLocale().then(() => t)) : Object(a.a)(t))) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(xa)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(xa)) }, token: t, providedIn: "root" }), t })(), Tc = (() => { class t { constructor(t, e, n, s) { this.languageService = t, this.languageGuard = e, this.config = n, this.translate = s, this.unsubscribe$ = new i.a, this.resolvedLanguage = null } init(t) { var e, n; if (this.router = t, 1 !== this.router.config.length || !(null === (n = null === (e = this.router.config[0]) || void 0 === e ? void 0 : e.path) || void 0 === n ? void 0 : n.startsWith(":")) || null == this.router.config[0].children) { const t = "Router configuration does not contain single route with language code param (e.g. :language). For language aware routing, please see Pattern > i18n > Translation guidance."; throw console.error(t), new Error(t) } this.router.config[0].canActivate = [...this.router.config[0].canActivate || [], Ec], this.translate.isEnabled ? this.router.events.pipe(Object(Z.a)(this.unsubscribe$)).subscribe(t => this.onRouterEvents(t)) : console.warn("Translation service not enabled. LanguageRoutingService will not intercept or redirect."), this.languageService.currentLanguage$.pipe(Object(Z.a)(this.unsubscribe$)).subscribe(t => this.onLanguageServiceLanguageChanged(t)) } ngOnDestroy() { this.unsubscribe$.next(), this.unsubscribe$.complete() } onRouterEvents(t) { t instanceof In.n && (this.languageGuard.canActivate$ = Object(Gt.a)([Object(a.a)(t), this.languageService.ready$.pipe(Object(u.a)(t => t))]).pipe(Object(Q.a)(([t]) => { const e = this.router.parseUrl(t.urlAfterRedirects); let n = this.tryGetLanguageSymbol(e); if (null == n || null == this.languageService.getLanguageMap()[n]) { n = this.languageService.currentLanguage, this.languageService.setLanguage(n, !0); const e = this.router.parseUrl(t.url); return Object(a.a)(this.insertLanguageUrlSegment(e, n)) } return n !== this.translate.currentLanguage && this.languageService.setLanguage(n, !0), n !== this.resolvedLanguage ? (this.resolvedLanguage = n, Object(a.a)(!0).pipe(Object(Zt.a)(100))) : Object(a.a)(!0) }))) } insertLanguageUrlSegment(t, e) { return void 0 === t.root.children[In.h] ? t.root.children[In.h] = new In.p([new In.o(e, {})], {}) : t.root.children[In.h].segments.unshift(new In.o(e, {})), t } onLanguageServiceLanguageChanged(t) { if (this.router.config[1] = { path: "", redirectTo: t, pathMatch: "full" }, null == this.router.getCurrentNavigation() && this.router.navigated) { const e = this.router.parseUrl(this.router.url); null != e.root.children[In.h] && e.root.children[In.h].segments[0].path !== t && (e.root.children[In.h].segments[0].path = t, this.router.navigateByUrl(e)) } else this.resolvedLanguage = t } tryGetLanguageSymbol(t) { return null != t.root.children[In.h] && t.root.children[In.h].segments.length > 0 ? t.root.children[In.h].segments[0].path : null } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(Sa), r.bc(Ec), r.bc(ba), r.bc(ua)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(Sa), Object(r.bc)(Ec), Object(r.bc)(ba), Object(r.bc)(ua)) }, token: t, providedIn: "root" }), t })(); const kc = new r.r("pattern.stream"); let jc = (() => { class t { constructor(t, e) { if (this.template = t, this.container = e, null == this.container) throw new Error("ptrnContainerTemplate directive must be a descendant of a component providing CONTAINER such as <ptrn-modal>."); this.container.registerContainer(t) } ngOnDestroy() { var t; null === (t = this.container) || void 0 === t || t.unregisterContainer(this.template) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.N), r.Rb(Ba, 8)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["", "ptrnContainerTemplate", ""]], exportAs: ["ptrnContainerTemplate"] }), t })(), Ac = (() => { class t { constructor(t, e) { if (this.template = t, this.container = e, null == this.container) throw new Error("ptrnContentTemplate directive must be a descendant of a component providing CONTENT_CONTAINER such as <ptrn-accordion-group>, <ptrn-modal>, or <ptrn-stepper>."); this.container.registerContent(t) } ngOnDestroy() { var t; null === (t = this.container) || void 0 === t || t.unregisterContent(this.template) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.N), r.Rb(Ki, 8)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["", "ptrnContentTemplate", ""]], exportAs: ["ptrnContentTemplate"] }), t })(), Rc = (() => { class t { constructor(t, e) { this.templateRef = t, this.viewContainer = e, this.hasView = !1 } static ngTemplateContextGuard(t, e) { return !0 } ngOnChanges() { var t, e, n; this.hasView && this.viewContainer.clear(); const s = (null !== (t = this.viewProviderTokens) && void 0 !== t ? t : []).map(t => ({ provide: t, useValue: this.viewContainer.injector.get(t) })), i = r.s.create({ providers: (null !== (e = this.providers) && void 0 !== e ? e : []).concat(s), parent: null !== (n = this.injector) && void 0 !== n ? n : this.viewContainer.injector }); this.viewContainer.createEmbeddedView(this.templateRef, { $implicit: i }), this.hasView = !0 } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.N), r.Rb(r.R)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["", "ptrnCustomProviders", ""]], inputs: { providers: ["ptrnCustomProviders", "providers"], injector: ["ptrnCustomProvidersInjector", "injector"], viewProviderTokens: ["ptrnCustomProvidersViewProviderTokens", "viewProviderTokens"] }, exportAs: ["ptrnCustomProviders"], features: [r.Ab] }), t })(), Lc = (() => { class t { constructor(t, e, n, s, r, o, a, c, l) { this.router = t, this.route = e, this.locationStrategy = n, this.languageService = s, this.languageRouting = r, this.element = o, this.renderer = a, this.location = c, this.translate = l, this.isExternalLink = !1, this.validLanguages = this.languageService.getLanguageSymbols(), this.inputLink$ = new qt.a(null), this.disabled$ = new qt.a(!1), this.commands = [], this.onChanges = new i.a } ngOnChanges(t) { (null != t.link || null != t.queryParams && !t.queryParams.firstChange || null != t.fragment && !t.fragment.firstChange || null != t.queryParamsHandling && !t.queryParamsHandling.firstChange || null != t.preserveFragment && !t.preserveFragment.firstChange) && this.setupLinkSubscription(), null != t.isDisabled && this.disabled$.next(!!this.isDisabled), this.onChanges.next(this) } ngAfterViewInit() { const t = this.router.events.pipe(Object(u.a)(t => t instanceof In.e), Object(Y.a)({})), e = this.inputLink$.pipe(Object(c.a)(t => { this.commands = [], this.inputUrlTree = void 0, t instanceof In.r ? this.inputUrlTree = t : null != t && (this.isExternalLink = this.isExternal || "string" == typeof t && mc(t), this.isExternalLink || (this.commands = Array.isArray(t) ? t : [t])) })); this.subscription = Object(Gt.a)([e, t, this.languageService.currentLanguage$, this.disabled$]).subscribe(([t]) => { this.generateUrlTree(), this.updateTargetUrlAndHref(t) }), this.setupLinkSubscription() } ngOnDestroy() { this.subscription.unsubscribe(), this.inputUrlTreeSubscription && this.inputUrlTreeSubscription.unsubscribe() } onClick(t, e, n, s) { if (this.isExternalLink) return !0; if (this.returnToFragment) { const t = `${this.location.path(!1)}#${this.returnToFragment}`; this.location.replaceState(t) } if (Ic(this.isDisabled)) return !1; if (0 !== t || e || n || s) return !0; if ("string" == typeof this.target && "_self" !== this.target) return !0; const r = { skipLocationChange: Ic(this.skipLocationChange), replaceUrl: Ic(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, r), !1 } setupLinkSubscription() { Object(V.a)(this.link) ? (this.inputUrlTreeSubscription && this.inputUrlTreeSubscription.unsubscribe(), this.inputUrlTreeSubscription = this.link.subscribe(t => this.inputLink$.next(t))) : this.inputLink$.next(this.link) } updateTargetUrlAndHref(t) { if (this.isDisabled) this.renderer.removeAttribute(this.element.nativeElement, "href"); else if (null != this.urlTree) { const t = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)); this.renderer.setProperty(this.element.nativeElement, "href", t) } else this.isExternalLink && this.renderer.setProperty(this.element.nativeElement, "href", t) } generateUrlTree() { let t; if (!this.isExternalLink) { if (this.inputUrlTree) { const e = this.router.serializeUrl(this.inputUrlTree); t = this.router.parseUrl(e) } else t = this.router.createUrlTree(this.commands, { relativeTo: this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: Ic(this.preserveFragment) }); if (this.translate) { let e = this.languageRouting.tryGetLanguageSymbol(t); null != e && -1 !== this.validLanguages.indexOf(e) || (e = this.languageService.currentLanguage, this.languageRouting.insertLanguageUrlSegment(t, e)) } this.urlTree = t } } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(In.i), r.Rb(In.a), r.Rb(s.k), r.Rb(Sa), r.Rb(Tc), r.Rb(r.l), r.Rb(r.F), r.Rb(s.j), r.Rb(Ln.d, 8)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["a", "ptrnLink", ""]], hostVars: 1, hostBindings: function (t, e) { 1 & t && r.ec("click", function (t) { return e.onClick(t.button, t.ctrlKey, t.metaKey, t.shiftKey) }), 2 & t && r.Db("target", e.target) }, inputs: { target: "target", link: ["ptrnLink", "link"], queryParams: "queryParams", fragment: "fragment", returnToFragment: "returnToFragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", isDisabled: "isDisabled", isExternal: "isExternal" }, features: [r.Bb([{ provide: In.k, useExisting: Object(r.V)(() => t) }]), r.Ab] }), t })(); function Ic(t) { return "" === t || !!t } var Pc = function (t) { return t.Full = "full", t.StartsWith = "starts-with", t.Fuzzy = "fuzzy", t.Acronym = "acronym", t }({}); const Dc = /\b(\w+)\b/g; class Mc { constructor(t, e) { var n, s, r; this.options = e, this.incrementalCache = new Map, this.browsable = null === (n = this.options.browsable) || void 0 === n || n, this.collator = new Aa(this.options.localeId), this.keys = null !== (s = e.keys) && void 0 !== s ? s : Vc; const i = null !== (r = e.scores) && void 0 !== r ? r : [Pc.Full, Pc.StartsWith, Pc.Fuzzy]; this.keyedScores = function (t) { const e = {}; for (var n in Pc) { const s = Pc[n]; e[s] = -1 !== t.indexOf(s) } return e }(i), this.normalizedList = function (t, e, n) { return t.map((t, s) => ({ item: t, index: s, values: Nc(t, e, n) })).sort((t, e) => function (t, e, n) { let s = 0, r = 0; for (; 0 === s && r < t.values.length && r < e.values.length;) { if (s = n.compare(t.values[r], e.values[r]), 0 !== s) return s; r++ } return t.index < e.index ? -1 : 1 }(t, e, n)).map(({ item: t, values: e }, n) => ({ item: t, index: n, values: e })) }(t, this.keys, this.collator) } bestMatch(t) { const e = Fc(null != t ? t : "", this.collator); if (0 === e.length) { if (this.browsable) { const t = this.normalizedList.map(({ item: t }) => t); return null != this.options.limitTo && (t.length = Math.min(t.length, this.options.limitTo)), t } return [] } const { cachedList: n, exact: s } = this.getCache(e); let r; r = s ? n : n.filter(({ values: t }) => function (t, e) { return t.some(t => Bc(t, e)) }(t, e)), this.saveCache(e, r); const i = r.map(({ item: t, values: n }, s) => ({ item: t, values: n, index: s, score: Uc(n, e, this.keyedScores) })).sort((t, e) => function (t, e) { const n = Math.sign(e.score - t.score); return 0 !== n ? n : t.index < e.index ? -1 : 1 }(t, e)); return null != this.options.limitTo && (i.length = Math.min(i.length, this.options.limitTo)), i.map(({ item: t }) => t) } getCache(t) { if (0 === t.length) return { cachedList: this.normalizedList, exact: !1 }; let e = t.length; for (; e > 0;) { const n = t.substr(0, e), s = this.incrementalCache.get(n); if (null != s) return { cachedList: s, exact: e === t.length }; e-- } return { cachedList: this.normalizedList, exact: !1 } } saveCache(t, e) { t.length > 5 || this.incrementalCache.has(t) || this.incrementalCache.set(t, e) } } function Nc(t, e, n) { let s = e(t); return null == s ? [] : (s = Array.isArray(s) ? s : [s], s.map(t => Fc(t, n))) } function Fc(t, e) { return e.removeDiacritics(t.trim().toLowerCase()) } function Vc(t) { return "string" == typeof t ? t : null } function Bc(t, e) { if (-1 !== t.indexOf(e)) return !0; let n = 0; for (let s = 0; s < e.length; s++) { const r = t.indexOf(e.charAt(s), n); if (-1 === r) return !1; n = r + 1 } return !0 } function Uc(t, e, n) { return t.reduce((t, s) => Math.max(t, function (t, e, n) { let s = 0; return n[Pc.Full] && (s += function (t, e) { const n = t.indexOf(e); return -1 !== n ? e.length + 1 / (n + 1) : 0 }(t, e)), n[Pc.StartsWith] && (s += function (t, e) { return 0 === t.indexOf(e) ? 1 : 0 }(t, e)), s > 0 || (n[Pc.Fuzzy] && (s += function (t, e) { let n = 0, s = 0; for (let r = 0; r < e.length; r++) { const i = t.indexOf(e.charAt(r), s); if (-1 === i) return n; n += 1 / (i + 1), s = i + 1 } return n }(t, e)), s > 0 && n[Pc.Acronym] && (s += function (t, e) { var n; const s = null !== (n = t.match(Dc)) && void 0 !== n ? n : []; let r = ""; for (const i of s) r += i[0]; return Bc(r, e) ? e.length / 2 : 0 }(t, e))), s }(s, e, n)), 0) } let Hc = (() => { class t { constructor(t, e, n) { var s; this.cdr = t, this.localeId = e, this.typeahead = n, this.list$ = new i.a, this.options$ = new i.a, this.searchTerm$ = new qt.a(void 0), this.outputList = [], this.unsubscribe$ = new i.a; const r = this.list$.pipe(Object(B.a)()), o = this.options$.pipe(Object(B.a)()), c = this.searchTerm$.pipe(Object(B.a)()), l = (null !== (s = null == n ? void 0 : n.search$) && void 0 !== s ? s : Object(a.a)("")).pipe(Object(B.a)()), u = Object(Gt.a)([c, l]).pipe(Object(h.a)(([t, e]) => { var n; return null !== (n = null != t ? t : e) && void 0 !== n ? n : "" }), Object(B.a)()); Object(Gt.a)([r, o]).pipe(Object(h.a)(([t, e]) => { var s, r, i, o, a; const c = null != (null === (s = this.typeahead) || void 0 === s ? void 0 : s.scrollableSize) ? this.typeahead.scrollableSize + 1 : void 0, l = { keys: null !== (r = null == e ? void 0 : e.keys) && void 0 !== r ? r : null == n ? void 0 : n.displayWith, scores: null == e ? void 0 : e.scores, debounceTime: null != n || null == e ? void 0 : e.debounceTime, browsable: null !== (i = null == e ? void 0 : e.browsable) && void 0 !== i ? i : null === (o = this.typeahead) || void 0 === o ? void 0 : o.browsable, localeId: this.localeId, limitTo: null !== (a = null == e ? void 0 : e.limitTo) && void 0 !== a ? a : c }; return new Mc(t, l) })).pipe(Object(Q.a)(t => { let e = u.pipe(Object(h.a)(e => ({ bestMatchList: t, searchTerm: e }))); return null != t.options.debounceTime && (e = e.pipe(ne(({ searchTerm: e }) => e ? G(t.options.debounceTime) : Xt.a))), e }), Object(Z.a)(this.unsubscribe$)).subscribe(({ bestMatchList: t, searchTerm: e }) => this.updateValue(t, e)) } transform(t, e, n) { if (null == t || 0 === t.length) return []; let s, r; return null != n ? (s = e, r = n) : "string" == typeof e || null == e ? s = e : r = e, this.searchTerm$.next(s), this.options$.next(r), this.list$.next(t), this.outputList } ngOnDestroy() { this.unsubscribe$.next(), this.unsubscribe$.complete() } updateValue(t, e) { this.outputList = t.bestMatch(e), this.cdr.markForCheck() } } return t.\u0275fac = function (e) { return new (e || t)(r.dc(), r.Rb(r.v), r.Rb(Oc, 8)) }, t.\u0275pipe = r.Qb({ name: "bestMatch", type: t, pure: !1 }), t })(), zc = (() => { class t { transform(t, ...e) { return la(t, ...e) || "" } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275pipe = r.Qb({ name: "stripHtml", type: t, pure: !0 }), t })(), $c = (() => { class t { constructor(t, e) { this.translationService = t, this.cdr = e, this.translationArgumentsSubject = new qt.a({ key: void 0 }), this.unsubscribe$ = new i.a, this.isFirstRun = !0 } transform(t, e) { const n = { key: t }; return null != e && (n.params = e), this.translationArgumentsSubject.next(n), this.isFirstRun && (this.isFirstRun = !1, n.key && (this.latestValue = this.translationService.translate(n.key, n.params)), this.initSubscription()), this.latestValue } ngOnDestroy() { this.unsubscribe$.next(), this.unsubscribe$.complete() } initSubscription() { _c(this.translationArgumentsSubject, this.translationService).pipe(Object(Z.a)(this.unsubscribe$), Object(u.a)(t => t !== this.latestValue)).subscribe(t => { this.latestValue = t, this.cdr.markForCheck() }) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(ua), r.dc()) }, t.\u0275pipe = r.Qb({ name: "ptrnTranslate", type: t, pure: !1 }), t })(), Wc = (() => { class t { constructor(t) { this.streams = t } static forRoot(e) { return { ngModule: t, providers: [{ provide: _a, useValue: e || {} }, { provide: ba, useValue: e || {} }, { provide: r.v, deps: [xa], useClass: Sc }, { provide: $t.a, useValue: !1 }, s.d, s.f, Xa, zc, { provide: r.d, useFactory: xc, deps: [r.s, Sa, Tc, Oa, ba], multi: !0 }] } } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(kc, 8)) }, t.\u0275mod = r.Pb({ type: t }), t.\u0275inj = r.Ob({ imports: [[P, s.c, $t.l, zt, $t.u]] }), t })(), qc = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.Pb({ type: t }), t.\u0275inj = r.Ob({ imports: [[s.c, Wc, $t.l, $t.u, E]] }), t })(), Gc = (() => { class t { constructor(t) { this.cd = t, this.closeAriaLabel = "Close" } get modalTitleWithFallback() { return this.modalTitle || "&nbsp;" } ngAfterContentInit() { this._showLanguageSubscription = this.language.languageChange.subscribe(() => { this.showLanguage = !1, this.cd.detectChanges() }) } ngOnDestroy() { this._showLanguageSubscription.unsubscribe() } onShowLanguage() { this.showLanguage = !0 } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(r.h)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-top-nav-language"]], contentQueries: function (t, e, n) { if (1 & t && r.Kb(n, Ra, 1), 2 & t) { let t; r.xc(t = r.fc()) && (e.language = t.first) } }, inputs: { closeAriaLabel: "closeAriaLabel", modalTitle: "modalTitle" }, ngContentSelectors: ji, decls: 4, vars: 3, consts: [["type", "button", 1, "top-nav__secondary-item", "top-nav__secondary-item--clickable", "top-nav__language-switcher", 3, "click"], ["icon", "language", 3, "size"], [3, "visible", "visibleChange"], ["class", "language-modal", 4, "ptrnContainerTemplate"], [1, "language-modal"], [3, "closeAriaLabel", "canDismiss"], [3, "innerHTML"]], template: function (t, e) { 1 & t && (r.nc(ki), r.Xb(0, "button", 0), r.ec("click", function () { return e.onShowLanguage() }), r.Sb(1, "ptrn-icon", 1), r.Wb(), r.Xb(2, "ptrn-modal", 2), r.ec("visibleChange", function (t) { return e.showLanguage = t }), r.Gc(3, Ti, 5, 3, "section", 3), r.Wb()), 2 & t && (r.Db("aria-label", e.modalTitleWithFallback), r.Cb(1), r.oc("size", 28), r.Cb(1), r.oc("visible", e.showLanguage)) }, directives: [ea, Ha, jc, $a, Pa], encapsulation: 2, changeDetection: 0 }), t })(), Xc = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-top-nav-aside"]], ngContentSelectors: Mn, decls: 2, vars: 0, consts: [[1, "top-nav__aside"]], template: function (t, e) { 1 & t && (r.nc(), r.Xb(0, "div", 0), r.mc(1), r.Wb()) }, encapsulation: 2, changeDetection: 0 }), t })(), Kc = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-side-nav-header"]], ngContentSelectors: Mn, decls: 2, vars: 0, consts: [[1, "side-nav__section", "padding-bottom-1"]], template: function (t, e) { 1 & t && (r.nc(), r.Xb(0, "section", 0), r.mc(1), r.Wb()) }, encapsulation: 2, changeDetection: 0 }), t })(), Zc = (() => { class t { constructor(t) { this.siteModal = t, this.viewProviderTokens = [Ba] } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(Fa)) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-site-modal-outlet"]], decls: 2, vars: 2, consts: [[3, "visible", "cssClass", "modalTitle", "canDismiss", "closeAriaLabel", "visibleChange", 4, "ngIf"], [3, "visible", "visibleChange", 4, "ngIf"], [3, "visible", "cssClass", "modalTitle", "canDismiss", "closeAriaLabel", "visibleChange"], ["ptrnContentTemplate", ""], [4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ptrnCustomProviders", "ptrnCustomProvidersInjector", "ptrnCustomProvidersViewProviderTokens"], [4, "ngComponentOutlet", "ngComponentOutletInjector"], [3, "visible", "visibleChange"], ["ptrnContainerTemplate", ""]], template: function (t, e) { 1 & t && (r.Gc(0, Mi, 3, 7, "ptrn-modal", 0), r.Gc(1, zi, 4, 5, "ptrn-modal", 1)), 2 & t && (r.oc("ngIf", !(null != e.siteModal.modalOptions && e.siteModal.modalOptions.isContainerElement)), r.Cb(1), r.oc("ngIf", null == e.siteModal.modalOptions ? null : e.siteModal.modalOptions.isContainerElement)) }, directives: [s.o, Ha, Ac, s.s, Rc, s.m, jc], pipes: [s.b], encapsulation: 2, changeDetection: 0 }), t })(), Yc = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-footer"]], ngContentSelectors: Mn, decls: 2, vars: 0, consts: [[1, "layout__footer"]], template: function (t, e) { 1 & t && (r.nc(), r.Xb(0, "footer", 0), r.mc(1), r.Wb()) }, encapsulation: 2, changeDetection: 0 }), t })(), Qc = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-action-links"]], inputs: { cssClass: "cssClass" }, ngContentSelectors: Wi, decls: 4, vars: 1, consts: [[1, "action-links", 3, "ngClass"], [1, "action-links__list"]], template: function (t, e) { 1 & t && (r.nc($i), r.Xb(0, "nav", 0), r.mc(1), r.Xb(2, "ul", 1), r.mc(3, 1), r.Wb(), r.Wb()), 2 & t && r.oc("ngClass", e.cssClass) }, directives: [s.l], encapsulation: 2, changeDetection: 0 }), t })(), Jc = (() => { class t { constructor() { this.level = "sibling" } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-action-links-heading"]], inputs: { level: "level" }, ngContentSelectors: Mn, decls: 2, vars: 1, consts: [["cssClass", "action-links__title", 3, "level"]], template: function (t, e) { 1 & t && (r.nc(), r.Xb(0, "ptrn-heading", 0), r.mc(1), r.Wb()), 2 & t && r.oc("level", e.level) }, directives: [ma], encapsulation: 2, changeDetection: 0 }), t })(), tl = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ptrn-action-link"]], inputs: { link: "link", linkTarget: "linkTarget", isExternal: "isExternal" }, ngContentSelectors: Mn, decls: 5, vars: 4, consts: [[1, "action-links__link-item", 3, "ptrnLink", "target", "isExternal"], [1, "action-links__text"], ["cssClass", "action-links__icon", "icon", "chevron-right", 3, "size"]], template: function (t, e) { 1 & t && (r.nc(), r.Xb(0, "li"), r.Xb(1, "a", 0), r.Xb(2, "span", 1), r.mc(3), r.Wb(), r.Sb(4, "ptrn-icon", 2), r.Wb(), r.Wb()), 2 & t && (r.Cb(1), r.oc("ptrnLink", e.link)("target", e.linkTarget)("isExternal", e.isExternal), r.Cb(3), r.oc("size", 20)) }, directives: [Lc, ea], encapsulation: 2, changeDetection: 0 }), t })(); function el(t) { return null != t && "" !== t.trim() ? `${t} :: ` : "" } let nl = (() => { class t { constructor(t, e, n, s) { this.router = t, this.title = e, this.config = n, this.translate = s, this.routes$ = this.router.events.pipe(Object(u.a)(t => t instanceof In.b), Object(u.a)(t => null != t && "primary" === t.snapshot.outlet && (null == t.snapshot.children || 0 === t.snapshot.children.length))), this.value$ = Object(ft.a)(this.translate ? this.translate.language$ : Xt.a, this.routes$).pipe(Object(te.a)(this.routes$), Object(h.a)(([t, e]) => e.snapshot), Object(c.a)(t => { null != t && null != t.data && null != t.data.pageTitle ? this.setTitle(t.data.pageTitle) : this.setTitle() }), Object(J.a)(1)), this.value$.subscribe() } setTitle(t) { const e = null != this.config.appTitle; let n = this.config.appTitle || ""; const s = null != this.config.suffixTitle; let r = this.config.suffixTitle || "", i = ""; null != t && (this.translate.isEnabled && null != t && (t = this.translate.translate(t)), i = t || i), e && (this.translate.isEnabled && (n = this.translate.translate(n)), i = `${el(i)}${n}`), s && (this.translate.isEnabled && (r = this.translate.translate(r)), i = `${el(i)}${r}`), i = la(i) || i, i = i.trim(), "" !== i && this.title.setTitle(i) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(In.i), r.bc(Dn.c), r.bc(ba), r.bc(ua)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return new t(Object(r.bc)(In.i), Object(r.bc)(Dn.c), Object(r.bc)(ba), Object(r.bc)(ua)) }, token: t, providedIn: "root" }), t })(), sl = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = r.Pb({ type: t }), t.\u0275inj = r.Ob({ providers: [{ provide: kc, useClass: nl, multi: !0 }], imports: [[s.c, In.l, $t.l, Wc]] }), t })() }, itXk: function (t, e, n) { "use strict"; n.d(e, "a", function () { return l }); var s = n("z+Ro"), r = n("DH7j"), i = n("l7GE"), o = n("ZUHj"), a = n("yCtX"); const c = {}; function l(...t) { let e, n; return Object(s.a)(t[t.length - 1]) && (n = t.pop()), "function" == typeof t[t.length - 1] && (e = t.pop()), 1 === t.length && Object(r.a)(t[0]) && (t = t[0]), Object(a.a)(t, n).lift(new u(e)) } class u { constructor(t) { this.resultSelector = t } call(t, e) { return e.subscribe(new h(t, this.resultSelector)) } } class h extends i.a { constructor(t, e) { super(t), this.resultSelector = e, this.active = 0, this.values = [], this.observables = [] } _next(t) { this.values.push(c), this.observables.push(t) } _complete() { const t = this.observables, e = t.length; if (0 === e) this.destination.complete(); else { this.active = e, this.toRespond = e; for (let n = 0; n < e; n++) { const e = t[n]; this.add(Object(o.a)(this, e, void 0, n)) } } } notifyComplete(t) { 0 == (this.active -= 1) && this.destination.complete() } notifyNext(t, e, n) { const s = this.values, r = this.toRespond ? s[n] === c ? --this.toRespond : this.toRespond : 0; s[n] = e, 0 === r && (this.resultSelector ? this._tryResultSelector(s) : this.destination.next(s.slice())) } _tryResultSelector(t) { let e; try { e = this.resultSelector.apply(this, t) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } }, jIYg: function (t, e, n) { "use strict"; function s(t, e) { if (e.length < t) throw new TypeError(t + " argument" + (t > 1 ? "s" : "") + " required, but only " + e.length + " present") } n.d(e, "a", function () { return s }) }, jKzE: function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }); var s = n("/Tr7"), r = n("jIYg"); function i(t) { Object(r.a)(1, arguments); var e = Object(s.a)(t), n = e.getMonth(); return e.setFullYear(e.getFullYear(), n + 1, 0), e.setHours(23, 59, 59, 999), e } }, jZKg: function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }); var s = n("HDdC"), r = n("quSY"); function i(t, e) { return new s.a(n => { const s = new r.a; let i = 0; return s.add(e.schedule(function () { i !== t.length ? (n.next(t[i++]), n.closed || s.add(this.schedule())) : n.complete() })), s }) } }, jhN1: function (t, e, n) { "use strict"; n.d(e, "a", function () { return N }), n.d(e, "b", function () { return R }), n.d(e, "c", function () { return V }), n.d(e, "d", function () { return D }), n.d(e, "e", function () { return w }); var s = n("ofXK"), r = n("fXoL"); class i extends s.A { constructor() { super() } supportsDOMEvents() { return !0 } } class o extends i { static makeCurrent() { Object(s.E)(new o) } getProperty(t, e) { return t[e] } log(t) { window.console && window.console.log && window.console.log(t) } logGroup(t) { window.console && window.console.group && window.console.group(t) } logGroupEnd() { window.console && window.console.groupEnd && window.console.groupEnd() } onAndCancel(t, e, n) { return t.addEventListener(e, n, !1), () => { t.removeEventListener(e, n, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } remove(t) { return t.parentNode && t.parentNode.removeChild(t), t } getValue(t) { return t.value } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getHistory() { return window.history } getLocation() { return window.location } getBaseHref(t) { const e = c || (c = document.querySelector("base"), c) ? c.getAttribute("href") : null; return null == e ? null : (n = e, a || (a = document.createElement("a")), a.setAttribute("href", n), "/" === a.pathname.charAt(0) ? a.pathname : "/" + a.pathname); var n } resetBaseElement() { c = null } getUserAgent() { return window.navigator.userAgent } performanceNow() { return window.performance && window.performance.now ? window.performance.now() : (new Date).getTime() } supportsCookies() { return !0 } getCookie(t) { return Object(s.D)(document.cookie, t) } } let a, c = null; const l = new r.r("TRANSITION_ID"), u = [{ provide: r.d, useFactory: function (t, e, n) { return () => { n.get(r.e).donePromise.then(() => { const n = Object(s.C)(); Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e => e.getAttribute("ng-transition") === t).forEach(t => n.remove(t)) }) } }, deps: [l, s.e, r.s], multi: !0 }]; class h { static init() { Object(r.Z)(new h) } addToWindow(t) { r.qb.getAngularTestability = (e, n = !0) => { const s = t.findTestabilityInTree(e, n); if (null == s) throw new Error("Could not find testability for element."); return s }, r.qb.getAllAngularTestabilities = () => t.getAllTestabilities(), r.qb.getAllAngularRootElements = () => t.getAllRootElements(), r.qb.frameworkStabilizers || (r.qb.frameworkStabilizers = []), r.qb.frameworkStabilizers.push(t => { const e = r.qb.getAllAngularTestabilities(); let n = e.length, s = !1; const i = function (e) { s = s || e, n--, 0 == n && t(s) }; e.forEach(function (t) { t.whenStable(i) }) }) } findTestabilityInTree(t, e, n) { if (null == e) return null; const r = t.getTestability(e); return null != r ? r : n ? Object(s.C)().isShadowRoot(e) ? this.findTestabilityInTree(t, e.host, !0) : this.findTestabilityInTree(t, e.parentElement, !0) : null } } const d = new r.r("EventManagerPlugins"); let p = (() => { class t { constructor(t, e) { this._zone = e, this._eventNameToPlugin = new Map, t.forEach(t => t.manager = this), this._plugins = t.slice().reverse() } addEventListener(t, e, n) { return this._findPluginFor(e).addEventListener(t, e, n) } addGlobalEventListener(t, e, n) { return this._findPluginFor(e).addGlobalEventListener(t, e, n) } getZone() { return this._zone } _findPluginFor(t) { const e = this._eventNameToPlugin.get(t); if (e) return e; const n = this._plugins; for (let s = 0; s < n.length; s++) { const e = n[s]; if (e.supports(t)) return this._eventNameToPlugin.set(t, e), e } throw new Error(`No event manager plugin found for event ${t}`) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(d), r.bc(r.A)) }, t.\u0275prov = r.Nb({ token: t, factory: t.\u0275fac }), t })(); class f { constructor(t) { this._doc = t } addGlobalEventListener(t, e, n) { const r = Object(s.C)().getGlobalEventTarget(this._doc, t); if (!r) throw new Error(`Unsupported event target ${r} for event ${e}`); return this.addEventListener(r, e, n) } } let g = (() => { class t { constructor() { this._stylesSet = new Set } addStyles(t) { const e = new Set; t.forEach(t => { this._stylesSet.has(t) || (this._stylesSet.add(t), e.add(t)) }), this.onStylesAdded(e) } onStylesAdded(t) { } getAllStyles() { return Array.from(this._stylesSet) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = r.Nb({ token: t, factory: t.\u0275fac }), t })(), m = (() => { class t extends g { constructor(t) { super(), this._doc = t, this._hostNodes = new Set, this._styleNodes = new Set, this._hostNodes.add(t.head) } _addStylesToHost(t, e) { t.forEach(t => { const n = this._doc.createElement("style"); n.textContent = t, this._styleNodes.add(e.appendChild(n)) }) } addHost(t) { this._addStylesToHost(this._stylesSet, t), this._hostNodes.add(t) } removeHost(t) { this._hostNodes.delete(t) } onStylesAdded(t) { this._hostNodes.forEach(e => this._addStylesToHost(t, e)) } ngOnDestroy() { this._styleNodes.forEach(t => Object(s.C)().remove(t)) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(s.e)) }, t.\u0275prov = r.Nb({ token: t, factory: t.\u0275fac }), t })(); const b = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, _ = /%COMP%/g; function v(t, e, n) { for (let s = 0; s < e.length; s++) { let r = e[s]; Array.isArray(r) ? v(t, r, n) : (r = r.replace(_, t), n.push(r)) } return n } function y(t) { return e => { if ("__ngUnwrap__" === e) return t; !1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } let w = (() => { class t { constructor(t, e, n) { this.eventManager = t, this.sharedStylesHost = e, this.appId = n, this.rendererByCompId = new Map, this.defaultRenderer = new C(t) } createRenderer(t, e) { if (!t || !e) return this.defaultRenderer; switch (e.encapsulation) { case r.S.Emulated: { let n = this.rendererByCompId.get(e.id); return n || (n = new O(this.eventManager, this.sharedStylesHost, e, this.appId), this.rendererByCompId.set(e.id, n)), n.applyToHost(t), n } case 1: case r.S.ShadowDom: return new S(this.eventManager, this.sharedStylesHost, t, e); default: if (!this.rendererByCompId.has(e.id)) { const t = v(e.id, e.styles, []); this.sharedStylesHost.addStyles(t), this.rendererByCompId.set(e.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(p), r.bc(m), r.bc(r.c)) }, t.\u0275prov = r.Nb({ token: t, factory: t.\u0275fac }), t })(); class C { constructor(t) { this.eventManager = t, this.data = Object.create(null) } destroy() { } createElement(t, e) { return e ? document.createElementNS(b[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { t.appendChild(e) } insertBefore(t, e, n) { t && t.insertBefore(e, n) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let n = "string" == typeof t ? document.querySelector(t) : t; if (!n) throw new Error(`The selector "${t}" did not match any elements`); return e || (n.textContent = ""), n } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, n, s) { if (s) { e = s + ":" + e; const r = b[s]; r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n) } else t.setAttribute(e, n) } removeAttribute(t, e, n) { if (n) { const s = b[n]; s ? t.removeAttributeNS(s, e) : t.removeAttribute(`${n}:${e}`) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, n, s) { s & (r.H.DashCase | r.H.Important) ? t.style.setProperty(e, n, s & r.H.Important ? "important" : "") : t.style[e] = n } removeStyle(t, e, n) { n & r.H.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, n) { t[e] = n } setValue(t, e) { t.nodeValue = e } listen(t, e, n) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, y(n)) : this.eventManager.addEventListener(t, e, y(n)) } } class O extends C { constructor(t, e, n, s) { super(t), this.component = n; const r = v(s + "-" + n.id, n.styles, []); e.addStyles(r), this.contentAttr = "_ngcontent-%COMP%".replace(_, s + "-" + n.id), this.hostAttr = "_nghost-%COMP%".replace(_, s + "-" + n.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const n = super.createElement(t, e); return super.setAttribute(n, this.contentAttr, ""), n } } class S extends C { constructor(t, e, n, s) { super(t), this.sharedStylesHost = e, this.hostEl = n, this.shadowRoot = n.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const r = v(s.id, s.styles, []); for (let i = 0; i < r.length; i++) { const t = document.createElement("style"); t.textContent = r[i], this.shadowRoot.appendChild(t) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, n) { return super.insertBefore(this.nodeOrShadowRoot(t), e, n) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let x = (() => { class t extends f { constructor(t) { super(t) } supports(t) { return !0 } addEventListener(t, e, n) { return t.addEventListener(e, n, !1), () => this.removeEventListener(t, e, n) } removeEventListener(t, e, n) { return t.removeEventListener(e, n) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(s.e)) }, t.\u0275prov = r.Nb({ token: t, factory: t.\u0275fac }), t })(); const E = ["alt", "control", "meta", "shift"], T = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, k = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, j = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let A = (() => { class t extends f { constructor(t) { super(t) } supports(e) { return null != t.parseEventName(e) } addEventListener(e, n, r) { const i = t.parseEventName(n), o = t.eventCallback(i.fullKey, r, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Object(s.C)().onAndCancel(e, i.domEventName, o)) } static parseEventName(e) { const n = e.toLowerCase().split("."), s = n.shift(); if (0 === n.length || "keydown" !== s && "keyup" !== s) return null; const r = t._normalizeKey(n.pop()); let i = ""; if (E.forEach(t => { const e = n.indexOf(t); e > -1 && (n.splice(e, 1), i += t + ".") }), i += r, 0 != n.length || 0 === r.length) return null; const o = {}; return o.domEventName = s, o.fullKey = i, o } static getEventFullKey(t) { let e = "", n = function (t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified"; e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && k.hasOwnProperty(e) && (e = k[e])) } return T[e] || e }(t); return n = n.toLowerCase(), " " === n ? n = "space" : "." === n && (n = "dot"), E.forEach(s => { s != n && (0, j[s])(t) && (e += s + ".") }), e += n, e } static eventCallback(e, n, s) { return r => { t.getEventFullKey(r) === e && s.runGuarded(() => n(r)) } } static _normalizeKey(t) { switch (t) { case "esc": return "escape"; default: return t } } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(s.e)) }, t.\u0275prov = r.Nb({ token: t, factory: t.\u0275fac }), t })(), R = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return Object(r.bc)(I) }, token: t, providedIn: "root" }), t })(); function L(t) { return new I(t.get(s.e)) } let I = (() => { class t extends R { constructor(t) { super(), this._doc = t } sanitize(t, e) { if (null == e) return null; switch (t) { case r.J.NONE: return e; case r.J.HTML: return Object(r.fb)(e, "HTML") ? Object(r.yb)(e) : Object(r.db)(this._doc, String(e)).toString(); case r.J.STYLE: return Object(r.fb)(e, "Style") ? Object(r.yb)(e) : e; case r.J.SCRIPT: if (Object(r.fb)(e, "Script")) return Object(r.yb)(e); throw new Error("unsafe value used in a script context"); case r.J.URL: return Object(r.pb)(e), Object(r.fb)(e, "URL") ? Object(r.yb)(e) : Object(r.eb)(String(e)); case r.J.RESOURCE_URL: if (Object(r.fb)(e, "ResourceURL")) return Object(r.yb)(e); throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)"); default: throw new Error(`Unexpected SecurityContext ${t} (see https://g.co/ng/security#xss)`) } } bypassSecurityTrustHtml(t) { return Object(r.gb)(t) } bypassSecurityTrustStyle(t) { return Object(r.jb)(t) } bypassSecurityTrustScript(t) { return Object(r.ib)(t) } bypassSecurityTrustUrl(t) { return Object(r.kb)(t) } bypassSecurityTrustResourceUrl(t) { return Object(r.hb)(t) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(s.e)) }, t.\u0275prov = Object(r.Nb)({ factory: function () { return L(Object(r.bc)(r.o)) }, token: t, providedIn: "root" }), t })(); const P = [{ provide: r.C, useValue: s.B }, { provide: r.D, useValue: function () { o.makeCurrent(), h.init() }, multi: !0 }, { provide: s.e, useFactory: function () { return Object(r.wb)(document), document }, deps: [] }], D = Object(r.T)(r.Y, "browser", P), M = [[], { provide: r.bb, useValue: "root" }, { provide: r.m, useFactory: function () { return new r.m }, deps: [] }, { provide: d, useClass: x, multi: !0, deps: [s.e, r.A, r.C] }, { provide: d, useClass: A, multi: !0, deps: [s.e] }, [], { provide: w, useClass: w, deps: [p, m, r.c] }, { provide: r.G, useExisting: w }, { provide: g, useExisting: m }, { provide: m, useClass: m, deps: [s.e] }, { provide: r.O, useClass: r.O, deps: [r.A] }, { provide: p, useClass: p, deps: [d, r.A] }, []]; let N = (() => { class t { constructor(t) { if (t) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(e) { return { ngModule: t, providers: [{ provide: r.c, useValue: e.appId }, { provide: l, useExisting: r.c }, u] } } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(t, 12)) }, t.\u0275mod = r.Pb({ type: t }), t.\u0275inj = r.Ob({ providers: M, imports: [s.c, r.f] }), t })(); function F() { return new V(Object(r.bc)(s.e)) } let V = (() => { class t { constructor(t) { this._doc = t } getTitle() { return this._doc.title } setTitle(t) { this._doc.title = t || "" } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(s.e)) }, t.\u0275prov = Object(r.Nb)({ factory: F, token: t, providedIn: "root" }), t })(); "undefined" != typeof window && window }, jtHE: function (t, e, n) { "use strict"; n.d(e, "a", function () { return l }); var s = n("XNiG"), r = n("qgXg"), i = n("quSY"), o = n("pxpQ"), a = n("9ppp"), c = n("Ylt2"); class l extends s.a { constructor(t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, n) { super(), this.scheduler = n, this._events = [], this._infiniteTimeWindow = !1, this._bufferSize = t < 1 ? 1 : t, this._windowTime = e < 1 ? 1 : e, e === Number.POSITIVE_INFINITY ? (this._infiniteTimeWindow = !0, this.next = this.nextInfiniteTimeWindow) : this.next = this.nextTimeWindow } nextInfiniteTimeWindow(t) { if (!this.isStopped) { const e = this._events; e.push(t), e.length > this._bufferSize && e.shift() } super.next(t) } nextTimeWindow(t) { this.isStopped || (this._events.push(new u(this._getNow(), t)), this._trimBufferThenGetEvents()), super.next(t) } _subscribe(t) { const e = this._infiniteTimeWindow, n = e ? this._events : this._trimBufferThenGetEvents(), s = this.scheduler, r = n.length; let l; if (this.closed) throw new a.a; if (this.isStopped || this.hasError ? l = i.a.EMPTY : (this.observers.push(t), l = new c.a(this, t)), s && t.add(t = new o.a(t, s)), e) for (let i = 0; i < r && !t.closed; i++)t.next(n[i]); else for (let i = 0; i < r && !t.closed; i++)t.next(n[i].value); return this.hasError ? t.error(this.thrownError) : this.isStopped && t.complete(), l } _getNow() { return (this.scheduler || r.a).now() } _trimBufferThenGetEvents() { const t = this._getNow(), e = this._bufferSize, n = this._windowTime, s = this._events, r = s.length; let i = 0; for (; i < r && !(t - s[i].time < n);)i++; return r > e && (i = Math.max(i, r - e)), i > 0 && s.splice(0, i), s } } class u { constructor(t, e) { this.time = t, this.value = e } } }, kJWO: function (t, e, n) { "use strict"; n.d(e, "a", function () { return s }); const s = (() => "function" == typeof Symbol && Symbol.observable || "@@observable")() }, l7GE: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("7o/Q"); class r extends s.a { notifyNext(t, e, n, s, r) { this.destination.next(e) } notifyError(t, e) { this.destination.error(t) } notifyComplete(t) { this.destination.complete() } } }, l7P3: function (t, e, n) { "use strict"; n.d(e, "a", function () { return V }), n.d(e, "b", function () { return _ }), n.d(e, "c", function () { return b }), n.d(e, "d", function () { return C }), n.d(e, "e", function () { return W }), n.d(e, "f", function () { return $ }), n.d(e, "g", function () { return K }), n.d(e, "h", function () { return Q }), n.d(e, "i", function () { return nt }), n.d(e, "j", function () { return At }), n.d(e, "k", function () { return Rt }), n.d(e, "l", function () { return jt }), n.d(e, "m", function () { return q }), n.d(e, "n", function () { return H }), n.d(e, "o", function () { return f }), n.d(e, "p", function () { return ht }), n.d(e, "q", function () { return Vt }), n.d(e, "r", function () { return lt }), n.d(e, "s", function () { return it }), n.d(e, "t", function () { return Ft }), n.d(e, "u", function () { return g }), n.d(e, "v", function () { return rt }); var s = n("fXoL"), r = n("2Vo4"), i = n("HDdC"), o = n("XNiG"), a = n("qgXg"), c = n("pxpQ"), l = n("zp1y"), u = n("Kqap"), h = n("lJxs"), d = n("/uUt"); const p = {}; function f(t, e) { if (p[t] = (p[t] || 0) + 1, "function" == typeof e) return m(t, (...n) => Object.assign(Object.assign({}, e(...n)), { type: t })); switch (e ? e._as : "empty") { case "empty": return m(t, () => ({ type: t })); case "props": return m(t, e => Object.assign(Object.assign({}, e), { type: t })); default: throw new Error("Unexpected config.") } } function g() { return { _as: "props", _p: void 0 } } function m(t, e) { return Object.defineProperty(e, "type", { value: t, writable: !1 }) } const b = "@ngrx/store/init"; let _ = (() => { class t extends r.a { constructor() { super({ type: b }) } next(t) { if ("function" == typeof t) throw new TypeError("\n        Dispatch expected an object, instead it received a function.\n        If you're using the createAction function, make sure to invoke the function\n        before dispatching the action. For example, someAction should be someAction()."); if (void 0 === t) throw new TypeError("Actions must be objects"); if (void 0 === t.type) throw new TypeError("Actions must have a type property"); super.next(t) } complete() { } ngOnDestroy() { super.complete() } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); const v = [_], y = new s.r("@ngrx/store Internal Root Guard"), w = new s.r("@ngrx/store Internal Initial State"), C = new s.r("@ngrx/store Initial State"), O = new s.r("@ngrx/store Reducer Factory"), S = new s.r("@ngrx/store Internal Reducer Factory Provider"), x = new s.r("@ngrx/store Initial Reducers"), E = new s.r("@ngrx/store Internal Initial Reducers"), T = new s.r("@ngrx/store Store Features"), k = new s.r("@ngrx/store Internal Store Reducers"), j = new s.r("@ngrx/store Internal Feature Reducers"), A = new s.r("@ngrx/store Internal Feature Configs"), R = new s.r("@ngrx/store Internal Store Features"), L = new s.r("@ngrx/store Internal Feature Reducers Token"), I = new s.r("@ngrx/store Feature Reducers"), P = new s.r("@ngrx/store User Provided Meta Reducers"), D = new s.r("@ngrx/store Meta Reducers"), M = new s.r("@ngrx/store Internal Resolved Meta Reducers"), N = new s.r("@ngrx/store User Runtime Checks Config"), F = new s.r("@ngrx/store Internal User Runtime Checks Config"), V = new s.r("@ngrx/store Internal Runtime Checks"), B = new s.r("@ngrx/store Check if Action types are unique"); function U(t, e = {}) { const n = Object.keys(t), s = {}; for (let i = 0; i < n.length; i++) { const e = n[i]; "function" == typeof t[e] && (s[e] = t[e]) } const r = Object.keys(s); return function (t, n) { t = void 0 === t ? e : t; let i = !1; const o = {}; for (let e = 0; e < r.length; e++) { const a = r[e], c = t[a], l = (0, s[a])(c, n); o[a] = l, i = i || l !== c } return i ? o : t } } function H(...t) { return function (e) { if (0 === t.length) return e; const n = t[t.length - 1]; return t.slice(0, -1).reduceRight((t, e) => e(t), n(e)) } } function z(t, e) { return Array.isArray(e) && e.length > 0 && (t = H.apply(null, [...e, t])), (e, n) => { const s = t(e); return (t, e) => s(t = void 0 === t ? n : t, e) } } class $ extends i.a { } class W extends _ { } const q = "@ngrx/store/update-reducers"; let G = (() => { class t extends r.a { constructor(t, e, n, s) { super(s(n, e)), this.dispatcher = t, this.initialState = e, this.reducers = n, this.reducerFactory = s } addFeature(t) { this.addFeatures([t]) } addFeatures(t) { const e = t.reduce((t, { reducers: e, reducerFactory: n, metaReducers: s, initialState: r, key: i }) => { const o = "function" == typeof e ? function (t) { const e = Array.isArray(t) && t.length > 0 ? H(...t) : t => t; return (t, n) => (t = e(t), (e, s) => t(e = void 0 === e ? n : e, s)) }(s)(e, r) : z(n, s)(e, r); return t[i] = o, t }, {}); this.addReducers(e) } removeFeature(t) { this.removeFeatures([t]) } removeFeatures(t) { this.removeReducers(t.map(t => t.key)) } addReducer(t, e) { this.addReducers({ [t]: e }) } addReducers(t) { this.reducers = Object.assign(Object.assign({}, this.reducers), t), this.updateReducers(Object.keys(t)) } removeReducer(t) { this.removeReducers([t]) } removeReducers(t) { t.forEach(t => { var e, n; this.reducers = (e = this.reducers, n = t, Object.keys(e).filter(t => t !== n).reduce((t, n) => Object.assign(t, { [n]: e[n] }), {})) }), this.updateReducers(t) } updateReducers(t) { this.next(this.reducerFactory(this.reducers, this.initialState)), this.dispatcher.next({ type: q, features: t }) } ngOnDestroy() { this.complete() } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(W), s.bc(C), s.bc(x), s.bc(O)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); const X = [G, { provide: $, useExisting: G }, { provide: W, useExisting: _ }]; let K = (() => { class t extends o.a { ngOnDestroy() { this.complete() } } return t.\u0275fac = function (e) { return Z(e || t) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); const Z = s.Zb(K), Y = [K]; class Q extends i.a { } let J = (() => { class t extends r.a { constructor(t, e, n, s) { super(s); const r = { state: s }, i = t.pipe(Object(c.b)(a.b)).pipe(Object(l.a)(e)).pipe(Object(u.a)(tt, r)); this.stateSubscription = i.subscribe(({ state: t, action: e }) => { this.next(t), n.next(e) }) } ngOnDestroy() { this.stateSubscription.unsubscribe(), this.complete() } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(_), s.bc($), s.bc(K), s.bc(C)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t.INIT = b, t })(); function tt(t = { state: void 0 }, [e, n]) { const { state: s } = t; return { state: n(s, e), action: e } } const et = [J, { provide: Q, useExisting: J }]; let nt = (() => { class t extends i.a { constructor(t, e, n) { super(), this.actionsObserver = e, this.reducerManager = n, this.source = t } select(t, ...e) { return rt.call(null, t, ...e)(this) } lift(e) { const n = new t(this, this.actionsObserver, this.reducerManager); return n.operator = e, n } dispatch(t) { this.actionsObserver.next(t) } next(t) { this.actionsObserver.next(t) } error(t) { this.actionsObserver.error(t) } complete() { this.actionsObserver.complete() } addReducer(t, e) { this.reducerManager.addReducer(t, e) } removeReducer(t) { this.reducerManager.removeReducer(t) } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(Q), s.bc(_), s.bc(G)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); const st = [nt]; function rt(t, e, ...n) { return function (s) { let r; if ("string" == typeof t) { const i = [e, ...n].filter(Boolean); r = s.pipe(function (...t) { const e = t.length; if (0 === e) throw new Error("list of properties cannot be empty."); return n => Object(h.a)(function (t, e) { return n => { let s = n; for (let r = 0; r < e; r++) { const e = null != s ? s[t[r]] : void 0; if (void 0 === e) return; s = e } return s } }(t, e))(n) }(t, ...i)) } else { if ("function" != typeof t) throw new TypeError(`Unexpected type '${typeof t}' in select operator, expected 'string' or 'function'`); r = s.pipe(Object(h.a)(n => t(n, e))) } return r.pipe(Object(d.a)()) } } function it() { return !1 } function ot(t, e) { return t === e } function at(t, e, n) { for (let s = 0; s < t.length; s++)if (!n(t[s], e[s])) return !0; return !1 } function ct(t, e = ot, n = ot) { let s, r = null, i = null; return { memoized: function () { if (void 0 !== s) return s.result; if (!r) return i = t.apply(null, arguments), r = arguments, i; if (!at(arguments, r, e)) return i; const o = t.apply(null, arguments); return r = arguments, n(i, o) ? i : (i = o, o) }, reset: function () { r = null, i = null }, setResult: function (t) { s = { result: t } }, clearResult: function () { s = void 0 } } } function lt(...t) { return function (t, e = { stateFn: ut }) { return function (...n) { let s = n; if (Array.isArray(s[0])) { const [t, ...e] = s; s = [...t, ...e] } const r = s.slice(0, s.length - 1), i = s[s.length - 1], o = r.filter(t => t.release && "function" == typeof t.release), a = t(function (...t) { return i.apply(null, t) }), c = ct(function (t, n) { return e.stateFn.apply(null, [t, r, n, a]) }); return Object.assign(c.memoized, { release: function () { c.reset(), a.reset(), o.forEach(t => t.release()) }, projector: a.memoized, setResult: c.setResult, clearResult: c.clearResult }) } }(ct)(...t) } function ut(t, e, n, s) { if (void 0 === n) { const n = e.map(e => e(t)); return s.memoized.apply(null, n) } const r = e.map(e => e(t, n)); return s.memoized.apply(null, [...r, n]) } function ht(t) { return lt(e => { const n = e[t]; return !Object(s.X)() || t in e || console.warn(`@ngrx/store: The feature name "${t}" does not exist in the state, therefore createFeatureSelector cannot access it.  Be sure it is imported in a loaded module using StoreModule.forRoot('${t}', ...) or StoreModule.forFeature('${t}', ...).  If the default state is intended to be undefined, as is the case with router state, this development-only warning message can be ignored.`), n }, t => t) } const dt = "https://ngrx.io/guide/store/configuration/runtime-checks"; function pt(t) { return void 0 === t } function ft(t) { return null === t } function gt(t) { return Array.isArray(t) } function mt(t) { return "object" == typeof t && null !== t } function bt(t) { return "function" == typeof t } function _t(t) { Object.freeze(t); const e = bt(t); return Object.getOwnPropertyNames(t).forEach(n => { if (!n.startsWith("\u0275") && function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }(t, n) && (!e || "caller" !== n && "callee" !== n && "arguments" !== n)) { const e = t[n]; !mt(e) && !bt(e) || Object.isFrozen(e) || _t(e) } }), t } function vt(t, e = []) { return (pt(t) || ft(t)) && 0 === e.length ? { path: ["root"], value: t } : Object.keys(t).reduce((n, s) => { if (n) return n; const r = t[s]; return function (t) { return bt(t) && t.hasOwnProperty("\u0275cmp") }(r) ? n : !(pt(r) || ft(r) || function (t) { return "number" == typeof t }(r) || function (t) { return "boolean" == typeof t }(r) || function (t) { return "string" == typeof t }(r) || gt(r)) && (function (t) { if (!function (t) { return mt(t) && !gt(t) }(t)) return !1; const e = Object.getPrototypeOf(t); return e === Object.prototype || null === e }(r) ? vt(r, [...e, s]) : { path: [...e, s], value: r }) }, !1) } function yt(t, e) { if (!1 === t) return; const n = t.path.join("."), s = new Error(`Detected unserializable ${e} at "${n}". ${dt}#strict${e}serializability`); throw s.value = t.value, s.unserializablePath = n, s } function wt(t) { return Object(s.X)() ? Object.assign({ strictStateSerializability: !1, strictActionSerializability: !1, strictStateImmutability: !0, strictActionImmutability: !0, strictActionWithinNgZone: !1, strictActionTypeUniqueness: !1 }, t) : { strictStateSerializability: !1, strictActionSerializability: !1, strictStateImmutability: !1, strictActionImmutability: !1, strictActionWithinNgZone: !1, strictActionTypeUniqueness: !1 } } function Ct({ strictActionSerializability: t, strictStateSerializability: e }) { return n => t || e ? function (t, e) { return function (n, s) { e.action(s) && yt(vt(s), "action"); const r = t(n, s); return e.state() && yt(vt(r), "state"), r } }(n, { action: e => t && !St(e), state: () => e }) : n } function Ot({ strictActionImmutability: t, strictStateImmutability: e }) { return n => t || e ? function (t, e) { return function (n, s) { const r = e.action(s) ? _t(s) : s, i = t(n, r); return e.state() ? _t(i) : i } }(n, { action: e => t && !St(e), state: () => e }) : n } function St(t) { return t.type.startsWith("@ngrx") } function xt({ strictActionWithinNgZone: t }) { return e => t ? function (t, e) { return function (n, r) { if (e.action(r) && !s.A.isInAngularZone()) throw new Error(`Action '${r.type}' running outside NgZone. ${dt}#strictactionwithinngzone`); return t(n, r) } }(e, { action: e => t && !St(e) }) : e } function Et() { return [{ provide: B, multi: !0, deps: [V], useFactory: kt }] } function Tt(t) { return t } function kt(t) { if (!t.strictActionTypeUniqueness) return; const e = Object.entries(p).filter(([, t]) => t > 1).map(([t]) => t); if (e.length) throw new Error(`Action types are registered more than once, ${e.map(t => `"${t}"`).join(", ")}. ${dt}#strictactiontypeuniqueness`) } let jt = (() => { class t { constructor(t, e, n, s, r, i) { } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(_), s.bc($), s.bc(K), s.bc(nt), s.bc(y, 8), s.bc(B, 8)) }, t.\u0275mod = s.Pb({ type: t }), t.\u0275inj = s.Ob({}), t })(), At = (() => { class t { constructor(t, e, n, s, r) { this.features = t, this.featureReducers = e, this.reducerManager = n; const i = t.map((t, n) => { const s = e.shift()[n]; return Object.assign(Object.assign({}, t), { reducers: s, initialState: Dt(t.initialState) }) }); n.addFeatures(i) } ngOnDestroy() { this.reducerManager.removeFeatures(this.features) } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(R), s.bc(I), s.bc(G), s.bc(jt), s.bc(B, 8)) }, t.\u0275mod = s.Pb({ type: t }), t.\u0275inj = s.Ob({}), t })(), Rt = (() => { class t { static forRoot(t, e = {}) { return { ngModule: jt, providers: [{ provide: y, useFactory: Nt, deps: [[nt, new s.B, new s.L]] }, { provide: w, useValue: e.initialState }, { provide: C, useFactory: Dt, deps: [w] }, { provide: E, useValue: t }, { provide: k, useExisting: t instanceof s.r ? t : E }, { provide: x, deps: [s.s, E, [new s.p(k)]], useFactory: Lt }, { provide: P, useValue: e.metaReducers ? e.metaReducers : [] }, { provide: M, deps: [D, P], useFactory: Mt }, { provide: S, useValue: e.reducerFactory ? e.reducerFactory : U }, { provide: O, deps: [S, M], useFactory: z }, v, X, Y, et, st, (n = e.runtimeChecks, [{ provide: F, useValue: n }, { provide: N, useFactory: Tt, deps: [F] }, { provide: V, deps: [N], useFactory: wt }, { provide: D, multi: !0, deps: [V], useFactory: Ot }, { provide: D, multi: !0, deps: [V], useFactory: Ct }, { provide: D, multi: !0, deps: [V], useFactory: xt }]), Et()] }; var n } static forFeature(t, e, n = {}) { return { ngModule: At, providers: [{ provide: A, multi: !0, useValue: t instanceof Object ? {} : n }, { provide: T, multi: !0, useValue: { key: t instanceof Object ? t.name : t, reducerFactory: n instanceof s.r || !n.reducerFactory ? U : n.reducerFactory, metaReducers: n instanceof s.r || !n.metaReducers ? [] : n.metaReducers, initialState: n instanceof s.r || !n.initialState ? void 0 : n.initialState } }, { provide: R, deps: [s.s, A, T], useFactory: It }, { provide: j, multi: !0, useValue: t instanceof Object ? t.reducer : e }, { provide: L, multi: !0, useExisting: e instanceof s.r ? e : j }, { provide: I, multi: !0, deps: [s.s, j, [new s.p(L)]], useFactory: Pt }, Et()] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = s.Pb({ type: t }), t.\u0275inj = s.Ob({}), t })(); function Lt(t, e) { return e instanceof s.r ? t.get(e) : e } function It(t, e, n) { return n.map((n, r) => { if (e[r] instanceof s.r) { const s = t.get(e[r]); return { key: n.key, reducerFactory: s.reducerFactory ? s.reducerFactory : U, metaReducers: s.metaReducers ? s.metaReducers : [], initialState: s.initialState } } return n }) } function Pt(t, e) { return e.map(e => e instanceof s.r ? t.get(e) : e) } function Dt(t) { return "function" == typeof t ? t() : t } function Mt(t, e) { return t.concat(e) } function Nt(t) { if (t) throw new TypeError("StoreModule.forRoot() called twice. Feature modules should use StoreModule.forFeature() instead."); return "guarded" } function Ft(...t) { return { reducer: t.pop(), types: t.map(t => t.type) } } function Vt(t, ...e) { const n = new Map; for (let s of e) for (let t of s.types) { const e = n.get(t); n.set(t, e ? (t, n) => s.reducer(e(t, n), n) : s.reducer) } return function (e = t, s) { const r = n.get(s.type); return r ? r(e, s) : e } } }, lJxs: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("7o/Q"); function r(t, e) { return function (n) { if ("function" != typeof t) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return n.lift(new i(t, e)) } } class i { constructor(t, e) { this.project = t, this.thisArg = e } call(t, e) { return e.subscribe(new o(t, this.project, this.thisArg)) } } class o extends s.a { constructor(t, e, n) { super(t), this.project = e, this.count = 0, this.thisArg = n || this } _next(t) { let e; try { e = this.project.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } }, mCNh: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }), n.d(e, "b", function () { return i }); var s = n("SpAZ"); function r(...t) { return i(t) } function i(t) { return 0 === t.length ? s.a : 1 === t.length ? t[0] : function (e) { return t.reduce((t, e) => e(t), e) } } }, mlxB: function (t, e, n) { "use strict"; function s(t) { return t instanceof Date && !isNaN(+t) } n.d(e, "a", function () { return s }) }, mrSG: function (t, e, n) { "use strict"; function s(t, e, n, s) { var r, i = arguments.length, o = i < 3 ? e : null === s ? s = Object.getOwnPropertyDescriptor(e, n) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(t, e, n, s); else for (var a = t.length - 1; a >= 0; a--)(r = t[a]) && (o = (i < 3 ? r(o) : i > 3 ? r(e, n, o) : r(e, n)) || o); return i > 3 && o && Object.defineProperty(e, n, o), o } function r(t, e, n, s) { return new (n || (n = Promise))(function (r, i) { function o(t) { try { c(s.next(t)) } catch (e) { i(e) } } function a(t) { try { c(s.throw(t)) } catch (e) { i(e) } } function c(t) { var e; t.done ? r(t.value) : (e = t.value, e instanceof n ? e : new n(function (t) { t(e) })).then(o, a) } c((s = s.apply(t, e || [])).next()) }) } n.d(e, "b", function () { return s }), n.d(e, "a", function () { return r }) }, n6bG: function (t, e, n) { "use strict"; function s(t) { return "function" == typeof t } n.d(e, "a", function () { return s }) }, nYR2: function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }); var s = n("7o/Q"), r = n("quSY"); function i(t) { return e => e.lift(new o(t)) } class o { constructor(t) { this.callback = t } call(t, e) { return e.subscribe(new a(t, this.callback)) } } class a extends s.a { constructor(t, e) { super(t), this.add(new r.a(e)) } } }, ngJS: function (t, e, n) { "use strict"; n.d(e, "a", function () { return s }); const s = t => e => { for (let n = 0, s = t.length; n < s && !e.closed; n++)e.next(t[n]); e.complete() } }, ofXK: function (t, e, n) { "use strict"; n.d(e, "a", function () { return y }), n.d(e, "b", function () { return Rt }), n.d(e, "c", function () { return Dt }), n.d(e, "d", function () { return Pt }), n.d(e, "e", function () { return c }), n.d(e, "f", function () { return It }), n.d(e, "g", function () { return R }), n.d(e, "h", function () { return C }), n.d(e, "i", function () { return h }), n.d(e, "j", function () { return O }), n.d(e, "k", function () { return _ }), n.d(e, "l", function () { return pt }), n.d(e, "m", function () { return ft }), n.d(e, "n", function () { return mt }), n.d(e, "o", function () { return _t }), n.d(e, "p", function () { return St }), n.d(e, "q", function () { return Ct }), n.d(e, "r", function () { return Ot }), n.d(e, "s", function () { return xt }), n.d(e, "t", function () { return w }), n.d(e, "u", function () { return l }), n.d(e, "v", function () { return Lt }), n.d(e, "w", function () { return Ft }), n.d(e, "x", function () { return I }), n.d(e, "y", function () { return Nt }), n.d(e, "z", function () { return ht }), n.d(e, "A", function () { return a }), n.d(e, "B", function () { return Mt }), n.d(e, "C", function () { return i }), n.d(e, "D", function () { return dt }), n.d(e, "E", function () { return o }); var s = n("fXoL"); let r = null; function i() { return r } function o(t) { r || (r = t) } class a { } const c = new s.r("DocumentToken"); let l = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = Object(s.Nb)({ factory: u, token: t, providedIn: "platform" }), t })(); function u() { return Object(s.bc)(d) } const h = new s.r("Location Initialized"); let d = (() => { class t extends l { constructor(t) { super(), this._doc = t, this._init() } _init() { this.location = i().getLocation(), this._history = i().getHistory() } getBaseHrefFromDOM() { return i().getBaseHref(this._doc) } onPopState(t) { i().getGlobalEventTarget(this._doc, "window").addEventListener("popstate", t, !1) } onHashChange(t) { i().getGlobalEventTarget(this._doc, "window").addEventListener("hashchange", t, !1) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(t) { this.location.pathname = t } pushState(t, e, n) { p() ? this._history.pushState(t, e, n) : this.location.hash = n } replaceState(t, e, n) { p() ? this._history.replaceState(t, e, n) : this.location.hash = n } forward() { this._history.forward() } back() { this._history.back() } getState() { return this._history.state } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(c)) }, t.\u0275prov = Object(s.Nb)({ factory: f, token: t, providedIn: "platform" }), t })(); function p() { return !!window.history.pushState } function f() { return new d(Object(s.bc)(c)) } function g(t, e) { if (0 == t.length) return e; if (0 == e.length) return t; let n = 0; return t.endsWith("/") && n++, e.startsWith("/") && n++, 2 == n ? t + e.substring(1) : 1 == n ? t + e : t + "/" + e } function m(t) { const e = t.match(/#|\?|$/), n = e && e.index || t.length; return t.slice(0, n - ("/" === t[n - 1] ? 1 : 0)) + t.slice(n) } function b(t) { return t && "?" !== t[0] ? "?" + t : t } let _ = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = Object(s.Nb)({ factory: v, token: t, providedIn: "root" }), t })(); function v(t) { const e = Object(s.bc)(c).location; return new w(Object(s.bc)(l), e && e.origin || "") } const y = new s.r("appBaseHref"); let w = (() => { class t extends _ { constructor(t, e) { if (super(), this._platformLocation = t, null == e && (e = this._platformLocation.getBaseHrefFromDOM()), null == e) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = e } onPopState(t) { this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t) } getBaseHref() { return this._baseHref } prepareExternalUrl(t) { return g(this._baseHref, t) } path(t = !1) { const e = this._platformLocation.pathname + b(this._platformLocation.search), n = this._platformLocation.hash; return n && t ? `${e}${n}` : e } pushState(t, e, n, s) { const r = this.prepareExternalUrl(n + b(s)); this._platformLocation.pushState(t, e, r) } replaceState(t, e, n, s) { const r = this.prepareExternalUrl(n + b(s)); this._platformLocation.replaceState(t, e, r) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(l), s.bc(y, 8)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(), C = (() => { class t extends _ { constructor(t, e) { super(), this._platformLocation = t, this._baseHref = "", null != e && (this._baseHref = e) } onPopState(t) { this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t) } getBaseHref() { return this._baseHref } path(t = !1) { let e = this._platformLocation.hash; return null == e && (e = "#"), e.length > 0 ? e.substring(1) : e } prepareExternalUrl(t) { const e = g(this._baseHref, t); return e.length > 0 ? "#" + e : e } pushState(t, e, n, s) { let r = this.prepareExternalUrl(n + b(s)); 0 == r.length && (r = this._platformLocation.pathname), this._platformLocation.pushState(t, e, r) } replaceState(t, e, n, s) { let r = this.prepareExternalUrl(n + b(s)); 0 == r.length && (r = this._platformLocation.pathname), this._platformLocation.replaceState(t, e, r) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(l), s.bc(y, 8)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(), O = (() => { class t { constructor(t, e) { this._subject = new s.n, this._urlChangeListeners = [], this._platformStrategy = t; const n = this._platformStrategy.getBaseHref(); this._platformLocation = e, this._baseHref = m(x(n)), this._platformStrategy.onPopState(t => { this._subject.emit({ url: this.path(!0), pop: !0, state: t.state, type: t.type }) }) } path(t = !1) { return this.normalize(this._platformStrategy.path(t)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(t, e = "") { return this.path() == this.normalize(t + b(e)) } normalize(e) { return t.stripTrailingSlash(function (t, e) { return t && e.startsWith(t) ? e.substring(t.length) : e }(this._baseHref, x(e))) } prepareExternalUrl(t) { return t && "/" !== t[0] && (t = "/" + t), this._platformStrategy.prepareExternalUrl(t) } go(t, e = "", n = null) { this._platformStrategy.pushState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + b(e)), n) } replaceState(t, e = "", n = null) { this._platformStrategy.replaceState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + b(e)), n) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } onUrlChange(t) { this._urlChangeListeners.push(t), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(t => { this._notifyUrlChangeListeners(t.url, t.state) })) } _notifyUrlChangeListeners(t = "", e) { this._urlChangeListeners.forEach(n => n(t, e)) } subscribe(t, e, n) { return this._subject.subscribe({ next: t, error: e, complete: n }) } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(_), s.bc(l)) }, t.normalizeQueryParams = b, t.joinWithSlash = g, t.stripTrailingSlash = m, t.\u0275prov = Object(s.Nb)({ factory: S, token: t, providedIn: "root" }), t })(); function S() { return new O(Object(s.bc)(_), Object(s.bc)(l)) } function x(t) { return t.replace(/\/index.html$/, "") } const E = { ADP: [void 0, void 0, 0], AFN: [void 0, void 0, 0], ALL: [void 0, void 0, 0], AMD: [void 0, void 0, 2], AOA: [void 0, "Kz"], ARS: [void 0, "$"], AUD: ["A$", "$"], BAM: [void 0, "KM"], BBD: [void 0, "$"], BDT: [void 0, "\u09f3"], BHD: [void 0, void 0, 3], BIF: [void 0, void 0, 0], BMD: [void 0, "$"], BND: [void 0, "$"], BOB: [void 0, "Bs"], BRL: ["R$"], BSD: [void 0, "$"], BWP: [void 0, "P"], BYN: [void 0, "\u0440.", 2], BYR: [void 0, void 0, 0], BZD: [void 0, "$"], CAD: ["CA$", "$", 2], CHF: [void 0, void 0, 2], CLF: [void 0, void 0, 4], CLP: [void 0, "$", 0], CNY: ["CN\xa5", "\xa5"], COP: [void 0, "$", 2], CRC: [void 0, "\u20a1", 2], CUC: [void 0, "$"], CUP: [void 0, "$"], CZK: [void 0, "K\u010d", 2], DJF: [void 0, void 0, 0], DKK: [void 0, "kr", 2], DOP: [void 0, "$"], EGP: [void 0, "E\xa3"], ESP: [void 0, "\u20a7", 0], EUR: ["\u20ac"], FJD: [void 0, "$"], FKP: [void 0, "\xa3"], GBP: ["\xa3"], GEL: [void 0, "\u20be"], GIP: [void 0, "\xa3"], GNF: [void 0, "FG", 0], GTQ: [void 0, "Q"], GYD: [void 0, "$", 2], HKD: ["HK$", "$"], HNL: [void 0, "L"], HRK: [void 0, "kn"], HUF: [void 0, "Ft", 2], IDR: [void 0, "Rp", 2], ILS: ["\u20aa"], INR: ["\u20b9"], IQD: [void 0, void 0, 0], IRR: [void 0, void 0, 0], ISK: [void 0, "kr", 0], ITL: [void 0, void 0, 0], JMD: [void 0, "$"], JOD: [void 0, void 0, 3], JPY: ["\xa5", void 0, 0], KHR: [void 0, "\u17db"], KMF: [void 0, "CF", 0], KPW: [void 0, "\u20a9", 0], KRW: ["\u20a9", void 0, 0], KWD: [void 0, void 0, 3], KYD: [void 0, "$"], KZT: [void 0, "\u20b8"], LAK: [void 0, "\u20ad", 0], LBP: [void 0, "L\xa3", 0], LKR: [void 0, "Rs"], LRD: [void 0, "$"], LTL: [void 0, "Lt"], LUF: [void 0, void 0, 0], LVL: [void 0, "Ls"], LYD: [void 0, void 0, 3], MGA: [void 0, "Ar", 0], MGF: [void 0, void 0, 0], MMK: [void 0, "K", 0], MNT: [void 0, "\u20ae", 2], MRO: [void 0, void 0, 0], MUR: [void 0, "Rs", 2], MXN: ["MX$", "$"], MYR: [void 0, "RM"], NAD: [void 0, "$"], NGN: [void 0, "\u20a6"], NIO: [void 0, "C$"], NOK: [void 0, "kr", 2], NPR: [void 0, "Rs"], NZD: ["NZ$", "$"], OMR: [void 0, void 0, 3], PHP: [void 0, "\u20b1"], PKR: [void 0, "Rs", 2], PLN: [void 0, "z\u0142"], PYG: [void 0, "\u20b2", 0], RON: [void 0, "lei"], RSD: [void 0, void 0, 0], RUB: [void 0, "\u20bd"], RUR: [void 0, "\u0440."], RWF: [void 0, "RF", 0], SBD: [void 0, "$"], SEK: [void 0, "kr", 2], SGD: [void 0, "$"], SHP: [void 0, "\xa3"], SLL: [void 0, void 0, 0], SOS: [void 0, void 0, 0], SRD: [void 0, "$"], SSP: [void 0, "\xa3"], STD: [void 0, void 0, 0], STN: [void 0, "Db"], SYP: [void 0, "\xa3", 0], THB: [void 0, "\u0e3f"], TMM: [void 0, void 0, 0], TND: [void 0, void 0, 3], TOP: [void 0, "T$"], TRL: [void 0, void 0, 0], TRY: [void 0, "\u20ba"], TTD: [void 0, "$"], TWD: ["NT$", "$", 2], TZS: [void 0, void 0, 2], UAH: [void 0, "\u20b4"], UGX: [void 0, void 0, 0], USD: ["$"], UYI: [void 0, void 0, 0], UYU: [void 0, "$"], UYW: [void 0, void 0, 4], UZS: [void 0, void 0, 2], VEF: [void 0, "Bs", 2], VND: ["\u20ab", void 0, 0], VUV: [void 0, void 0, 0], XAF: ["FCFA", void 0, 0], XCD: ["EC$", "$"], XOF: ["CFA", void 0, 0], XPF: ["CFPF", void 0, 0], XXX: ["\xa4"], YER: [void 0, void 0, 0], ZAR: [void 0, "R"], ZMK: [void 0, void 0, 0], ZMW: [void 0, "ZK"], ZWD: [void 0, void 0, 0] }; var T = function (t) { return t[t.Decimal = 0] = "Decimal", t[t.Percent = 1] = "Percent", t[t.Currency = 2] = "Currency", t[t.Scientific = 3] = "Scientific", t }({}), k = function (t) { return t[t.Zero = 0] = "Zero", t[t.One = 1] = "One", t[t.Two = 2] = "Two", t[t.Few = 3] = "Few", t[t.Many = 4] = "Many", t[t.Other = 5] = "Other", t }({}), j = function (t) { return t[t.Format = 0] = "Format", t[t.Standalone = 1] = "Standalone", t }({}), A = function (t) { return t[t.Narrow = 0] = "Narrow", t[t.Abbreviated = 1] = "Abbreviated", t[t.Wide = 2] = "Wide", t[t.Short = 3] = "Short", t }({}), R = function (t) { return t[t.Short = 0] = "Short", t[t.Medium = 1] = "Medium", t[t.Long = 2] = "Long", t[t.Full = 3] = "Full", t }({}), L = function (t) { return t[t.Decimal = 0] = "Decimal", t[t.Group = 1] = "Group", t[t.List = 2] = "List", t[t.PercentSign = 3] = "PercentSign", t[t.PlusSign = 4] = "PlusSign", t[t.MinusSign = 5] = "MinusSign", t[t.Exponential = 6] = "Exponential", t[t.SuperscriptingExponent = 7] = "SuperscriptingExponent", t[t.PerMille = 8] = "PerMille", t[t[1 / 0] = 9] = "Infinity", t[t.NaN = 10] = "NaN", t[t.TimeSeparator = 11] = "TimeSeparator", t[t.CurrencyDecimal = 12] = "CurrencyDecimal", t[t.CurrencyGroup = 13] = "CurrencyGroup", t }({}); function I(t, e) { return V(Object(s.lb)(t)[s.cb.DateFormat], e) } function P(t, e) { return V(Object(s.lb)(t)[s.cb.TimeFormat], e) } function D(t, e) { return V(Object(s.lb)(t)[s.cb.DateTimeFormat], e) } function M(t, e) { const n = Object(s.lb)(t), r = n[s.cb.NumberSymbols][e]; if (void 0 === r) { if (e === L.CurrencyDecimal) return n[s.cb.NumberSymbols][L.Decimal]; if (e === L.CurrencyGroup) return n[s.cb.NumberSymbols][L.Group] } return r } const N = s.ob; function F(t) { if (!t[s.cb.ExtraData]) throw new Error(`Missing extra locale data for the locale "${t[s.cb.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`) } function V(t, e) { for (let n = e; n > -1; n--)if (void 0 !== t[n]) return t[n]; throw new Error("Locale data API: locale data undefined") } function B(t) { const [e, n] = t.split(":"); return { hours: +e, minutes: +n } } const U = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/, H = {}, z = /((?:[^GyYMLwWdEabBhHmsSzZO']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/; var $ = function (t) { return t[t.Short = 0] = "Short", t[t.ShortGMT = 1] = "ShortGMT", t[t.Long = 2] = "Long", t[t.Extended = 3] = "Extended", t }({}), W = function (t) { return t[t.FullYear = 0] = "FullYear", t[t.Month = 1] = "Month", t[t.Date = 2] = "Date", t[t.Hours = 3] = "Hours", t[t.Minutes = 4] = "Minutes", t[t.Seconds = 5] = "Seconds", t[t.FractionalSeconds = 6] = "FractionalSeconds", t[t.Day = 7] = "Day", t }({}), q = function (t) { return t[t.DayPeriods = 0] = "DayPeriods", t[t.Days = 1] = "Days", t[t.Months = 2] = "Months", t[t.Eras = 3] = "Eras", t }({}); function G(t, e, n, s) { let r = function (t) { if (ot(t)) return t; if ("number" == typeof t && !isNaN(t)) return new Date(t); if ("string" == typeof t) { if (t = t.trim(), /^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(t)) { const [e, n = 1, s = 1] = t.split("-").map(t => +t); return X(e, n - 1, s) } const e = parseFloat(t); if (!isNaN(t - e)) return new Date(e); let n; if (n = t.match(U)) return function (t) { const e = new Date(0); let n = 0, s = 0; const r = t[8] ? e.setUTCFullYear : e.setFullYear, i = t[8] ? e.setUTCHours : e.setHours; t[9] && (n = Number(t[9] + t[10]), s = Number(t[9] + t[11])), r.call(e, Number(t[1]), Number(t[2]) - 1, Number(t[3])); const o = Number(t[4] || 0) - n, a = Number(t[5] || 0) - s, c = Number(t[6] || 0), l = Math.floor(1e3 * parseFloat("0." + (t[7] || 0))); return i.call(e, o, a, c, l), e }(n) } const e = new Date(t); if (!ot(e)) throw new Error(`Unable to convert "${t}" into a date`); return e }(t); e = K(n, e) || e; let i, o = []; for (; e;) { if (i = z.exec(e), !i) { o.push(e); break } { o = o.concat(i.slice(1)); const t = o.pop(); if (!t) break; e = t } } let a = r.getTimezoneOffset(); s && (a = it(s, a), r = function (t, e, n) { const s = t.getTimezoneOffset(); return function (t, e) { return (t = new Date(t.getTime())).setMinutes(t.getMinutes() + e), t }(t, -1 * (it(e, s) - s)) }(r, s)); let c = ""; return o.forEach(t => { const e = function (t) { if (rt[t]) return rt[t]; let e; switch (t) { case "G": case "GG": case "GGG": e = J(q.Eras, A.Abbreviated); break; case "GGGG": e = J(q.Eras, A.Wide); break; case "GGGGG": e = J(q.Eras, A.Narrow); break; case "y": e = Q(W.FullYear, 1, 0, !1, !0); break; case "yy": e = Q(W.FullYear, 2, 0, !0, !0); break; case "yyy": e = Q(W.FullYear, 3, 0, !1, !0); break; case "yyyy": e = Q(W.FullYear, 4, 0, !1, !0); break; case "Y": e = st(1); break; case "YY": e = st(2, !0); break; case "YYY": e = st(3); break; case "YYYY": e = st(4); break; case "M": case "L": e = Q(W.Month, 1, 1); break; case "MM": case "LL": e = Q(W.Month, 2, 1); break; case "MMM": e = J(q.Months, A.Abbreviated); break; case "MMMM": e = J(q.Months, A.Wide); break; case "MMMMM": e = J(q.Months, A.Narrow); break; case "LLL": e = J(q.Months, A.Abbreviated, j.Standalone); break; case "LLLL": e = J(q.Months, A.Wide, j.Standalone); break; case "LLLLL": e = J(q.Months, A.Narrow, j.Standalone); break; case "w": e = nt(1); break; case "ww": e = nt(2); break; case "W": e = nt(1, !0); break; case "d": e = Q(W.Date, 1); break; case "dd": e = Q(W.Date, 2); break; case "E": case "EE": case "EEE": e = J(q.Days, A.Abbreviated); break; case "EEEE": e = J(q.Days, A.Wide); break; case "EEEEE": e = J(q.Days, A.Narrow); break; case "EEEEEE": e = J(q.Days, A.Short); break; case "a": case "aa": case "aaa": e = J(q.DayPeriods, A.Abbreviated); break; case "aaaa": e = J(q.DayPeriods, A.Wide); break; case "aaaaa": e = J(q.DayPeriods, A.Narrow); break; case "b": case "bb": case "bbb": e = J(q.DayPeriods, A.Abbreviated, j.Standalone, !0); break; case "bbbb": e = J(q.DayPeriods, A.Wide, j.Standalone, !0); break; case "bbbbb": e = J(q.DayPeriods, A.Narrow, j.Standalone, !0); break; case "B": case "BB": case "BBB": e = J(q.DayPeriods, A.Abbreviated, j.Format, !0); break; case "BBBB": e = J(q.DayPeriods, A.Wide, j.Format, !0); break; case "BBBBB": e = J(q.DayPeriods, A.Narrow, j.Format, !0); break; case "h": e = Q(W.Hours, 1, -12); break; case "hh": e = Q(W.Hours, 2, -12); break; case "H": e = Q(W.Hours, 1); break; case "HH": e = Q(W.Hours, 2); break; case "m": e = Q(W.Minutes, 1); break; case "mm": e = Q(W.Minutes, 2); break; case "s": e = Q(W.Seconds, 1); break; case "ss": e = Q(W.Seconds, 2); break; case "S": e = Q(W.FractionalSeconds, 1); break; case "SS": e = Q(W.FractionalSeconds, 2); break; case "SSS": e = Q(W.FractionalSeconds, 3); break; case "Z": case "ZZ": case "ZZZ": e = tt($.Short); break; case "ZZZZZ": e = tt($.Extended); break; case "O": case "OO": case "OOO": case "z": case "zz": case "zzz": e = tt($.ShortGMT); break; case "OOOO": case "ZZZZ": case "zzzz": e = tt($.Long); break; default: return null }return rt[t] = e, e }(t); c += e ? e(r, n, a) : "''" === t ? "'" : t.replace(/(^'|'$)/g, "").replace(/''/g, "'") }), c } function X(t, e, n) { const s = new Date(0); return s.setFullYear(t, e, n), s.setHours(0, 0, 0), s } function K(t, e) { const n = function (t) { return Object(s.lb)(t)[s.cb.LocaleId] }(t); if (H[n] = H[n] || {}, H[n][e]) return H[n][e]; let r = ""; switch (e) { case "shortDate": r = I(t, R.Short); break; case "mediumDate": r = I(t, R.Medium); break; case "longDate": r = I(t, R.Long); break; case "fullDate": r = I(t, R.Full); break; case "shortTime": r = P(t, R.Short); break; case "mediumTime": r = P(t, R.Medium); break; case "longTime": r = P(t, R.Long); break; case "fullTime": r = P(t, R.Full); break; case "short": const e = K(t, "shortTime"), n = K(t, "shortDate"); r = Z(D(t, R.Short), [e, n]); break; case "medium": const s = K(t, "mediumTime"), i = K(t, "mediumDate"); r = Z(D(t, R.Medium), [s, i]); break; case "long": const o = K(t, "longTime"), a = K(t, "longDate"); r = Z(D(t, R.Long), [o, a]); break; case "full": const c = K(t, "fullTime"), l = K(t, "fullDate"); r = Z(D(t, R.Full), [c, l]) }return r && (H[n][e] = r), r } function Z(t, e) { return e && (t = t.replace(/\{([^}]+)}/g, function (t, n) { return null != e && n in e ? e[n] : t })), t } function Y(t, e, n = "-", s, r) { let i = ""; (t < 0 || r && t <= 0) && (r ? t = 1 - t : (t = -t, i = n)); let o = String(t); for (; o.length < e;)o = "0" + o; return s && (o = o.substr(o.length - e)), i + o } function Q(t, e, n = 0, s = !1, r = !1) { return function (i, o) { let a = function (t, e) { switch (t) { case W.FullYear: return e.getFullYear(); case W.Month: return e.getMonth(); case W.Date: return e.getDate(); case W.Hours: return e.getHours(); case W.Minutes: return e.getMinutes(); case W.Seconds: return e.getSeconds(); case W.FractionalSeconds: return e.getMilliseconds(); case W.Day: return e.getDay(); default: throw new Error(`Unknown DateType value "${t}".`) } }(t, i); if ((n > 0 || a > -n) && (a += n), t === W.Hours) 0 === a && -12 === n && (a = 12); else if (t === W.FractionalSeconds) return c = e, Y(a, 3).substr(0, c); var c; const l = M(o, L.MinusSign); return Y(a, e, l, s, r) } } function J(t, e, n = j.Format, r = !1) { return function (i, o) { return function (t, e, n, r, i, o) { switch (n) { case q.Months: return function (t, e, n) { const r = Object(s.lb)(t), i = V([r[s.cb.MonthsFormat], r[s.cb.MonthsStandalone]], e); return V(i, n) }(e, i, r)[t.getMonth()]; case q.Days: return function (t, e, n) { const r = Object(s.lb)(t), i = V([r[s.cb.DaysFormat], r[s.cb.DaysStandalone]], e); return V(i, n) }(e, i, r)[t.getDay()]; case q.DayPeriods: const a = t.getHours(), c = t.getMinutes(); if (o) { const t = function (t) { const e = Object(s.lb)(t); return F(e), (e[s.cb.ExtraData][2] || []).map(t => "string" == typeof t ? B(t) : [B(t[0]), B(t[1])]) }(e), n = function (t, e, n) { const r = Object(s.lb)(t); F(r); const i = V([r[s.cb.ExtraData][0], r[s.cb.ExtraData][1]], e) || []; return V(i, n) || [] }(e, i, r), o = t.findIndex(t => { if (Array.isArray(t)) { const [e, n] = t, s = a >= e.hours && c >= e.minutes, r = a < n.hours || a === n.hours && c < n.minutes; if (e.hours < n.hours) { if (s && r) return !0 } else if (s || r) return !0 } else if (t.hours === a && t.minutes === c) return !0; return !1 }); if (-1 !== o) return n[o] } return function (t, e, n) { const r = Object(s.lb)(t), i = V([r[s.cb.DayPeriodsFormat], r[s.cb.DayPeriodsStandalone]], e); return V(i, n) }(e, i, r)[a < 12 ? 0 : 1]; case q.Eras: return function (t, e) { return V(Object(s.lb)(t)[s.cb.Eras], e) }(e, r)[t.getFullYear() <= 0 ? 0 : 1]; default: throw new Error(`unexpected translation type ${n}`) } }(i, o, t, e, n, r) } } function tt(t) { return function (e, n, s) { const r = -1 * s, i = M(n, L.MinusSign), o = r > 0 ? Math.floor(r / 60) : Math.ceil(r / 60); switch (t) { case $.Short: return (r >= 0 ? "+" : "") + Y(o, 2, i) + Y(Math.abs(r % 60), 2, i); case $.ShortGMT: return "GMT" + (r >= 0 ? "+" : "") + Y(o, 1, i); case $.Long: return "GMT" + (r >= 0 ? "+" : "") + Y(o, 2, i) + ":" + Y(Math.abs(r % 60), 2, i); case $.Extended: return 0 === s ? "Z" : (r >= 0 ? "+" : "") + Y(o, 2, i) + ":" + Y(Math.abs(r % 60), 2, i); default: throw new Error(`Unknown zone width "${t}"`) } } } function et(t) { return X(t.getFullYear(), t.getMonth(), t.getDate() + (4 - t.getDay())) } function nt(t, e = !1) { return function (n, s) { let r; if (e) { const t = new Date(n.getFullYear(), n.getMonth(), 1).getDay() - 1, e = n.getDate(); r = 1 + Math.floor((e + t) / 7) } else { const t = et(n), e = function (t) { const e = X(t, 0, 1).getDay(); return X(t, 0, 1 + (e <= 4 ? 4 : 11) - e) }(t.getFullYear()), s = t.getTime() - e.getTime(); r = 1 + Math.round(s / 6048e5) } return Y(r, t, M(s, L.MinusSign)) } } function st(t, e = !1) { return function (n, s) { return Y(et(n).getFullYear(), t, M(s, L.MinusSign), e) } } const rt = {}; function it(t, e) { t = t.replace(/:/g, ""); const n = Date.parse("Jan 01, 1970 00:00:00 " + t) / 6e4; return isNaN(n) ? e : n } function ot(t) { return t instanceof Date && !isNaN(t.valueOf()) } const at = /^(\d+)?\.((\d+)(-(\d+))?)?$/; function ct(t) { const e = parseInt(t); if (isNaN(e)) throw new Error("Invalid integer literal when parsing " + t); return e } class lt { } let ut = (() => { class t extends lt { constructor(t) { super(), this.locale = t } getPluralCategory(t, e) { switch (N(e || this.locale)(t)) { case k.Zero: return "zero"; case k.One: return "one"; case k.Two: return "two"; case k.Few: return "few"; case k.Many: return "many"; default: return "other" } } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(s.v)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); function ht(t, e, n) { return Object(s.vb)(t, e, n) } function dt(t, e) { e = encodeURIComponent(e); for (const n of t.split(";")) { const t = n.indexOf("="), [s, r] = -1 == t ? [n, ""] : [n.slice(0, t), n.slice(t + 1)]; if (s.trim() === e) return decodeURIComponent(r) } return null } let pt = (() => { class t { constructor(t, e, n, s) { this._iterableDiffers = t, this._keyValueDiffers = e, this._ngEl = n, this._renderer = s, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null } set klass(t) { this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof t ? t.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass) } set ngClass(t) { this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof t ? t.split(/\s+/) : t, this._rawClass && (Object(s.rb)(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create()) } ngDoCheck() { if (this._iterableDiffer) { const t = this._iterableDiffer.diff(this._rawClass); t && this._applyIterableChanges(t) } else if (this._keyValueDiffer) { const t = this._keyValueDiffer.diff(this._rawClass); t && this._applyKeyValueChanges(t) } } _applyKeyValueChanges(t) { t.forEachAddedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachChangedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachRemovedItem(t => { t.previousValue && this._toggleClass(t.key, !1) }) } _applyIterableChanges(t) { t.forEachAddedItem(t => { if ("string" != typeof t.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${Object(s.xb)(t.item)}`); this._toggleClass(t.item, !0) }), t.forEachRemovedItem(t => this._toggleClass(t.item, !1)) } _applyClasses(t) { t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !0)) : Object.keys(t).forEach(e => this._toggleClass(e, !!t[e]))) } _removeClasses(t) { t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !1)) : Object.keys(t).forEach(t => this._toggleClass(t, !1))) } _toggleClass(t, e) { (t = t.trim()) && t.split(/\s+/g).forEach(t => { e ? this._renderer.addClass(this._ngEl.nativeElement, t) : this._renderer.removeClass(this._ngEl.nativeElement, t) }) } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.t), s.Rb(s.u), s.Rb(s.l), s.Rb(s.F)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" } }), t })(), ft = (() => { class t { constructor(t) { this._viewContainerRef = t, this._componentRef = null, this._moduleRef = null } ngOnChanges(t) { if (this._viewContainerRef.clear(), this._componentRef = null, this.ngComponentOutlet) { const e = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector; if (t.ngComponentOutletNgModuleFactory) if (this._moduleRef && this._moduleRef.destroy(), this.ngComponentOutletNgModuleFactory) { const t = e.get(s.y); this._moduleRef = this.ngComponentOutletNgModuleFactory.create(t.injector) } else this._moduleRef = null; const n = (this._moduleRef ? this._moduleRef.componentFactoryResolver : e.get(s.j)).resolveComponentFactory(this.ngComponentOutlet); this._componentRef = this._viewContainerRef.createComponent(n, this._viewContainerRef.length, e, this.ngComponentOutletContent) } } ngOnDestroy() { this._moduleRef && this._moduleRef.destroy() } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.R)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "ngComponentOutlet", ""]], inputs: { ngComponentOutlet: "ngComponentOutlet", ngComponentOutletInjector: "ngComponentOutletInjector", ngComponentOutletContent: "ngComponentOutletContent", ngComponentOutletNgModuleFactory: "ngComponentOutletNgModuleFactory" }, features: [s.Ab] }), t })(); class gt { constructor(t, e, n, s) { this.$implicit = t, this.ngForOf = e, this.index = n, this.count = s } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let mt = (() => { class t { constructor(t, e, n) { this._viewContainer = t, this._template = e, this._differs = n, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(t) { this._ngForOf = t, this._ngForOfDirty = !0 } set ngForTrackBy(t) { this._trackByFn = t } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(t) { t && (this._template = t) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; if (!this._differ && n) try { this._differ = this._differs.find(n).create(this.ngForTrackBy) } catch (e) { throw new Error(`Cannot find a differ supporting object '${n}' of type '${t = n, t.name || typeof t}'. NgFor only supports binding to Iterables such as Arrays.`) } } var t; if (this._differ) { const t = this._differ.diff(this._ngForOf); t && this._applyChanges(t) } } _applyChanges(t) { const e = []; t.forEachOperation((t, n, s) => { if (null == t.previousIndex) { const n = this._viewContainer.createEmbeddedView(this._template, new gt(null, this._ngForOf, -1, -1), null === s ? void 0 : s), r = new bt(t, n); e.push(r) } else if (null == s) this._viewContainer.remove(null === n ? void 0 : n); else if (null !== n) { const r = this._viewContainer.get(n); this._viewContainer.move(r, s); const i = new bt(t, r); e.push(i) } }); for (let n = 0; n < e.length; n++)this._perViewChange(e[n].view, e[n].record); for (let n = 0, s = this._viewContainer.length; n < s; n++) { const t = this._viewContainer.get(n); t.context.index = n, t.context.count = s, t.context.ngForOf = this._ngForOf } t.forEachIdentityChange(t => { this._viewContainer.get(t.currentIndex).context.$implicit = t.item }) } _perViewChange(t, e) { t.context.$implicit = e.item } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.R), s.Rb(s.N), s.Rb(s.t)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }), t })(); class bt { constructor(t, e) { this.record = t, this.view = e } } let _t = (() => { class t { constructor(t, e) { this._viewContainer = t, this._context = new vt, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = e } set ngIf(t) { this._context.$implicit = this._context.ngIf = t, this._updateView() } set ngIfThen(t) { yt("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView() } set ngIfElse(t) { yt("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.R), s.Rb(s.N)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), t })(); class vt { constructor() { this.$implicit = null, this.ngIf = null } } function yt(t, e) { if (e && !e.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${Object(s.xb)(e)}'.`) } class wt { constructor(t, e) { this._viewContainerRef = t, this._templateRef = e, this._created = !1 } create() { this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef) } destroy() { this._created = !1, this._viewContainerRef.clear() } enforceState(t) { t && !this._created ? this.create() : !t && this._created && this.destroy() } } let Ct = (() => { class t { constructor() { this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1 } set ngSwitch(t) { this._ngSwitch = t, 0 === this._caseCount && this._updateDefaultCases(!0) } _addCase() { return this._caseCount++ } _addDefault(t) { this._defaultViews || (this._defaultViews = []), this._defaultViews.push(t) } _matchCase(t) { const e = t == this._ngSwitch; return this._lastCasesMatched = this._lastCasesMatched || e, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), e } _updateDefaultCases(t) { if (this._defaultViews && t !== this._defaultUsed) { this._defaultUsed = t; for (let e = 0; e < this._defaultViews.length; e++)this._defaultViews[e].enforceState(t) } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "ngSwitch", ""]], inputs: { ngSwitch: "ngSwitch" } }), t })(), Ot = (() => { class t { constructor(t, e, n) { this.ngSwitch = n, n._addCase(), this._view = new wt(t, e) } ngDoCheck() { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)) } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.R), s.Rb(s.N), s.Rb(Ct, 1)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "ngSwitchCase", ""]], inputs: { ngSwitchCase: "ngSwitchCase" } }), t })(), St = (() => { class t { constructor(t, e, n) { this._ngEl = t, this._differs = e, this._renderer = n, this._ngStyle = null, this._differ = null } set ngStyle(t) { this._ngStyle = t, !this._differ && t && (this._differ = this._differs.find(t).create()) } ngDoCheck() { if (this._differ) { const t = this._differ.diff(this._ngStyle); t && this._applyChanges(t) } } _setStyle(t, e) { const [n, s] = t.split("."); null != (e = null != e && s ? `${e}${s}` : e) ? this._renderer.setStyle(this._ngEl.nativeElement, n, e) : this._renderer.removeStyle(this._ngEl.nativeElement, n) } _applyChanges(t) { t.forEachRemovedItem(t => this._setStyle(t.key, null)), t.forEachAddedItem(t => this._setStyle(t.key, t.currentValue)), t.forEachChangedItem(t => this._setStyle(t.key, t.currentValue)) } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.l), s.Rb(s.u), s.Rb(s.F)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "ngStyle", ""]], inputs: { ngStyle: "ngStyle" } }), t })(), xt = (() => { class t { constructor(t) { this._viewContainerRef = t, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null } ngOnChanges(t) { if (this._shouldRecreateView(t)) { const t = this._viewContainerRef; this._viewRef && t.remove(t.indexOf(this._viewRef)), this._viewRef = this.ngTemplateOutlet ? t.createEmbeddedView(this.ngTemplateOutlet, this.ngTemplateOutletContext) : null } else this._viewRef && this.ngTemplateOutletContext && this._updateExistingContext(this.ngTemplateOutletContext) } _shouldRecreateView(t) { const e = t.ngTemplateOutletContext; return !!t.ngTemplateOutlet || e && this._hasContextShapeChanged(e) } _hasContextShapeChanged(t) { const e = Object.keys(t.previousValue || {}), n = Object.keys(t.currentValue || {}); if (e.length === n.length) { for (let t of n) if (-1 === e.indexOf(t)) return !0; return !1 } return !0 } _updateExistingContext(t) { for (let e of Object.keys(t)) this._viewRef.context[e] = this.ngTemplateOutletContext[e] } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.R)) }, t.\u0275dir = s.Mb({ type: t, selectors: [["", "ngTemplateOutlet", ""]], inputs: { ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet" }, features: [s.Ab] }), t })(); function Et(t, e) { return Error(`InvalidPipeArgument: '${e}' for pipe '${Object(s.xb)(t)}'`) } class Tt { createSubscription(t, e) { return t.subscribe({ next: e, error: t => { throw t } }) } dispose(t) { t.unsubscribe() } onDestroy(t) { t.unsubscribe() } } class kt { createSubscription(t, e) { return t.then(e, t => { throw t }) } dispose(t) { } onDestroy(t) { } } const jt = new kt, At = new Tt; let Rt = (() => { class t { constructor(t) { this._ref = t, this._latestValue = null, this._subscription = null, this._obj = null, this._strategy = null } ngOnDestroy() { this._subscription && this._dispose() } transform(t) { return this._obj ? t !== this._obj ? (this._dispose(), this.transform(t)) : this._latestValue : (t && this._subscribe(t), this._latestValue) } _subscribe(t) { this._obj = t, this._strategy = this._selectStrategy(t), this._subscription = this._strategy.createSubscription(t, e => this._updateLatestValue(t, e)) } _selectStrategy(e) { if (Object(s.tb)(e)) return jt; if (Object(s.ub)(e)) return At; throw Et(t, e) } _dispose() { this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null } _updateLatestValue(t, e) { t === this._obj && (this._latestValue = e, this._ref.markForCheck()) } } return t.\u0275fac = function (e) { return new (e || t)(s.dc()) }, t.\u0275pipe = s.Qb({ name: "async", type: t, pure: !1 }), t })(), Lt = (() => { class t { transform(e) { if (null == e) return null; if ("string" != typeof e) throw Et(t, e); return e.toUpperCase() } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275pipe = s.Qb({ name: "uppercase", type: t, pure: !0 }), t })(), It = (() => { class t { constructor(t) { this.locale = t } transform(e, n = "mediumDate", s, r) { if (null == e || "" === e || e != e) return null; try { return G(e, n, r || this.locale, s) } catch (i) { throw Et(t, i.message) } } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.v)) }, t.\u0275pipe = s.Qb({ name: "date", type: t, pure: !0 }), t })(), Pt = (() => { class t { constructor(t, e = "USD") { this._locale = t, this._defaultCurrencyCode = e } transform(e, n, r = "symbol", i, o) { if (!function (t) { return !(null == t || "" === t || t != t) }(e)) return null; o = o || this._locale, "boolean" == typeof r && (r = r ? "symbol" : "code"); let a = n || this._defaultCurrencyCode; "code" !== r && (a = "symbol" === r || "symbol-narrow" === r ? function (t, e, n = "en") { const r = function (t) { return Object(s.lb)(t)[s.cb.Currencies] }(n)[t] || E[t] || [], i = r[1]; return "narrow" === e && "string" == typeof i ? i : r[0] || t }(a, "symbol" === r ? "wide" : "narrow", o) : r); try { return function (t, e, n, r, i) { const o = function (t, e = "-") { const n = { minInt: 1, minFrac: 0, maxFrac: 0, posPre: "", posSuf: "", negPre: "", negSuf: "", gSize: 0, lgSize: 0 }, s = t.split(";"), r = s[0], i = s[1], o = -1 !== r.indexOf(".") ? r.split(".") : [r.substring(0, r.lastIndexOf("0") + 1), r.substring(r.lastIndexOf("0") + 1)], a = o[0], c = o[1] || ""; n.posPre = a.substr(0, a.indexOf("#")); for (let u = 0; u < c.length; u++) { const t = c.charAt(u); "0" === t ? n.minFrac = n.maxFrac = u + 1 : "#" === t ? n.maxFrac = u + 1 : n.posSuf += t } const l = a.split(","); if (n.gSize = l[1] ? l[1].length : 0, n.lgSize = l[2] || l[1] ? (l[2] || l[1]).length : 0, i) { const t = r.length - n.posPre.length - n.posSuf.length, e = i.indexOf("#"); n.negPre = i.substr(0, e).replace(/'/g, ""), n.negSuf = i.substr(e + t).replace(/'/g, "") } else n.negPre = e + n.posPre, n.negSuf = n.posSuf; return n }(function (t, e) { return Object(s.lb)(t)[s.cb.NumberFormats][e] }(e, T.Currency), M(e, L.MinusSign)); return o.minFrac = function (t) { let e; const n = E[t]; return n && (e = n[2]), "number" == typeof e ? e : 2 }(r), o.maxFrac = o.minFrac, function (t, e, n, s, r, i, o = !1) { let a = "", c = !1; if (isFinite(t)) { let l = function (t) { let e, n, s, r, i, o = Math.abs(t) + "", a = 0; for ((n = o.indexOf(".")) > -1 && (o = o.replace(".", "")), (s = o.search(/e/i)) > 0 ? (n < 0 && (n = s), n += +o.slice(s + 1), o = o.substring(0, s)) : n < 0 && (n = o.length), s = 0; "0" === o.charAt(s); s++); if (s === (i = o.length)) e = [0], n = 1; else { for (i--; "0" === o.charAt(i);)i--; for (n -= s, e = [], r = 0; s <= i; s++, r++)e[r] = Number(o.charAt(s)) } return n > 22 && (e = e.splice(0, 21), a = n - 1, n = 1), { digits: e, exponent: a, integerLen: n } }(t); o && (l = function (t) { if (0 === t.digits[0]) return t; const e = t.digits.length - t.integerLen; return t.exponent ? t.exponent += 2 : (0 === e ? t.digits.push(0, 0) : 1 === e && t.digits.push(0), t.integerLen += 2), t }(l)); let u = e.minInt, h = e.minFrac, d = e.maxFrac; if (i) { const t = i.match(at); if (null === t) throw new Error(`${i} is not a valid digit info`); const e = t[1], n = t[3], s = t[5]; null != e && (u = ct(e)), null != n && (h = ct(n)), null != s ? d = ct(s) : null != n && h > d && (d = h) } !function (t, e, n) { if (e > n) throw new Error(`The minimum number of digits after fraction (${e}) is higher than the maximum (${n}).`); let s = t.digits, r = s.length - t.integerLen; const i = Math.min(Math.max(e, r), n); let o = i + t.integerLen, a = s[o]; if (o > 0) { s.splice(Math.max(t.integerLen, o)); for (let t = o; t < s.length; t++)s[t] = 0 } else { r = Math.max(0, r), t.integerLen = 1, s.length = Math.max(1, o = i + 1), s[0] = 0; for (let t = 1; t < o; t++)s[t] = 0 } if (a >= 5) if (o - 1 < 0) { for (let e = 0; e > o; e--)s.unshift(0), t.integerLen++; s.unshift(1), t.integerLen++ } else s[o - 1]++; for (; r < Math.max(0, i); r++)s.push(0); let c = 0 !== i; const l = e + t.integerLen, u = s.reduceRight(function (t, e, n, s) { return s[n] = (e += t) < 10 ? e : e - 10, c && (0 === s[n] && n >= l ? s.pop() : c = !1), e >= 10 ? 1 : 0 }, 0); u && (s.unshift(u), t.integerLen++) }(l, h, d); let p = l.digits, f = l.integerLen; const g = l.exponent; let m = []; for (c = p.every(t => !t); f < u; f++)p.unshift(0); for (; f < 0; f++)p.unshift(0); f > 0 ? m = p.splice(f, p.length) : (m = p, p = [0]); const b = []; for (p.length >= e.lgSize && b.unshift(p.splice(-e.lgSize, p.length).join("")); p.length > e.gSize;)b.unshift(p.splice(-e.gSize, p.length).join("")); p.length && b.unshift(p.join("")), a = b.join(M(n, s)), m.length && (a += M(n, r) + m.join("")), g && (a += M(n, L.Exponential) + "+" + g) } else a = M(n, L.Infinity); return a = t < 0 && !c ? e.negPre + a + e.negSuf : e.posPre + a + e.posSuf, a }(t, o, e, L.CurrencyGroup, L.CurrencyDecimal, i).replace("\xa4", n).replace("\xa4", "").trim() }(function (t) { if ("string" == typeof t && !isNaN(Number(t) - parseFloat(t))) return Number(t); if ("number" != typeof t) throw new Error(`${t} is not a number`); return t }(e), o, a, n, i) } catch (c) { throw Et(t, c.message) } } } return t.\u0275fac = function (e) { return new (e || t)(s.Rb(s.v), s.Rb(s.k)) }, t.\u0275pipe = s.Qb({ name: "currency", type: t, pure: !0 }), t })(), Dt = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = s.Pb({ type: t }), t.\u0275inj = s.Ob({ providers: [{ provide: lt, useClass: ut }] }), t })(); const Mt = "browser"; function Nt(t) { return t === Mt } let Ft = (() => { class t { } return t.\u0275prov = Object(s.Nb)({ token: t, providedIn: "root", factory: () => new Vt(Object(s.bc)(c), window) }), t })(); class Vt { constructor(t, e) { this.document = t, this.window = e, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (!this.supportsScrolling()) return; const e = function (t, e) { const n = t.getElementById(e) || t.getElementsByName(e)[0]; if (n) return n; if ("function" == typeof t.createTreeWalker && t.body && (t.body.createShadowRoot || t.body.attachShadow)) { const n = t.createTreeWalker(t.body, NodeFilter.SHOW_ELEMENT); let s = n.currentNode; for (; s;) { const t = s.shadowRoot; if (t) { const n = t.getElementById(e) || t.querySelector(`[name="${e}"]`); if (n) return n } s = n.nextNode() } } return null }(this.document, t); e && (this.scrollToElement(e), this.attemptFocus(e)) } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const e = this.window.history; e && e.scrollRestoration && (e.scrollRestoration = t) } } scrollToElement(t) { const e = t.getBoundingClientRect(), n = e.left + this.window.pageXOffset, s = e.top + this.window.pageYOffset, r = this.offset(); this.window.scrollTo(n - r[0], s - r[1]) } attemptFocus(t) { return t.focus(), this.document.activeElement === t } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const t = Bt(this.window.history) || Bt(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch (t) { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch (t) { return !1 } } } function Bt(t) { return Object.getOwnPropertyDescriptor(t, "scrollRestoration") } }, pLZG: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("7o/Q"); function r(t, e) { return function (n) { return n.lift(new i(t, e)) } } class i { constructor(t, e) { this.predicate = t, this.thisArg = e } call(t, e) { return e.subscribe(new o(t, this.predicate, this.thisArg)) } } class o extends s.a { constructor(t, e, n) { super(t), this.predicate = e, this.thisArg = n, this.count = 0 } _next(t) { let e; try { e = this.predicate.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } e && this.destination.next(t) } } }, piIK: function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }); var s = n("/Tr7"), r = n("jIYg"); function i(t) { Object(r.a)(1, arguments); var e = Object(s.a)(t); return e.setHours(23, 59, 59, 999), e } }, pxpQ: function (t, e, n) { "use strict"; n.d(e, "b", function () { return i }), n.d(e, "a", function () { return a }); var s = n("7o/Q"), r = n("WMd4"); function i(t, e = 0) { return function (n) { return n.lift(new o(t, e)) } } class o { constructor(t, e = 0) { this.scheduler = t, this.delay = e } call(t, e) { return e.subscribe(new a(t, this.scheduler, this.delay)) } } class a extends s.a { constructor(t, e, n = 0) { super(t), this.scheduler = e, this.delay = n } static dispatch(t) { const { notification: e, destination: n } = t; e.observe(n), this.unsubscribe() } scheduleMessage(t) { this.destination.add(this.scheduler.schedule(a.dispatch, this.delay, new c(t, this.destination))) } _next(t) { this.scheduleMessage(r.a.createNext(t)) } _error(t) { this.scheduleMessage(r.a.createError(t)), this.unsubscribe() } _complete() { this.scheduleMessage(r.a.createComplete()), this.unsubscribe() } } class c { constructor(t, e) { this.notification = t, this.destination = e } } }, qgXg: function (t, e, n) { "use strict"; n.d(e, "b", function () { return a }), n.d(e, "a", function () { return c }); var s = n("3N8a"); class r extends s.a { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } schedule(t, e = 0) { return e > 0 ? super.schedule(t, e) : (this.delay = e, this.state = t, this.scheduler.flush(this), this) } execute(t, e) { return e > 0 || this.closed ? super.execute(t, e) : this._execute(t, e) } requestAsyncId(t, e, n = 0) { return null !== n && n > 0 || null === n && this.delay > 0 ? super.requestAsyncId(t, e, n) : t.flush(this) } } var i = n("IjjT"); class o extends i.a { } const a = new o(r), c = a }, quSY: function (t, e, n) { "use strict"; n.d(e, "a", function () { return a }); var s = n("DH7j"), r = n("XoHu"), i = n("n6bG"); const o = (() => { function t(t) { return Error.call(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((t, e) => `${e + 1}) ${t.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t, this } return t.prototype = Object.create(Error.prototype), t })(); let a = (() => { class t { constructor(t) { this.closed = !1, this._parentOrParents = null, this._subscriptions = null, t && (this._ctorUnsubscribe = !0, this._unsubscribe = t) } unsubscribe() { let e; if (this.closed) return; let { _parentOrParents: n, _ctorUnsubscribe: a, _unsubscribe: l, _subscriptions: u } = this; if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, n instanceof t) n.remove(this); else if (null !== n) for (let t = 0; t < n.length; ++t)n[t].remove(this); if (Object(i.a)(l)) { a && (this._unsubscribe = void 0); try { l.call(this) } catch (h) { e = h instanceof o ? c(h.errors) : [h] } } if (Object(s.a)(u)) { let t = -1, n = u.length; for (; ++t < n;) { const n = u[t]; if (Object(r.a)(n)) try { n.unsubscribe() } catch (h) { e = e || [], h instanceof o ? e = e.concat(c(h.errors)) : e.push(h) } } } if (e) throw new o(e) } add(e) { let n = e; if (!e) return t.EMPTY; switch (typeof e) { case "function": n = new t(e); case "object": if (n === this || n.closed || "function" != typeof n.unsubscribe) return n; if (this.closed) return n.unsubscribe(), n; if (!(n instanceof t)) { const e = n; n = new t, n._subscriptions = [e] } break; default: throw new Error("unrecognized teardown " + e + " added to Subscription.") }let { _parentOrParents: s } = n; if (null === s) n._parentOrParents = this; else if (s instanceof t) { if (s === this) return n; n._parentOrParents = [s, this] } else { if (-1 !== s.indexOf(this)) return n; s.push(this) } const r = this._subscriptions; return null === r ? this._subscriptions = [n] : r.push(n), n } remove(t) { const e = this._subscriptions; if (e) { const n = e.indexOf(t); -1 !== n && e.splice(n, 1) } } } var e; return t.EMPTY = ((e = new t).closed = !0, e), t })(); function c(t) { return t.reduce((t, e) => t.concat(e instanceof o ? e.errors : e), []) } }, sVev: function (t, e, n) { "use strict"; n.d(e, "a", function () { return s }); const s = (() => { function t() { return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this } return t.prototype = Object.create(Error.prototype), t })() }, sYmb: function (t, e, n) { "use strict"; n.d(e, "a", function () { return b }), n.d(e, "b", function () { return f }), n.d(e, "c", function () { return P }), n.d(e, "d", function () { return I }); var s = n("fXoL"), r = n("LRne"), i = n("7+OI"), o = n("cp0P"), a = n("GyhO"), c = n("NXyV"), l = n("IzEk"), u = n("UXun"), h = n("lJxs"), d = n("bOdf"), p = n("eIep"); class f { } let g = (() => { class t extends f { getTranslation(t) { return Object(r.a)({}) } } return t.\u0275fac = function (e) { return m(e || t) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); const m = s.Zb(g); class b { } let _ = (() => { class t { handle(t) { return t.key } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); function v(t) { return null != t } function y(t) { return t && "object" == typeof t && !Array.isArray(t) } function w(t, e) { let n = Object.assign({}, t); return y(t) && y(e) && Object.keys(e).forEach(s => { y(e[s]) ? s in t ? n[s] = w(t[s], e[s]) : Object.assign(n, { [s]: e[s] }) : Object.assign(n, { [s]: e[s] }) }), n } class C { } let O = (() => { class t extends C { constructor() { super(...arguments), this.templateMatcher = /{{\s?([^{}\s]*)\s?}}/g } interpolate(t, e) { let n; return n = "string" == typeof t ? this.interpolateString(t, e) : "function" == typeof t ? this.interpolateFunction(t, e) : t, n } getValue(t, e) { let n = "string" == typeof e ? e.split(".") : [e]; e = ""; do { e += n.shift(), !v(t) || !v(t[e]) || "object" != typeof t[e] && n.length ? n.length ? e += "." : t = void 0 : (t = t[e], e = "") } while (n.length); return t } interpolateFunction(t, e) { return t(e) } interpolateString(t, e) { return e ? t.replace(this.templateMatcher, (t, n) => { let s = this.getValue(e, n); return v(s) ? s : t }) : t } } return t.\u0275fac = function (e) { return S(e || t) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); const S = s.Zb(O); class x { } let E = (() => { class t extends x { compile(t, e) { return t } compileTranslations(t, e) { return t } } return t.\u0275fac = function (e) { return T(e || t) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); const T = s.Zb(E); class k { constructor() { this.currentLang = this.defaultLang, this.translations = {}, this.langs = [], this.onTranslationChange = new s.n, this.onLangChange = new s.n, this.onDefaultLangChange = new s.n } } const j = new s.r("USE_STORE"), A = new s.r("USE_DEFAULT_LANG"), R = new s.r("DEFAULT_LANGUAGE"), L = new s.r("USE_EXTEND"); let I = (() => { class t { constructor(t, e, n, r, i, o = !0, a = !1, c = !1, l) { this.store = t, this.currentLoader = e, this.compiler = n, this.parser = r, this.missingTranslationHandler = i, this.useDefaultLang = o, this.isolate = a, this.extend = c, this.pending = !1, this._onTranslationChange = new s.n, this._onLangChange = new s.n, this._onDefaultLangChange = new s.n, this._langs = [], this._translations = {}, this._translationRequests = {}, l && this.setDefaultLang(l) } get onTranslationChange() { return this.isolate ? this._onTranslationChange : this.store.onTranslationChange } get onLangChange() { return this.isolate ? this._onLangChange : this.store.onLangChange } get onDefaultLangChange() { return this.isolate ? this._onDefaultLangChange : this.store.onDefaultLangChange } get defaultLang() { return this.isolate ? this._defaultLang : this.store.defaultLang } set defaultLang(t) { this.isolate ? this._defaultLang = t : this.store.defaultLang = t } get currentLang() { return this.isolate ? this._currentLang : this.store.currentLang } set currentLang(t) { this.isolate ? this._currentLang = t : this.store.currentLang = t } get langs() { return this.isolate ? this._langs : this.store.langs } set langs(t) { this.isolate ? this._langs = t : this.store.langs = t } get translations() { return this.isolate ? this._translations : this.store.translations } set translations(t) { this.isolate ? this._translations = t : this.store.translations = t } setDefaultLang(t) { if (t === this.defaultLang) return; let e = this.retrieveTranslations(t); void 0 !== e ? (null == this.defaultLang && (this.defaultLang = t), e.pipe(Object(l.a)(1)).subscribe(e => { this.changeDefaultLang(t) })) : this.changeDefaultLang(t) } getDefaultLang() { return this.defaultLang } use(t) { if (t === this.currentLang) return Object(r.a)(this.translations[t]); let e = this.retrieveTranslations(t); return void 0 !== e ? (this.currentLang || (this.currentLang = t), e.pipe(Object(l.a)(1)).subscribe(e => { this.changeLang(t) }), e) : (this.changeLang(t), Object(r.a)(this.translations[t])) } retrieveTranslations(t) { let e; return (void 0 === this.translations[t] || this.extend) && (this._translationRequests[t] = this._translationRequests[t] || this.getTranslation(t), e = this._translationRequests[t]), e } getTranslation(t) { this.pending = !0; const e = this.currentLoader.getTranslation(t).pipe(Object(u.a)(1), Object(l.a)(1)); return this.loadingTranslations = e.pipe(Object(h.a)(e => this.compiler.compileTranslations(e, t)), Object(u.a)(1), Object(l.a)(1)), this.loadingTranslations.subscribe({ next: e => { this.translations[t] = this.extend && this.translations[t] ? Object.assign(Object.assign({}, e), this.translations[t]) : e, this.updateLangs(), this.pending = !1 }, error: t => { this.pending = !1 } }), e } setTranslation(t, e, n = !1) { e = this.compiler.compileTranslations(e, t), this.translations[t] = (n || this.extend) && this.translations[t] ? w(this.translations[t], e) : e, this.updateLangs(), this.onTranslationChange.emit({ lang: t, translations: this.translations[t] }) } getLangs() { return this.langs } addLangs(t) { t.forEach(t => { -1 === this.langs.indexOf(t) && this.langs.push(t) }) } updateLangs() { this.addLangs(Object.keys(this.translations)) } getParsedResult(t, e, n) { let s; if (e instanceof Array) { let s = {}, a = !1; for (let r of e) s[r] = this.getParsedResult(t, r, n), Object(i.a)(s[r]) && (a = !0); if (a) { const t = e.map(t => Object(i.a)(s[t]) ? s[t] : Object(r.a)(s[t])); return Object(o.a)(t).pipe(Object(h.a)(t => { let n = {}; return t.forEach((t, s) => { n[e[s]] = t }), n })) } return s } if (t && (s = this.parser.interpolate(this.parser.getValue(t, e), n)), void 0 === s && null != this.defaultLang && this.defaultLang !== this.currentLang && this.useDefaultLang && (s = this.parser.interpolate(this.parser.getValue(this.translations[this.defaultLang], e), n)), void 0 === s) { let t = { key: e, translateService: this }; void 0 !== n && (t.interpolateParams = n), s = this.missingTranslationHandler.handle(t) } return void 0 !== s ? s : e } get(t, e) { if (!v(t) || !t.length) throw new Error('Parameter "key" required'); if (this.pending) return this.loadingTranslations.pipe(Object(d.a)(n => (n = this.getParsedResult(n, t, e), Object(i.a)(n) ? n : Object(r.a)(n)))); { let n = this.getParsedResult(this.translations[this.currentLang], t, e); return Object(i.a)(n) ? n : Object(r.a)(n) } } getStreamOnTranslationChange(t, e) { if (!v(t) || !t.length) throw new Error('Parameter "key" required'); return Object(a.a)(Object(c.a)(() => this.get(t, e)), this.onTranslationChange.pipe(Object(p.a)(n => { const s = this.getParsedResult(n.translations, t, e); return "function" == typeof s.subscribe ? s : Object(r.a)(s) }))) } stream(t, e) { if (!v(t) || !t.length) throw new Error('Parameter "key" required'); return Object(a.a)(Object(c.a)(() => this.get(t, e)), this.onLangChange.pipe(Object(p.a)(n => { const s = this.getParsedResult(n.translations, t, e); return Object(i.a)(s) ? s : Object(r.a)(s) }))) } instant(t, e) { if (!v(t) || !t.length) throw new Error('Parameter "key" required'); let n = this.getParsedResult(this.translations[this.currentLang], t, e); if (Object(i.a)(n)) { if (t instanceof Array) { let e = {}; return t.forEach((n, s) => { e[t[s]] = t[s] }), e } return t } return n } set(t, e, n = this.currentLang) { this.translations[n][t] = this.compiler.compile(e, n), this.updateLangs(), this.onTranslationChange.emit({ lang: n, translations: this.translations[n] }) } changeLang(t) { this.currentLang = t, this.onLangChange.emit({ lang: t, translations: this.translations[t] }), null == this.defaultLang && this.changeDefaultLang(t) } changeDefaultLang(t) { this.defaultLang = t, this.onDefaultLangChange.emit({ lang: t, translations: this.translations[t] }) } reloadLang(t) { return this.resetLang(t), this.getTranslation(t) } resetLang(t) { this._translationRequests[t] = void 0, this.translations[t] = void 0 } getBrowserLang() { if ("undefined" == typeof window || void 0 === window.navigator) return; let t = window.navigator.languages ? window.navigator.languages[0] : null; return t = t || window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage, void 0 !== t ? (-1 !== t.indexOf("-") && (t = t.split("-")[0]), -1 !== t.indexOf("_") && (t = t.split("_")[0]), t) : void 0 } getBrowserCultureLang() { if ("undefined" == typeof window || void 0 === window.navigator) return; let t = window.navigator.languages ? window.navigator.languages[0] : null; return t = t || window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage, t } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(k), s.bc(f), s.bc(x), s.bc(C), s.bc(b), s.bc(A), s.bc(j), s.bc(L), s.bc(R)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(), P = (() => { class t { static forRoot(e = {}) { return { ngModule: t, providers: [e.loader || { provide: f, useClass: g }, e.compiler || { provide: x, useClass: E }, e.parser || { provide: C, useClass: O }, e.missingTranslationHandler || { provide: b, useClass: _ }, k, { provide: j, useValue: e.isolate }, { provide: A, useValue: e.useDefaultLang }, { provide: L, useValue: e.extend }, { provide: R, useValue: e.defaultLanguage }, I] } } static forChild(e = {}) { return { ngModule: t, providers: [e.loader || { provide: f, useClass: g }, e.compiler || { provide: x, useClass: E }, e.parser || { provide: C, useClass: O }, e.missingTranslationHandler || { provide: b, useClass: _ }, { provide: j, useValue: e.isolate }, { provide: A, useValue: e.useDefaultLang }, { provide: L, useValue: e.extend }, { provide: R, useValue: e.defaultLanguage }, I] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = s.Pb({ type: t }), t.\u0275inj = s.Ob({}), t })() }, tS1D: function (t, e, n) { "use strict"; n.d(e, "a", function () { return u }); var s = n("D0XW"); const r = (() => { function t() { return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this } return t.prototype = Object.create(Error.prototype), t })(); var i = n("mlxB"), o = n("zx2A"); class a { constructor(t, e, n, s) { this.waitFor = t, this.absoluteTimeout = e, this.withObservable = n, this.scheduler = s } call(t, e) { return e.subscribe(new c(t, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler)) } } class c extends o.b { constructor(t, e, n, s, r) { super(t), this.absoluteTimeout = e, this.waitFor = n, this.withObservable = s, this.scheduler = r, this.scheduleTimeout() } static dispatchTimeout(t) { const { withObservable: e } = t; t._unsubscribeAndRecycle(), t.add(Object(o.c)(e, new o.a(t))) } scheduleTimeout() { const { action: t } = this; t ? this.action = t.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(c.dispatchTimeout, this.waitFor, this)) } _next(t) { this.absoluteTimeout || this.scheduleTimeout(), super._next(t) } _unsubscribe() { this.action = void 0, this.scheduler = null, this.withObservable = null } } var l = n("z6cu"); function u(t, e = s.a) { return function (t, e, n = s.a) { return s => { let r = Object(i.a)(t), o = r ? +t - n.now() : Math.abs(t); return s.lift(new a(o, r, e, n)) } }(t, Object(l.a)(new r), e) } }, "tk/3": function (t, e, n) { "use strict"; n.d(e, "a", function () { return k }), n.d(e, "b", function () { return h }), n.d(e, "c", function () { return E }), n.d(e, "d", function () { return U }), n.d(e, "e", function () { return S }), n.d(e, "f", function () { return y }), n.d(e, "g", function () { return v }); var s = n("fXoL"), r = n("LRne"), i = n("HDdC"), o = n("bOdf"), a = n("pLZG"), c = n("lJxs"), l = n("ofXK"); class u { } class h { } class d { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(t => { const e = t.indexOf(":"); if (e > 0) { const n = t.slice(0, e), s = n.toLowerCase(), r = t.slice(e + 1).trim(); this.maybeSetNormalizedName(n, s), this.headers.has(s) ? this.headers.get(s).push(r) : this.headers.set(s, [r]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(e => { let n = t[e]; const s = e.toLowerCase(); "string" == typeof n && (n = [n]), n.length > 0 && (this.headers.set(s, n), this.maybeSetNormalizedName(e, s)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const e = this.headers.get(t.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, e) { return this.clone({ name: t, value: e, op: "a" }) } set(t, e) { return this.clone({ name: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ name: t, value: e, op: "d" }) } maybeSetNormalizedName(t, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, t) } init() { this.lazyInit && (this.lazyInit instanceof d ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(e => { this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e)) }) } clone(t) { const e = new d; return e.lazyInit = this.lazyInit && this.lazyInit instanceof d ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e } applyUpdate(t) { const e = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let n = t.value; if ("string" == typeof n && (n = [n]), 0 === n.length) return; this.maybeSetNormalizedName(t.name, e); const s = ("a" === t.op ? this.headers.get(e) : void 0) || []; s.push(...n), this.headers.set(e, s); break; case "d": const r = t.value; if (r) { let t = this.headers.get(e); if (!t) return; t = t.filter(t => -1 === r.indexOf(t)), 0 === t.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, t) } else this.headers.delete(e), this.normalizedNames.delete(e) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => t(this.normalizedNames.get(e), this.headers.get(e))) } } class p { encodeKey(t) { return f(t) } encodeValue(t) { return f(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } function f(t) { return encodeURIComponent(t).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/") } class g { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new p, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function (t, e) { const n = new Map; return t.length > 0 && t.replace(/^\?/, "").split("&").forEach(t => { const s = t.indexOf("="), [r, i] = -1 == s ? [e.decodeKey(t), ""] : [e.decodeKey(t.slice(0, s)), e.decodeValue(t.slice(s + 1))], o = n.get(r) || []; o.push(i), n.set(r, o) }), n }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(e => { const n = t.fromObject[e]; this.map.set(e, Array.isArray(n) ? n : [n]) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const e = this.map.get(t); return e ? e[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, e) { return this.clone({ param: t, value: e, op: "a" }) } appendAll(t) { const e = []; return Object.keys(t).forEach(n => { const s = t[n]; Array.isArray(s) ? s.forEach(t => { e.push({ param: n, value: t, op: "a" }) }) : e.push({ param: n, value: s, op: "a" }) }), this.clone(e) } set(t, e) { return this.clone({ param: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ param: t, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const e = this.encoder.encodeKey(t); return this.map.get(t).map(t => e + "=" + this.encoder.encodeValue(t)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const e = new g({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat(t), e } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const e = ("a" === t.op ? this.map.get(t.param) : void 0) || []; e.push(t.value), this.map.set(t.param, e); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let e = this.map.get(t.param) || []; const n = e.indexOf(t.value); -1 !== n && e.splice(n, 1), e.length > 0 ? this.map.set(t.param, e) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } function m(t) { return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer } function b(t) { return "undefined" != typeof Blob && t instanceof Blob } function _(t) { return "undefined" != typeof FormData && t instanceof FormData } class v { constructor(t, e, n, s) { let r; if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function (t) { switch (t) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || s ? (this.body = void 0 !== n ? n : null, r = s) : r = n, r && (this.reportProgress = !!r.reportProgress, this.withCredentials = !!r.withCredentials, r.responseType && (this.responseType = r.responseType), r.headers && (this.headers = r.headers), r.params && (this.params = r.params)), this.headers || (this.headers = new d), this.params) { const t = this.params.toString(); if (0 === t.length) this.urlWithParams = e; else { const n = e.indexOf("?"); this.urlWithParams = e + (-1 === n ? "?" : n < e.length - 1 ? "&" : "") + t } } else this.params = new g, this.urlWithParams = e } serializeBody() { return null === this.body ? null : m(this.body) || b(this.body) || _(this.body) || "string" == typeof this.body ? this.body : this.body instanceof g ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || _(this.body) ? null : b(this.body) ? this.body.type || null : m(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof g ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || Array.isArray(this.body) ? "application/json" : null } clone(t = {}) { const e = t.method || this.method, n = t.url || this.url, s = t.responseType || this.responseType, r = void 0 !== t.body ? t.body : this.body, i = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, o = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let a = t.headers || this.headers, c = t.params || this.params; return void 0 !== t.setHeaders && (a = Object.keys(t.setHeaders).reduce((e, n) => e.set(n, t.setHeaders[n]), a)), t.setParams && (c = Object.keys(t.setParams).reduce((e, n) => e.set(n, t.setParams[n]), c)), new v(e, n, r, { params: c, headers: a, reportProgress: o, responseType: s, withCredentials: i }) } } var y = function (t) { return t[t.Sent = 0] = "Sent", t[t.UploadProgress = 1] = "UploadProgress", t[t.ResponseHeader = 2] = "ResponseHeader", t[t.DownloadProgress = 3] = "DownloadProgress", t[t.Response = 4] = "Response", t[t.User = 5] = "User", t }({}); class w { constructor(t, e = 200, n = "OK") { this.headers = t.headers || new d, this.status = void 0 !== t.status ? t.status : e, this.statusText = t.statusText || n, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class C extends w { constructor(t = {}) { super(t), this.type = y.ResponseHeader } clone(t = {}) { return new C({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class O extends w { constructor(t = {}) { super(t), this.type = y.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new O({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class S extends w { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${t.url || "(unknown url)"}` : `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } } function x(t, e) { return { body: e, headers: t.headers, observe: t.observe, params: t.params, reportProgress: t.reportProgress, responseType: t.responseType, withCredentials: t.withCredentials } } let E = (() => { class t { constructor(t) { this.handler = t } request(t, e, n = {}) { let s; if (t instanceof v) s = t; else { let r, i; r = n.headers instanceof d ? n.headers : new d(n.headers), n.params && (i = n.params instanceof g ? n.params : new g({ fromObject: n.params })), s = new v(t, e, void 0 !== n.body ? n.body : null, { headers: r, params: i, reportProgress: n.reportProgress, responseType: n.responseType || "json", withCredentials: n.withCredentials }) } const i = Object(r.a)(s).pipe(Object(o.a)(t => this.handler.handle(t))); if (t instanceof v || "events" === n.observe) return i; const l = i.pipe(Object(a.a)(t => t instanceof O)); switch (n.observe || "body") { case "body": switch (s.responseType) { case "arraybuffer": return l.pipe(Object(c.a)(t => { if (null !== t.body && !(t.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return t.body })); case "blob": return l.pipe(Object(c.a)(t => { if (null !== t.body && !(t.body instanceof Blob)) throw new Error("Response is not a Blob."); return t.body })); case "text": return l.pipe(Object(c.a)(t => { if (null !== t.body && "string" != typeof t.body) throw new Error("Response is not a string."); return t.body })); case "json": default: return l.pipe(Object(c.a)(t => t.body)) }case "response": return l; default: throw new Error(`Unreachable: unhandled observe type ${n.observe}}`) } } delete(t, e = {}) { return this.request("DELETE", t, e) } get(t, e = {}) { return this.request("GET", t, e) } head(t, e = {}) { return this.request("HEAD", t, e) } jsonp(t, e) { return this.request("JSONP", t, { params: (new g).append(e, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(t, e = {}) { return this.request("OPTIONS", t, e) } patch(t, e, n = {}) { return this.request("PATCH", t, x(n, e)) } post(t, e, n = {}) { return this.request("POST", t, x(n, e)) } put(t, e, n = {}) { return this.request("PUT", t, x(n, e)) } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(u)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); class T { constructor(t, e) { this.next = t, this.interceptor = e } handle(t) { return this.interceptor.intercept(t, this.next) } } const k = new s.r("HTTP_INTERCEPTORS"); let j = (() => { class t { intercept(t, e) { return e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); const A = /^\)\]\}',?\n/; class R { } let L = (() => { class t { constructor() { } build() { return new XMLHttpRequest } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(), I = (() => { class t { constructor(t) { this.xhrFactory = t } handle(t) { if ("JSONP" === t.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new i.a(e => { const n = this.xhrFactory.build(); if (n.open(t.method, t.urlWithParams), t.withCredentials && (n.withCredentials = !0), t.headers.forEach((t, e) => n.setRequestHeader(t, e.join(","))), t.headers.has("Accept") || n.setRequestHeader("Accept", "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const e = t.detectContentTypeHeader(); null !== e && n.setRequestHeader("Content-Type", e) } if (t.responseType) { const e = t.responseType.toLowerCase(); n.responseType = "json" !== e ? e : "text" } const s = t.serializeBody(); let r = null; const i = () => { if (null !== r) return r; const e = 1223 === n.status ? 204 : n.status, s = n.statusText || "OK", i = new d(n.getAllResponseHeaders()), o = function (t) { return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null }(n) || t.url; return r = new C({ headers: i, status: e, statusText: s, url: o }), r }, o = () => { let { headers: s, status: r, statusText: o, url: a } = i(), c = null; 204 !== r && (c = void 0 === n.response ? n.responseText : n.response), 0 === r && (r = c ? 200 : 0); let l = r >= 200 && r < 300; if ("json" === t.responseType && "string" == typeof c) { const t = c; c = c.replace(A, ""); try { c = "" !== c ? JSON.parse(c) : null } catch (u) { c = t, l && (l = !1, c = { error: u, text: c }) } } l ? (e.next(new O({ body: c, headers: s, status: r, statusText: o, url: a || void 0 })), e.complete()) : e.error(new S({ error: c, headers: s, status: r, statusText: o, url: a || void 0 })) }, a = t => { const { url: s } = i(), r = new S({ error: t, status: n.status || 0, statusText: n.statusText || "Unknown Error", url: s || void 0 }); e.error(r) }; let c = !1; const l = s => { c || (e.next(i()), c = !0); let r = { type: y.DownloadProgress, loaded: s.loaded }; s.lengthComputable && (r.total = s.total), "text" === t.responseType && n.responseText && (r.partialText = n.responseText), e.next(r) }, u = t => { let n = { type: y.UploadProgress, loaded: t.loaded }; t.lengthComputable && (n.total = t.total), e.next(n) }; return n.addEventListener("load", o), n.addEventListener("error", a), n.addEventListener("timeout", a), n.addEventListener("abort", a), t.reportProgress && (n.addEventListener("progress", l), null !== s && n.upload && n.upload.addEventListener("progress", u)), n.send(s), e.next({ type: y.Sent }), () => { n.removeEventListener("error", a), n.removeEventListener("abort", a), n.removeEventListener("load", o), n.removeEventListener("timeout", a), t.reportProgress && (n.removeEventListener("progress", l), null !== s && n.upload && n.upload.removeEventListener("progress", u)), n.readyState !== n.DONE && n.abort() } }) } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(R)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(); const P = new s.r("XSRF_COOKIE_NAME"), D = new s.r("XSRF_HEADER_NAME"); class M { } let N = (() => { class t { constructor(t, e, n) { this.doc = t, this.platform = e, this.cookieName = n, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const t = this.doc.cookie || ""; return t !== this.lastCookieString && (this.parseCount++, this.lastToken = Object(l.D)(t, this.cookieName), this.lastCookieString = t), this.lastToken } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(l.e), s.bc(s.C), s.bc(P)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(), F = (() => { class t { constructor(t, e) { this.tokenService = t, this.headerName = e } intercept(t, e) { const n = t.url.toLowerCase(); if ("GET" === t.method || "HEAD" === t.method || n.startsWith("http://") || n.startsWith("https://")) return e.handle(t); const s = this.tokenService.getToken(); return null === s || t.headers.has(this.headerName) || (t = t.clone({ headers: t.headers.set(this.headerName, s) })), e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(M), s.bc(D)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(), V = (() => { class t { constructor(t, e) { this.backend = t, this.injector = e, this.chain = null } handle(t) { if (null === this.chain) { const t = this.injector.get(k, []); this.chain = t.reduceRight((t, e) => new T(t, e), this.backend) } return this.chain.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(s.bc(h), s.bc(s.s)) }, t.\u0275prov = s.Nb({ token: t, factory: t.\u0275fac }), t })(), B = (() => { class t { static disable() { return { ngModule: t, providers: [{ provide: F, useClass: j }] } } static withOptions(e = {}) { return { ngModule: t, providers: [e.cookieName ? { provide: P, useValue: e.cookieName } : [], e.headerName ? { provide: D, useValue: e.headerName } : []] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = s.Pb({ type: t }), t.\u0275inj = s.Ob({ providers: [F, { provide: k, useExisting: F, multi: !0 }, { provide: M, useClass: N }, { provide: P, useValue: "XSRF-TOKEN" }, { provide: D, useValue: "X-XSRF-TOKEN" }] }), t })(), U = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = s.Pb({ type: t }), t.\u0275inj = s.Ob({ providers: [E, { provide: u, useClass: V }, I, { provide: h, useExisting: I }, L, { provide: R, useExisting: L }], imports: [[B.withOptions({ cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN" })]] }), t })() }, tyNb: function (t, e, n) { "use strict"; n.d(e, "a", function () { return zt }), n.d(e, "b", function () { return J }), n.d(e, "c", function () { return wt }), n.d(e, "d", function () { return U }), n.d(e, "e", function () { return B }), n.d(e, "f", function () { return H }), n.d(e, "g", function () { return V }), n.d(e, "h", function () { return et }), n.d(e, "i", function () { return un }), n.d(e, "j", function () { return fn }), n.d(e, "k", function () { return dn }), n.d(e, "l", function () { return xn }), n.d(e, "m", function () { return gn }), n.d(e, "n", function () { return z }), n.d(e, "o", function () { return _t }), n.d(e, "p", function () { return bt }), n.d(e, "q", function () { return yt }), n.d(e, "r", function () { return mt }); var s = n("ofXK"), r = n("fXoL"), i = n("Cfvw"), o = n("LRne"), a = n("2Vo4"), c = n("itXk"), l = n("HDdC"), u = n("sVev"), h = n("GyhO"), d = n("NXyV"), p = n("EY2u"), f = n("EQ5u"), g = n("XNiG"), m = n("lJxs"), b = n("eIep"), _ = n("IzEk"), v = n("JX91"), y = n("Kqap"), w = n("pLZG"), C = n("JIr8"), O = n("bOdf"), S = n("7o/Q"), x = n("4I5i"); function E(t) { return function (e) { return 0 === t ? Object(p.b)() : e.lift(new T(t)) } } class T { constructor(t) { if (this.total = t, this.total < 0) throw new x.a } call(t, e) { return e.subscribe(new k(t, this.total)) } } class k extends S.a { constructor(t, e) { super(t), this.total = e, this.ring = new Array, this.count = 0 } _next(t) { const e = this.ring, n = this.total, s = this.count++; e.length < n ? e.push(t) : e[s % n] = t } _complete() { const t = this.destination; let e = this.count; if (e > 0) { const n = this.count >= this.total ? this.total : this.count, s = this.ring; for (let r = 0; r < n; r++) { const r = e++ % n; t.next(s[r]) } } t.complete() } } var j = n("XDbj"), A = n("xbPD"), R = n("SpAZ"), L = n("SxV6"), I = n("5+tZ"), P = n("vkgz"), D = n("x+ZX"), M = n("nYR2"), N = n("bHdf"); class F { constructor(t, e) { this.id = t, this.url = e } } class V extends F { constructor(t, e, n = "imperative", s = null) { super(t, e), this.navigationTrigger = n, this.restoredState = s } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class B extends F { constructor(t, e, n) { super(t, e), this.urlAfterRedirects = n } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class U extends F { constructor(t, e, n) { super(t, e), this.reason = n } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class H extends F { constructor(t, e, n) { super(t, e), this.error = n } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class z extends F { constructor(t, e, n, s) { super(t, e), this.urlAfterRedirects = n, this.state = s } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class $ extends F { constructor(t, e, n, s) { super(t, e), this.urlAfterRedirects = n, this.state = s } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class W extends F { constructor(t, e, n, s, r) { super(t, e), this.urlAfterRedirects = n, this.state = s, this.shouldActivate = r } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class q extends F { constructor(t, e, n, s) { super(t, e), this.urlAfterRedirects = n, this.state = s } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class G extends F { constructor(t, e, n, s) { super(t, e), this.urlAfterRedirects = n, this.state = s } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class X { constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class K { constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class Z { constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Y { constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Q { constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class J { constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class tt { constructor(t, e, n) { this.routerEvent = t, this.position = e, this.anchor = n } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } const et = "primary"; class nt { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e[0] : e } return null } getAll(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } } function st(t) { return new nt(t) } function rt(t) { const e = Error("NavigationCancelingError: " + t); return e.ngNavigationCancelingError = !0, e } function it(t, e, n) { const s = n.path.split("/"); if (s.length > t.length) return null; if ("full" === n.pathMatch && (e.hasChildren() || s.length < t.length)) return null; const r = {}; for (let i = 0; i < s.length; i++) { const e = s[i], n = t[i]; if (e.startsWith(":")) r[e.substring(1)] = n; else if (e !== n.path) return null } return { consumed: t.slice(0, s.length), posParams: r } } function ot(t, e) { const n = t ? Object.keys(t) : void 0, s = e ? Object.keys(e) : void 0; if (!n || !s || n.length != s.length) return !1; let r; for (let i = 0; i < n.length; i++)if (r = n[i], !at(t[r], e[r])) return !1; return !0 } function at(t, e) { if (Array.isArray(t) && Array.isArray(e)) { if (t.length !== e.length) return !1; const n = [...t].sort(), s = [...e].sort(); return n.every((t, e) => s[e] === t) } return t === e } function ct(t) { return Array.prototype.concat.apply([], t) } function lt(t) { return t.length > 0 ? t[t.length - 1] : null } function ut(t, e) { for (const n in t) t.hasOwnProperty(n) && e(t[n], n) } function ht(t) { return Object(r.sb)(t) ? t : Object(r.tb)(t) ? Object(i.a)(Promise.resolve(t)) : Object(o.a)(t) } function dt(t, e, n) { return n ? function (t, e) { return ot(t, e) }(t.queryParams, e.queryParams) && pt(t.root, e.root) : function (t, e) { return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(n => at(t[n], e[n])) }(t.queryParams, e.queryParams) && ft(t.root, e.root) } function pt(t, e) { if (!vt(t.segments, e.segments)) return !1; if (t.numberOfChildren !== e.numberOfChildren) return !1; for (const n in e.children) { if (!t.children[n]) return !1; if (!pt(t.children[n], e.children[n])) return !1 } return !0 } function ft(t, e) { return gt(t, e, e.segments) } function gt(t, e, n) { if (t.segments.length > n.length) return !!vt(t.segments.slice(0, n.length), n) && !e.hasChildren(); if (t.segments.length === n.length) { if (!vt(t.segments, n)) return !1; for (const n in e.children) { if (!t.children[n]) return !1; if (!ft(t.children[n], e.children[n])) return !1 } return !0 } { const s = n.slice(0, t.segments.length), r = n.slice(t.segments.length); return !!vt(t.segments, s) && !!t.children[et] && gt(t.children[et], e, r) } } class mt { constructor(t, e, n) { this.root = t, this.queryParams = e, this.fragment = n } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = st(this.queryParams)), this._queryParamMap } toString() { return Ct.serialize(this) } } class bt { constructor(t, e) { this.segments = t, this.children = e, this.parent = null, ut(e, (t, e) => t.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Ot(this) } } class _t { constructor(t, e) { this.path = t, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = st(this.parameters)), this._parameterMap } toString() { return At(this) } } function vt(t, e) { return t.length === e.length && t.every((t, n) => t.path === e[n].path) } class yt { } class wt { parse(t) { const e = new Dt(t); return new mt(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(t) { var e; return `/${St(t.root, !0)}${function (t) { const e = Object.keys(t).map(e => { const n = t[e]; return Array.isArray(n) ? n.map(t => `${Et(e)}=${Et(t)}`).join("&") : `${Et(e)}=${Et(n)}` }); return e.length ? `?${e.join("&")}` : "" }(t.queryParams)}${"string" == typeof t.fragment ? `#${e = t.fragment, encodeURI(e)}` : ""}` } } const Ct = new wt; function Ot(t) { return t.segments.map(t => At(t)).join("/") } function St(t, e) { if (!t.hasChildren()) return Ot(t); if (e) { const e = t.children[et] ? St(t.children[et], !1) : "", n = []; return ut(t.children, (t, e) => { e !== et && n.push(`${e}:${St(t, !1)}`) }), n.length > 0 ? `${e}(${n.join("//")})` : e } { const e = function (t, e) { let n = []; return ut(t.children, (t, s) => { s === et && (n = n.concat(e(t, s))) }), ut(t.children, (t, s) => { s !== et && (n = n.concat(e(t, s))) }), n }(t, (e, n) => n === et ? [St(t.children[et], !1)] : [`${n}:${St(e, !1)}`]); return 1 === Object.keys(t.children).length && null != t.children[et] ? `${Ot(t)}/${e[0]}` : `${Ot(t)}/(${e.join("//")})` } } function xt(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Et(t) { return xt(t).replace(/%3B/gi, ";") } function Tt(t) { return xt(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function kt(t) { return decodeURIComponent(t) } function jt(t) { return kt(t.replace(/\+/g, "%20")) } function At(t) { return `${Tt(t.path)}${e = t.parameters, Object.keys(e).map(t => `;${Tt(t)}=${Tt(e[t])}`).join("")}`; var e } const Rt = /^[^\/()?;=#]+/; function Lt(t) { const e = t.match(Rt); return e ? e[0] : "" } const It = /^[^=?&#]+/, Pt = /^[^?&#]+/; class Dt { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new bt([], {}) : new bt([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let n = {}; return this.peekStartsWith("(") && (n = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (n[et] = new bt(t, e)), n } parseSegment() { const t = Lt(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(t), new _t(kt(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const e = Lt(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = Lt(this.remaining); t && (n = t, this.capture(n)) } t[kt(e)] = kt(n) } parseQueryParam(t) { const e = function (t) { const e = t.match(It); return e ? e[0] : "" }(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = function (t) { const e = t.match(Pt); return e ? e[0] : "" }(this.remaining); t && (n = t, this.capture(n)) } const s = jt(e), r = jt(n); if (t.hasOwnProperty(s)) { let e = t[s]; Array.isArray(e) || (e = [e], t[s] = e), e.push(r) } else t[s] = r } parseParens(t) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const n = Lt(this.remaining), s = this.remaining[n.length]; if ("/" !== s && ")" !== s && ";" !== s) throw new Error(`Cannot parse url '${this.url}'`); let r; n.indexOf(":") > -1 ? (r = n.substr(0, n.indexOf(":")), this.capture(r), this.capture(":")) : t && (r = et); const i = this.parseChildren(); e[r] = 1 === Object.keys(i).length ? i[et] : new bt([], i), this.consumeOptional("//") } return e } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`) } } class Mt { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const e = this.pathFromRoot(t); return e.length > 1 ? e[e.length - 2] : null } children(t) { const e = Nt(t, this._root); return e ? e.children.map(t => t.value) : [] } firstChild(t) { const e = Nt(t, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(t) { const e = Ft(t, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(t => t.value).filter(e => e !== t) } pathFromRoot(t) { return Ft(t, this._root).map(t => t.value) } } function Nt(t, e) { if (t === e.value) return e; for (const n of e.children) { const e = Nt(t, n); if (e) return e } return null } function Ft(t, e) { if (t === e.value) return [e]; for (const n of e.children) { const s = Ft(t, n); if (s.length) return s.unshift(e), s } return [] } class Vt { constructor(t, e) { this.value = t, this.children = e } toString() { return `TreeNode(${this.value})` } } function Bt(t) { const e = {}; return t && t.children.forEach(t => e[t.value.outlet] = t), e } class Ut extends Mt { constructor(t, e) { super(t), this.snapshot = e, Gt(this, t) } toString() { return this.snapshot.toString() } } function Ht(t, e) { const n = function (t, e) { const n = new Wt([], {}, {}, "", {}, et, e, null, t.root, -1, {}); return new qt("", new Vt(n, [])) }(t, e), s = new a.a([new _t("", {})]), r = new a.a({}), i = new a.a({}), o = new a.a({}), c = new a.a(""), l = new zt(s, r, o, c, i, et, e, n.root); return l.snapshot = n.root, new Ut(new Vt(l, []), n) } class zt { constructor(t, e, n, s, r, i, o, a) { this.url = t, this.params = e, this.queryParams = n, this.fragment = s, this.data = r, this.outlet = i, this.component = o, this._futureSnapshot = a } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(Object(m.a)(t => st(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(Object(m.a)(t => st(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function $t(t, e = "emptyOnly") { const n = t.pathFromRoot; let s = 0; if ("always" !== e) for (s = n.length - 1; s >= 1;) { const t = n[s], e = n[s - 1]; if (t.routeConfig && "" === t.routeConfig.path) s--; else { if (e.component) break; s-- } } return function (t) { return t.reduce((t, e) => ({ params: Object.assign(Object.assign({}, t.params), e.params), data: Object.assign(Object.assign({}, t.data), e.data), resolve: Object.assign(Object.assign({}, t.resolve), e._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(n.slice(s)) } class Wt { constructor(t, e, n, s, r, i, o, a, c, l, u) { this.url = t, this.params = e, this.queryParams = n, this.fragment = s, this.data = r, this.outlet = i, this.component = o, this.routeConfig = a, this._urlSegment = c, this._lastPathIndex = l, this._resolve = u } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = st(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = st(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(t => t.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class qt extends Mt { constructor(t, e) { super(e), this.url = t, Gt(this, e) } toString() { return Xt(this._root) } } function Gt(t, e) { e.value._routerState = t, e.children.forEach(e => Gt(t, e)) } function Xt(t) { const e = t.children.length > 0 ? ` { ${t.children.map(Xt).join(", ")} } ` : ""; return `${t.value}${e}` } function Kt(t) { if (t.snapshot) { const e = t.snapshot, n = t._futureSnapshot; t.snapshot = n, ot(e.queryParams, n.queryParams) || t.queryParams.next(n.queryParams), e.fragment !== n.fragment && t.fragment.next(n.fragment), ot(e.params, n.params) || t.params.next(n.params), function (t, e) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; ++n)if (!ot(t[n], e[n])) return !1; return !0 }(e.url, n.url) || t.url.next(n.url), ot(e.data, n.data) || t.data.next(n.data) } else t.snapshot = t._futureSnapshot, t.data.next(t._futureSnapshot.data) } function Zt(t, e) { var n, s; return ot(t.params, e.params) && vt(n = t.url, s = e.url) && n.every((t, e) => ot(t.parameters, s[e].parameters)) && !(!t.parent != !e.parent) && (!t.parent || Zt(t.parent, e.parent)) } function Yt(t, e, n) { if (n && t.shouldReuseRoute(e.value, n.value.snapshot)) { const s = n.value; s._futureSnapshot = e.value; const r = function (t, e, n) { return e.children.map(e => { for (const s of n.children) if (t.shouldReuseRoute(e.value, s.value.snapshot)) return Yt(t, e, s); return Yt(t, e) }) }(t, e, n); return new Vt(s, r) } { if (t.shouldAttach(e.value)) { const n = t.retrieve(e.value); if (null !== n) { const t = n.route; return Qt(e, t), t } } const n = new zt(new a.a((s = e.value).url), new a.a(s.params), new a.a(s.queryParams), new a.a(s.fragment), new a.a(s.data), s.outlet, s.component, s), r = e.children.map(e => Yt(t, e)); return new Vt(n, r) } var s } function Qt(t, e) { if (t.value.routeConfig !== e.value.routeConfig) throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route"); if (t.children.length !== e.children.length) throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children"); e.value._futureSnapshot = t.value; for (let n = 0; n < t.children.length; ++n)Qt(t.children[n], e.children[n]) } function Jt(t) { return "object" == typeof t && null != t && !t.outlets && !t.segmentPath } function te(t) { return "object" == typeof t && null != t && t.outlets } function ee(t, e, n, s, r) { let i = {}; return s && ut(s, (t, e) => { i[e] = Array.isArray(t) ? t.map(t => `${t}`) : `${t}` }), new mt(n.root === t ? e : ne(n.root, t, e), i, r) } function ne(t, e, n) { const s = {}; return ut(t.children, (t, r) => { s[r] = t === e ? n : ne(t, e, n) }), new bt(t.segments, s) } class se { constructor(t, e, n) { if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = n, t && n.length > 0 && Jt(n[0])) throw new Error("Root segment cannot have matrix parameters"); const s = n.find(te); if (s && s !== lt(n)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class re { constructor(t, e, n) { this.segmentGroup = t, this.processChildren = e, this.index = n } } function ie(t, e, n) { if (t || (t = new bt([], {})), 0 === t.segments.length && t.hasChildren()) return oe(t, e, n); const s = function (t, e, n) { let s = 0, r = e; const i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; r < t.segments.length;) { if (s >= n.length) return i; const e = t.segments[r], o = n[s]; if (te(o)) break; const a = `${o}`, c = s < n.length - 1 ? n[s + 1] : null; if (r > 0 && void 0 === a) break; if (a && c && "object" == typeof c && void 0 === c.outlets) { if (!ue(a, c, e)) return i; s += 2 } else { if (!ue(a, {}, e)) return i; s++ } r++ } return { match: !0, pathIndex: r, commandIndex: s } }(t, e, n), r = n.slice(s.commandIndex); if (s.match && s.pathIndex < t.segments.length) { const e = new bt(t.segments.slice(0, s.pathIndex), {}); return e.children[et] = new bt(t.segments.slice(s.pathIndex), t.children), oe(e, 0, r) } return s.match && 0 === r.length ? new bt(t.segments, {}) : s.match && !t.hasChildren() ? ae(t, e, n) : s.match ? oe(t, 0, r) : ae(t, e, n) } function oe(t, e, n) { if (0 === n.length) return new bt(t.segments, {}); { const s = function (t) { return te(t[0]) ? t[0].outlets : { [et]: t } }(n), r = {}; return ut(s, (n, s) => { "string" == typeof n && (n = [n]), null !== n && (r[s] = ie(t.children[s], e, n)) }), ut(t.children, (t, e) => { void 0 === s[e] && (r[e] = t) }), new bt(t.segments, r) } } function ae(t, e, n) { const s = t.segments.slice(0, e); let r = 0; for (; r < n.length;) { const i = n[r]; if (te(i)) { const t = ce(i.outlets); return new bt(s, t) } if (0 === r && Jt(n[0])) { s.push(new _t(t.segments[e].path, le(n[0]))), r++; continue } const o = te(i) ? i.outlets[et] : `${i}`, a = r < n.length - 1 ? n[r + 1] : null; o && a && Jt(a) ? (s.push(new _t(o, le(a))), r += 2) : (s.push(new _t(o, {})), r++) } return new bt(s, {}) } function ce(t) { const e = {}; return ut(t, (t, n) => { "string" == typeof t && (t = [t]), null !== t && (e[n] = ae(new bt([], {}), 0, t)) }), e } function le(t) { const e = {}; return ut(t, (t, n) => e[n] = `${t}`), e } function ue(t, e, n) { return t == n.path && ot(e, n.parameters) } class he { constructor(t, e, n, s) { this.routeReuseStrategy = t, this.futureState = e, this.currState = n, this.forwardEvent = s } activate(t) { const e = this.futureState._root, n = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, n, t), Kt(this.futureState.root), this.activateChildRoutes(e, n, t) } deactivateChildRoutes(t, e, n) { const s = Bt(e); t.children.forEach(t => { const e = t.value.outlet; this.deactivateRoutes(t, s[e], n), delete s[e] }), ut(s, (t, e) => { this.deactivateRouteAndItsChildren(t, n) }) } deactivateRoutes(t, e, n) { const s = t.value, r = e ? e.value : null; if (s === r) if (s.component) { const r = n.getContext(s.outlet); r && this.deactivateChildRoutes(t, e, r.children) } else this.deactivateChildRoutes(t, e, n); else r && this.deactivateRouteAndItsChildren(e, n) } deactivateRouteAndItsChildren(t, e) { this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e) } detachAndStoreRouteSubtree(t, e) { const n = e.getContext(t.value.outlet); if (n && n.outlet) { const e = n.outlet.detach(), s = n.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: e, route: t, contexts: s }) } } deactivateRouteAndOutlet(t, e) { const n = e.getContext(t.value.outlet), s = n && t.value.component ? n.children : e, r = Bt(t); for (const i of Object.keys(r)) this.deactivateRouteAndItsChildren(r[i], s); n && n.outlet && (n.outlet.deactivate(), n.children.onOutletDeactivated(), n.attachRef = null, n.resolver = null, n.route = null) } activateChildRoutes(t, e, n) { const s = Bt(e); t.children.forEach(t => { this.activateRoutes(t, s[t.value.outlet], n), this.forwardEvent(new J(t.value.snapshot)) }), t.children.length && this.forwardEvent(new Y(t.value.snapshot)) } activateRoutes(t, e, n) { const s = t.value, r = e ? e.value : null; if (Kt(s), s === r) if (s.component) { const r = n.getOrCreateContext(s.outlet); this.activateChildRoutes(t, e, r.children) } else this.activateChildRoutes(t, e, n); else if (s.component) { const e = n.getOrCreateContext(s.outlet); if (this.routeReuseStrategy.shouldAttach(s.snapshot)) { const t = this.routeReuseStrategy.retrieve(s.snapshot); this.routeReuseStrategy.store(s.snapshot, null), e.children.onOutletReAttached(t.contexts), e.attachRef = t.componentRef, e.route = t.route.value, e.outlet && e.outlet.attach(t.componentRef, t.route.value), de(t.route) } else { const n = function (t) { for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig; if (t && t.component) return null } return null }(s.snapshot), r = n ? n.module.componentFactoryResolver : null; e.attachRef = null, e.route = s, e.resolver = r, e.outlet && e.outlet.activateWith(s, r), this.activateChildRoutes(t, null, e.children) } } else this.activateChildRoutes(t, null, n) } } function de(t) { Kt(t.value), t.children.forEach(de) } class pe { constructor(t, e) { this.routes = t, this.module = e } } function fe(t) { return "function" == typeof t } function ge(t) { return t instanceof mt } const me = Symbol("INITIAL_VALUE"); function be() { return Object(b.a)(t => Object(c.a)(t.map(t => t.pipe(Object(_.a)(1), Object(v.a)(me)))).pipe(Object(y.a)((t, e) => { let n = !1; return e.reduce((t, s, r) => { if (t !== me) return t; if (s === me && (n = !0), !n) { if (!1 === s) return s; if (r === e.length - 1 || ge(s)) return s } return t }, t) }, me), Object(w.a)(t => t !== me), Object(m.a)(t => ge(t) ? t : !0 === t), Object(_.a)(1))) } let _e = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = r.Lb({ type: t, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (t, e) { 1 & t && r.Sb(0, "router-outlet") }, directives: function () { return [gn] }, encapsulation: 2 }), t })(); function ve(t, e = "") { for (let n = 0; n < t.length; n++) { const s = t[n]; ye(s, we(e, s)) } } function ye(t, e) { t.children && ve(t.children, e) } function we(t, e) { return e ? t || e.path ? t && !e.path ? `${t}/` : !t && e.path ? e.path : `${t}/${e.path}` : "" : t } function Ce(t) { const e = t.children && t.children.map(Ce), n = e ? Object.assign(Object.assign({}, t), { children: e }) : Object.assign({}, t); return !n.component && (e || n.loadChildren) && n.outlet && n.outlet !== et && (n.component = _e), n } function Oe(t) { return t.outlet || et } function Se(t, e) { const n = t.filter(t => Oe(t) === e); return n.push(...t.filter(t => Oe(t) !== e)), n } const xe = { matched: !1, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; function Ee(t, e, n) { var s; if ("" === e.path) return "full" === e.pathMatch && (t.hasChildren() || n.length > 0) ? Object.assign({}, xe) : { matched: !0, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; const r = (e.matcher || it)(n, t, e); if (!r) return Object.assign({}, xe); const i = {}; ut(r.posParams, (t, e) => { i[e] = t.path }); const o = r.consumed.length > 0 ? Object.assign(Object.assign({}, i), r.consumed[r.consumed.length - 1].parameters) : i; return { matched: !0, consumedSegments: r.consumed, lastChild: r.consumed.length, parameters: o, positionalParamSegments: null !== (s = r.posParams) && void 0 !== s ? s : {} } } function Te(t, e, n, s, r = "corrected") { if (n.length > 0 && function (t, e, n) { return n.some(n => ke(t, e, n) && Oe(n) !== et) }(t, n, s)) { const r = new bt(e, function (t, e, n, s) { const r = {}; r[et] = s, s._sourceSegment = t, s._segmentIndexShift = e.length; for (const i of n) if ("" === i.path && Oe(i) !== et) { const n = new bt([], {}); n._sourceSegment = t, n._segmentIndexShift = e.length, r[Oe(i)] = n } return r }(t, e, s, new bt(n, t.children))); return r._sourceSegment = t, r._segmentIndexShift = e.length, { segmentGroup: r, slicedSegments: [] } } if (0 === n.length && function (t, e, n) { return n.some(n => ke(t, e, n)) }(t, n, s)) { const i = new bt(t.segments, function (t, e, n, s, r, i) { const o = {}; for (const a of s) if (ke(t, n, a) && !r[Oe(a)]) { const n = new bt([], {}); n._sourceSegment = t, n._segmentIndexShift = "legacy" === i ? t.segments.length : e.length, o[Oe(a)] = n } return Object.assign(Object.assign({}, r), o) }(t, e, n, s, t.children, r)); return i._sourceSegment = t, i._segmentIndexShift = e.length, { segmentGroup: i, slicedSegments: n } } const i = new bt(t.segments, t.children); return i._sourceSegment = t, i._segmentIndexShift = e.length, { segmentGroup: i, slicedSegments: n } } function ke(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path } function je(t, e, n, s) { return !!(Oe(t) === s || s !== et && ke(e, n, t)) && ("**" === t.path || Ee(e, t, n).matched) } function Ae(t, e, n) { return 0 === e.length && !t.children[n] } class Re { constructor(t) { this.segmentGroup = t || null } } class Le { constructor(t) { this.urlTree = t } } function Ie(t) { return new l.a(e => e.error(new Re(t))) } function Pe(t) { return new l.a(e => e.error(new Le(t))) } function De(t) { return new l.a(e => e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`))) } class Me { constructor(t, e, n, s, i) { this.configLoader = e, this.urlSerializer = n, this.urlTree = s, this.config = i, this.allowRedirects = !0, this.ngModule = t.get(r.y) } apply() { const t = Te(this.urlTree.root, [], [], this.config).segmentGroup, e = new bt(t.segments, t.children); return this.expandSegmentGroup(this.ngModule, this.config, e, et).pipe(Object(m.a)(t => this.createUrlTree(Ne(t), this.urlTree.queryParams, this.urlTree.fragment))).pipe(Object(C.a)(t => { if (t instanceof Le) return this.allowRedirects = !1, this.match(t.urlTree); if (t instanceof Re) throw this.noMatchError(t); throw t })) } match(t) { return this.expandSegmentGroup(this.ngModule, this.config, t.root, et).pipe(Object(m.a)(e => this.createUrlTree(Ne(e), t.queryParams, t.fragment))).pipe(Object(C.a)(t => { if (t instanceof Re) throw this.noMatchError(t); throw t })) } noMatchError(t) { return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`) } createUrlTree(t, e, n) { const s = t.segments.length > 0 ? new bt([], { [et]: t }) : t; return new mt(s, e, n) } expandSegmentGroup(t, e, n, s) { return 0 === n.segments.length && n.hasChildren() ? this.expandChildren(t, e, n).pipe(Object(m.a)(t => new bt([], t))) : this.expandSegment(t, n, e, n.segments, s, !0) } expandChildren(t, e, n) { const s = []; for (const r of Object.keys(n.children)) "primary" === r ? s.unshift(r) : s.push(r); return Object(i.a)(s).pipe(Object(O.a)(s => { const r = n.children[s], i = Se(e, s); return this.expandSegmentGroup(t, i, r, s).pipe(Object(m.a)(t => ({ segment: t, outlet: s }))) }), Object(y.a)((t, e) => (t[e.outlet] = e.segment, t), {}), function (t, e) { const n = arguments.length >= 2; return s => s.pipe(t ? Object(w.a)((e, n) => t(e, n, s)) : R.a, E(1), n ? Object(A.a)(e) : Object(j.a)(() => new u.a)) }()) } expandSegment(t, e, n, s, r, a) { return Object(i.a)(n).pipe(Object(O.a)(i => this.expandSegmentAgainstRoute(t, e, n, i, s, r, a).pipe(Object(C.a)(t => { if (t instanceof Re) return Object(o.a)(null); throw t }))), Object(L.a)(t => !!t), Object(C.a)((t, n) => { if (t instanceof u.a || "EmptyError" === t.name) { if (Ae(e, s, r)) return Object(o.a)(new bt([], {})); throw new Re(e) } throw t })) } expandSegmentAgainstRoute(t, e, n, s, r, i, o) { return je(s, e, r, i) ? void 0 === s.redirectTo ? this.matchSegmentAgainstRoute(t, e, s, r, i) : o && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, n, s, r, i) : Ie(e) : Ie(e) } expandSegmentAgainstRouteUsingRedirect(t, e, n, s, r, i) { return "**" === s.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, s, i) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, s, r, i) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, n, s) { const r = this.applyRedirectCommands([], n.redirectTo, {}); return n.redirectTo.startsWith("/") ? Pe(r) : this.lineralizeSegments(n, r).pipe(Object(I.a)(n => { const r = new bt(n, {}); return this.expandSegment(t, r, e, n, s, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, s, r, i) { const { matched: o, consumedSegments: a, lastChild: c, positionalParamSegments: l } = Ee(e, s, r); if (!o) return Ie(e); const u = this.applyRedirectCommands(a, s.redirectTo, l); return s.redirectTo.startsWith("/") ? Pe(u) : this.lineralizeSegments(s, u).pipe(Object(I.a)(s => this.expandSegment(t, e, n, s.concat(r.slice(c)), i, !1))) } matchSegmentAgainstRoute(t, e, n, s, r) { if ("**" === n.path) return n.loadChildren ? (n._loadedConfig ? Object(o.a)(n._loadedConfig) : this.configLoader.load(t.injector, n)).pipe(Object(m.a)(t => (n._loadedConfig = t, new bt(s, {})))) : Object(o.a)(new bt(s, {})); const { matched: i, consumedSegments: a, lastChild: c } = Ee(e, n, s); if (!i) return Ie(e); const l = s.slice(c); return this.getChildConfig(t, n, s).pipe(Object(I.a)(t => { const s = t.module, i = t.routes, { segmentGroup: c, slicedSegments: u } = Te(e, a, l, i), h = new bt(c.segments, c.children); if (0 === u.length && h.hasChildren()) return this.expandChildren(s, i, h).pipe(Object(m.a)(t => new bt(a, t))); if (0 === i.length && 0 === u.length) return Object(o.a)(new bt(a, {})); const d = Oe(n) === r; return this.expandSegment(s, h, i, u, d ? et : r, !0).pipe(Object(m.a)(t => new bt(a.concat(t.segments), t.children))) })) } getChildConfig(t, e, n) { return e.children ? Object(o.a)(new pe(e.children, t)) : e.loadChildren ? void 0 !== e._loadedConfig ? Object(o.a)(e._loadedConfig) : this.runCanLoadGuards(t.injector, e, n).pipe(Object(I.a)(n => n ? this.configLoader.load(t.injector, e).pipe(Object(m.a)(t => (e._loadedConfig = t, t))) : function (t) { return new l.a(e => e.error(rt(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`))) }(e))) : Object(o.a)(new pe([], t)) } runCanLoadGuards(t, e, n) { const s = e.canLoad; if (!s || 0 === s.length) return Object(o.a)(!0); const r = s.map(s => { const r = t.get(s); let i; if (function (t) { return t && fe(t.canLoad) }(r)) i = r.canLoad(e, n); else { if (!fe(r)) throw new Error("Invalid CanLoad guard"); i = r(e, n) } return ht(i) }); return Object(o.a)(r).pipe(be(), Object(P.a)(t => { if (!ge(t)) return; const e = rt(`Redirecting to "${this.urlSerializer.serialize(t)}"`); throw e.url = t, e }), Object(m.a)(t => !0 === t)) } lineralizeSegments(t, e) { let n = [], s = e.root; for (; ;) { if (n = n.concat(s.segments), 0 === s.numberOfChildren) return Object(o.a)(n); if (s.numberOfChildren > 1 || !s.children[et]) return De(t.redirectTo); s = s.children[et] } } applyRedirectCommands(t, e, n) { return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, n) } applyRedirectCreatreUrlTree(t, e, n, s) { const r = this.createSegmentGroup(t, e.root, n, s); return new mt(r, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(t, e) { const n = {}; return ut(t, (t, s) => { if ("string" == typeof t && t.startsWith(":")) { const r = t.substring(1); n[s] = e[r] } else n[s] = t }), n } createSegmentGroup(t, e, n, s) { const r = this.createSegments(t, e.segments, n, s); let i = {}; return ut(e.children, (e, r) => { i[r] = this.createSegmentGroup(t, e, n, s) }), new bt(r, i) } createSegments(t, e, n, s) { return e.map(e => e.path.startsWith(":") ? this.findPosParam(t, e, s) : this.findOrReturn(e, n)) } findPosParam(t, e, n) { const s = n[e.path.substring(1)]; if (!s) throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`); return s } findOrReturn(t, e) { let n = 0; for (const s of e) { if (s.path === t.path) return e.splice(n), s; n++ } return t } } function Ne(t) { const e = {}; for (const n of Object.keys(t.children)) { const s = Ne(t.children[n]); (s.segments.length > 0 || s.hasChildren()) && (e[n] = s) } return function (t) { if (1 === t.numberOfChildren && t.children[et]) { const e = t.children[et]; return new bt(t.segments.concat(e.segments), e.children) } return t }(new bt(t.segments, e)) } class Fe { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class Ve { constructor(t, e) { this.component = t, this.route = e } } function Be(t, e, n) { const s = t._root; return He(s, e ? e._root : null, n, [s.value]) } function Ue(t, e, n) { const s = function (t) { if (!t) return null; for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig } return null }(e); return (s ? s.module.injector : n).get(t) } function He(t, e, n, s, r = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = Bt(e); return t.children.forEach(t => { !function (t, e, n, s, r = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = t.value, o = e ? e.value : null, a = n ? n.getContext(t.value.outlet) : null; if (o && i.routeConfig === o.routeConfig) { const c = function (t, e, n) { if ("function" == typeof n) return n(t, e); switch (n) { case "pathParamsChange": return !vt(t.url, e.url); case "pathParamsOrQueryParamsChange": return !vt(t.url, e.url) || !ot(t.queryParams, e.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !Zt(t, e) || !ot(t.queryParams, e.queryParams); case "paramsChange": default: return !Zt(t, e) } }(o, i, i.routeConfig.runGuardsAndResolvers); c ? r.canActivateChecks.push(new Fe(s)) : (i.data = o.data, i._resolvedData = o._resolvedData), He(t, e, i.component ? a ? a.children : null : n, s, r), c && a && a.outlet && a.outlet.isActivated && r.canDeactivateChecks.push(new Ve(a.outlet.component, o)) } else o && ze(e, a, r), r.canActivateChecks.push(new Fe(s)), He(t, null, i.component ? a ? a.children : null : n, s, r) }(t, i[t.value.outlet], n, s.concat([t.value]), r), delete i[t.value.outlet] }), ut(i, (t, e) => ze(t, n.getContext(e), r)), r } function ze(t, e, n) { const s = Bt(t), r = t.value; ut(s, (t, s) => { ze(t, r.component ? e ? e.children.getContext(s) : null : e, n) }), n.canDeactivateChecks.push(new Ve(r.component && e && e.outlet && e.outlet.isActivated ? e.outlet.component : null, r)) } class $e { } function We(t) { return new l.a(e => e.error(t)) } class qe { constructor(t, e, n, s, r, i) { this.rootComponentType = t, this.config = e, this.urlTree = n, this.url = s, this.paramsInheritanceStrategy = r, this.relativeLinkResolution = i } recognize() { const t = Te(this.urlTree.root, [], [], this.config.filter(t => void 0 === t.redirectTo), this.relativeLinkResolution).segmentGroup, e = this.processSegmentGroup(this.config, t, et); if (null === e) return null; const n = new Wt([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, et, this.rootComponentType, null, this.urlTree.root, -1, {}), s = new Vt(n, e), r = new qt(this.url, s); return this.inheritParamsAndData(r._root), r } inheritParamsAndData(t) { const e = t.value, n = $t(e, this.paramsInheritanceStrategy); e.params = Object.freeze(n.params), e.data = Object.freeze(n.data), t.children.forEach(t => this.inheritParamsAndData(t)) } processSegmentGroup(t, e, n) { return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, n) } processChildren(t, e) { const n = []; for (const r of Object.keys(e.children)) { const s = e.children[r], i = Se(t, r), o = this.processSegmentGroup(i, s, r); if (null === o) return null; n.push(...o) } const s = Xe(n); return s.sort((t, e) => t.value.outlet === et ? -1 : e.value.outlet === et ? 1 : t.value.outlet.localeCompare(e.value.outlet)), s } processSegment(t, e, n, s) { for (const r of t) { const t = this.processSegmentAgainstRoute(r, e, n, s); if (null !== t) return t } return Ae(e, n, s) ? [] : null } processSegmentAgainstRoute(t, e, n, s) { if (t.redirectTo || !je(t, e, n, s)) return null; let r, i = [], o = []; if ("**" === t.path) { const s = n.length > 0 ? lt(n).parameters : {}; r = new Wt(n, s, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, Ye(t), Oe(t), t.component, t, Ke(e), Ze(e) + n.length, Qe(t)) } else { const s = Ee(e, t, n); if (!s.matched) return null; i = s.consumedSegments, o = n.slice(s.lastChild), r = new Wt(i, s.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, Ye(t), Oe(t), t.component, t, Ke(e), Ze(e) + i.length, Qe(t)) } const a = function (t) { return t.children ? t.children : t.loadChildren ? t._loadedConfig.routes : [] }(t), { segmentGroup: c, slicedSegments: l } = Te(e, i, o, a.filter(t => void 0 === t.redirectTo), this.relativeLinkResolution); if (0 === l.length && c.hasChildren()) { const t = this.processChildren(a, c); return null === t ? null : [new Vt(r, t)] } if (0 === a.length && 0 === l.length) return [new Vt(r, [])]; const u = Oe(t) === s, h = this.processSegment(a, c, l, u ? et : s); return null === h ? null : [new Vt(r, h)] } } function Ge(t) { const e = t.value.routeConfig; return e && "" === e.path && void 0 === e.redirectTo } function Xe(t) { const e = [], n = new Set; for (const s of t) { if (!Ge(s)) { e.push(s); continue } const t = e.find(t => s.value.routeConfig === t.value.routeConfig); void 0 !== t ? (t.children.push(...s.children), n.add(t)) : e.push(s) } for (const s of n) { const t = Xe(s.children); e.push(new Vt(s.value, t)) } return e.filter(t => !n.has(t)) } function Ke(t) { let e = t; for (; e._sourceSegment;)e = e._sourceSegment; return e } function Ze(t) { let e = t, n = e._segmentIndexShift ? e._segmentIndexShift : 0; for (; e._sourceSegment;)e = e._sourceSegment, n += e._segmentIndexShift ? e._segmentIndexShift : 0; return n - 1 } function Ye(t) { return t.data || {} } function Qe(t) { return t.resolve || {} } function Je(t) { return Object(b.a)(e => { const n = t(e); return n ? Object(i.a)(n).pipe(Object(m.a)(() => e)) : Object(o.a)(e) }) } class tn extends class { shouldDetach(t) { return !1 } store(t, e) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, e) { return t.routeConfig === e.routeConfig } }{ } const en = new r.r("ROUTES"); class nn { constructor(t, e, n, s) { this.loader = t, this.compiler = e, this.onLoadStartListener = n, this.onLoadEndListener = s } load(t, e) { if (e._loader$) return e._loader$; this.onLoadStartListener && this.onLoadStartListener(e); const n = this.loadModuleFactory(e.loadChildren).pipe(Object(m.a)(n => { this.onLoadEndListener && this.onLoadEndListener(e); const s = n.create(t); return new pe(ct(s.injector.get(en, void 0, r.q.Self | r.q.Optional)).map(Ce), s) }), Object(C.a)(t => { throw e._loader$ = void 0, t })); return e._loader$ = new f.a(n, () => new g.a).pipe(Object(D.a)()), e._loader$ } loadModuleFactory(t) { return "string" == typeof t ? Object(i.a)(this.loader.load(t)) : ht(t()).pipe(Object(I.a)(t => t instanceof r.w ? Object(o.a)(t) : Object(i.a)(this.compiler.compileModuleAsync(t)))) } } class sn { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new rn, this.attachRef = null } } class rn { constructor() { this.contexts = new Map } onChildOutletCreated(t, e) { const n = this.getOrCreateContext(t); n.outlet = e, this.contexts.set(t, n) } onChildOutletDestroyed(t) { const e = this.getContext(t); e && (e.outlet = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let e = this.getContext(t); return e || (e = new sn, this.contexts.set(t, e)), e } getContext(t) { return this.contexts.get(t) || null } } class on { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, e) { return t } } function an(t) { throw t } function cn(t, e, n) { return e.parse("/") } function ln(t, e) { return Object(o.a)(null) } let un = (() => { class t { constructor(t, e, n, s, i, o, c, l) { this.rootComponentType = t, this.urlSerializer = e, this.rootContexts = n, this.location = s, this.config = l, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.lastLocationChangeInfo = null, this.navigationId = 0, this.isNgZoneEnabled = !1, this.events = new g.a, this.errorHandler = an, this.malformedUriErrorHandler = cn, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: ln, afterPreactivation: ln }, this.urlHandlingStrategy = new on, this.routeReuseStrategy = new tn, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.ngModule = i.get(r.y), this.console = i.get(r.ab); const u = i.get(r.A); this.isNgZoneEnabled = u instanceof r.A && r.A.isInAngularZone(), this.resetConfig(l), this.currentUrlTree = new mt(new bt([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new nn(o, c, t => this.triggerEvent(new X(t)), t => this.triggerEvent(new K(t))), this.routerState = Ht(this.currentUrlTree, this.rootComponentType), this.transitions = new a.a({ id: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } setupNavigations(t) { const e = this.events; return t.pipe(Object(w.a)(t => 0 !== t.id), Object(m.a)(t => Object.assign(Object.assign({}, t), { extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl) })), Object(b.a)(t => { let n = !1, s = !1; return Object(o.a)(t).pipe(Object(P.a)(t => { this.currentNavigation = { id: t.id, initialUrl: t.currentRawUrl, extractedUrl: t.extractedUrl, trigger: t.source, extras: t.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), Object(b.a)(t => { const n = !this.navigated || t.extractedUrl.toString() !== this.browserUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || n) && this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) return Object(o.a)(t).pipe(Object(b.a)(t => { const n = this.transitions.getValue(); return e.next(new V(t.id, this.serializeUrl(t.extractedUrl), t.source, t.restoredState)), n !== this.transitions.getValue() ? p.a : Promise.resolve(t) }), (s = this.ngModule.injector, r = this.configLoader, i = this.urlSerializer, a = this.config, Object(b.a)(t => function (t, e, n, s, r) { return new Me(t, e, n, s, r).apply() }(s, r, i, t.extractedUrl, a).pipe(Object(m.a)(e => Object.assign(Object.assign({}, t), { urlAfterRedirects: e }))))), Object(P.a)(t => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: t.urlAfterRedirects }) }), function (t, e, n, s, r) { return Object(I.a)(i => function (t, e, n, s, r = "emptyOnly", i = "legacy") { try { const a = new qe(t, e, n, s, r, i).recognize(); return null === a ? We(new $e) : Object(o.a)(a) } catch (a) { return We(a) } }(t, e, i.urlAfterRedirects, n(i.urlAfterRedirects), s, r).pipe(Object(m.a)(t => Object.assign(Object.assign({}, i), { targetSnapshot: t })))) }(this.rootComponentType, this.config, t => this.serializeUrl(t), this.paramsInheritanceStrategy, this.relativeLinkResolution), Object(P.a)(t => { "eager" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(t.urlAfterRedirects, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects); const n = new z(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); e.next(n) })); var s, r, i, a; if (n && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: n, extractedUrl: s, source: r, restoredState: i, extras: a } = t, c = new V(n, this.serializeUrl(s), r, i); e.next(c); const l = Ht(s, this.rootComponentType).snapshot; return Object(o.a)(Object.assign(Object.assign({}, t), { targetSnapshot: l, urlAfterRedirects: s, extras: Object.assign(Object.assign({}, a), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = t.rawUrl, this.browserUrlTree = t.urlAfterRedirects, t.resolve(null), p.a }), Je(t => { const { targetSnapshot: e, id: n, extractedUrl: s, rawUrl: r, extras: { skipLocationChange: i, replaceUrl: o } } = t; return this.hooks.beforePreactivation(e, { navigationId: n, appliedUrlTree: s, rawUrlTree: r, skipLocationChange: !!i, replaceUrl: !!o }) }), Object(P.a)(t => { const e = new $(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), Object(m.a)(t => Object.assign(Object.assign({}, t), { guards: Be(t.targetSnapshot, t.currentSnapshot, this.rootContexts) })), function (t, e) { return Object(I.a)(n => { const { targetSnapshot: s, currentSnapshot: r, guards: { canActivateChecks: a, canDeactivateChecks: c } } = n; return 0 === c.length && 0 === a.length ? Object(o.a)(Object.assign(Object.assign({}, n), { guardsResult: !0 })) : function (t, e, n, s) { return Object(i.a)(t).pipe(Object(I.a)(t => function (t, e, n, s, r) { const i = e && e.routeConfig ? e.routeConfig.canDeactivate : null; if (!i || 0 === i.length) return Object(o.a)(!0); const a = i.map(i => { const o = Ue(i, e, r); let a; if (function (t) { return t && fe(t.canDeactivate) }(o)) a = ht(o.canDeactivate(t, e, n, s)); else { if (!fe(o)) throw new Error("Invalid CanDeactivate guard"); a = ht(o(t, e, n, s)) } return a.pipe(Object(L.a)()) }); return Object(o.a)(a).pipe(be()) }(t.component, t.route, n, e, s)), Object(L.a)(t => !0 !== t, !0)) }(c, s, r, t).pipe(Object(I.a)(n => n && "boolean" == typeof n ? function (t, e, n, s) { return Object(i.a)(e).pipe(Object(O.a)(e => Object(h.a)(function (t, e) { return null !== t && e && e(new Z(t)), Object(o.a)(!0) }(e.route.parent, s), function (t, e) { return null !== t && e && e(new Q(t)), Object(o.a)(!0) }(e.route, s), function (t, e, n) { const s = e[e.length - 1], r = e.slice(0, e.length - 1).reverse().map(t => function (t) { const e = t.routeConfig ? t.routeConfig.canActivateChild : null; return e && 0 !== e.length ? { node: t, guards: e } : null }(t)).filter(t => null !== t).map(e => Object(d.a)(() => { const r = e.guards.map(r => { const i = Ue(r, e.node, n); let o; if (function (t) { return t && fe(t.canActivateChild) }(i)) o = ht(i.canActivateChild(s, t)); else { if (!fe(i)) throw new Error("Invalid CanActivateChild guard"); o = ht(i(s, t)) } return o.pipe(Object(L.a)()) }); return Object(o.a)(r).pipe(be()) })); return Object(o.a)(r).pipe(be()) }(t, e.path, n), function (t, e, n) { const s = e.routeConfig ? e.routeConfig.canActivate : null; if (!s || 0 === s.length) return Object(o.a)(!0); const r = s.map(s => Object(d.a)(() => { const r = Ue(s, e, n); let i; if (function (t) { return t && fe(t.canActivate) }(r)) i = ht(r.canActivate(e, t)); else { if (!fe(r)) throw new Error("Invalid CanActivate guard"); i = ht(r(e, t)) } return i.pipe(Object(L.a)()) })); return Object(o.a)(r).pipe(be()) }(t, e.route, n))), Object(L.a)(t => !0 !== t, !0)) }(s, a, t, e) : Object(o.a)(n)), Object(m.a)(t => Object.assign(Object.assign({}, n), { guardsResult: t }))) }) }(this.ngModule.injector, t => this.triggerEvent(t)), Object(P.a)(t => { if (ge(t.guardsResult)) { const e = rt(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`); throw e.url = t.guardsResult, e } const e = new W(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult); this.triggerEvent(e) }), Object(w.a)(t => { if (!t.guardsResult) { this.resetUrlToCurrentUrlTree(); const n = new U(t.id, this.serializeUrl(t.extractedUrl), ""); return e.next(n), t.resolve(!1), !1 } return !0 }), Je(t => { if (t.guards.canActivateChecks.length) return Object(o.a)(t).pipe(Object(P.a)(t => { const e = new q(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), Object(b.a)(t => { let n = !1; return Object(o.a)(t).pipe((s = this.paramsInheritanceStrategy, r = this.ngModule.injector, Object(I.a)(t => { const { targetSnapshot: e, guards: { canActivateChecks: n } } = t; if (!n.length) return Object(o.a)(t); let a = 0; return Object(i.a)(n).pipe(Object(O.a)(t => function (t, e, n, s) { return function (t, e, n, s) { const r = Object.keys(t); if (0 === r.length) return Object(o.a)({}); const a = {}; return Object(i.a)(r).pipe(Object(I.a)(r => function (t, e, n, s) { const r = Ue(t, e, s); return ht(r.resolve ? r.resolve(e, n) : r(e, n)) }(t[r], e, n, s).pipe(Object(P.a)(t => { a[r] = t }))), E(1), Object(I.a)(() => Object.keys(a).length === r.length ? Object(o.a)(a) : p.a)) }(t._resolve, t, e, s).pipe(Object(m.a)(e => (t._resolvedData = e, t.data = Object.assign(Object.assign({}, t.data), $t(t, n).resolve), null))) }(t.route, e, s, r)), Object(P.a)(() => a++), E(1), Object(I.a)(e => a === n.length ? Object(o.a)(t) : p.a)) })), Object(P.a)({ next: () => n = !0, complete: () => { if (!n) { const n = new U(t.id, this.serializeUrl(t.extractedUrl), "At least one route resolver didn't emit any value."); e.next(n), t.resolve(!1) } } })); var s, r }), Object(P.a)(t => { const e = new G(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) })) }), Je(t => { const { targetSnapshot: e, id: n, extractedUrl: s, rawUrl: r, extras: { skipLocationChange: i, replaceUrl: o } } = t; return this.hooks.afterPreactivation(e, { navigationId: n, appliedUrlTree: s, rawUrlTree: r, skipLocationChange: !!i, replaceUrl: !!o }) }), Object(m.a)(t => { const e = function (t, e, n) { const s = Yt(t, e._root, n ? n._root : void 0); return new Ut(s, e) }(this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState); return Object.assign(Object.assign({}, t), { targetRouterState: e }) }), Object(P.a)(t => { this.currentUrlTree = t.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl), this.routerState = t.targetRouterState, "deferred" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects) }), (r = this.rootContexts, a = this.routeReuseStrategy, c = t => this.triggerEvent(t), Object(m.a)(t => (new he(a, t.targetRouterState, t.currentRouterState, c).activate(r), t))), Object(P.a)({ next() { n = !0 }, complete() { n = !0 } }), Object(M.a)(() => { if (!n && !s) { this.resetUrlToCurrentUrlTree(); const n = new U(t.id, this.serializeUrl(t.extractedUrl), `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`); e.next(n), t.resolve(!1) } this.currentNavigation = null }), Object(C.a)(n => { if (s = !0, (r = n) && r.ngNavigationCancelingError) { const s = ge(n.url); s || (this.navigated = !0, this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl)); const r = new U(t.id, this.serializeUrl(t.extractedUrl), n.message); e.next(r), s ? setTimeout(() => { const e = this.urlHandlingStrategy.merge(n.url, this.rawUrlTree); this.scheduleNavigation(e, "imperative", null, { skipLocationChange: t.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy }, { resolve: t.resolve, reject: t.reject, promise: t.promise }) }, 0) : t.resolve(!1) } else { this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl); const s = new H(t.id, this.serializeUrl(t.extractedUrl), n); e.next(s); try { t.resolve(this.errorHandler(n)) } catch (i) { t.reject(i) } } var r; return p.a })); var r, a, c })) } resetRootComponentType(t) { this.rootComponentType = t, this.routerState.root.component = this.rootComponentType } getTransition() { const t = this.transitions.value; return t.urlAfterRedirects = this.browserUrlTree, t } setTransition(t) { this.transitions.next(Object.assign(Object.assign({}, this.getTransition()), t)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(t => { const e = this.extractLocationChangeInfoFromEvent(t); this.shouldScheduleNavigation(this.lastLocationChangeInfo, e) && setTimeout(() => { const { source: t, state: n, urlTree: s } = e, r = { replaceUrl: !0 }; if (n) { const t = Object.assign({}, n); delete t.navigationId, 0 !== Object.keys(t).length && (r.state = t) } this.scheduleNavigation(s, t, n, r) }, 0), this.lastLocationChangeInfo = e })) } extractLocationChangeInfoFromEvent(t) { var e; return { source: "popstate" === t.type ? "popstate" : "hashchange", urlTree: this.parseUrl(t.url), state: (null === (e = t.state) || void 0 === e ? void 0 : e.navigationId) ? t.state : null, transitionId: this.getTransition().id } } shouldScheduleNavigation(t, e) { if (!t) return !0; const n = e.urlTree.toString() === t.urlTree.toString(); return !(e.transitionId === t.transitionId && n && ("hashchange" === e.source && "popstate" === t.source || "popstate" === e.source && "hashchange" === t.source)) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(t) { this.events.next(t) } resetConfig(t) { ve(t), this.config = t.map(Ce), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(t, e = {}) { const { relativeTo: n, queryParams: s, fragment: r, queryParamsHandling: i, preserveFragment: o } = e, a = n || this.routerState.root, c = o ? this.currentUrlTree.fragment : r; let l = null; switch (i) { case "merge": l = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), s); break; case "preserve": l = this.currentUrlTree.queryParams; break; default: l = s || null }return null !== l && (l = this.removeEmptyProps(l)), function (t, e, n, s, r) { if (0 === n.length) return ee(e.root, e.root, e, s, r); const i = function (t) { if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new se(!0, 0, t); let e = 0, n = !1; const s = t.reduce((t, s, r) => { if ("object" == typeof s && null != s) { if (s.outlets) { const e = {}; return ut(s.outlets, (t, n) => { e[n] = "string" == typeof t ? t.split("/") : t }), [...t, { outlets: e }] } if (s.segmentPath) return [...t, s.segmentPath] } return "string" != typeof s ? [...t, s] : 0 === r ? (s.split("/").forEach((s, r) => { 0 == r && "." === s || (0 == r && "" === s ? n = !0 : ".." === s ? e++ : "" != s && t.push(s)) }), t) : [...t, s] }, []); return new se(n, e, s) }(n); if (i.toRoot()) return ee(e.root, new bt([], {}), e, s, r); const o = function (t, e, n) { if (t.isAbsolute) return new re(e.root, !0, 0); if (-1 === n.snapshot._lastPathIndex) { const t = n.snapshot._urlSegment; return new re(t, t === e.root, 0) } const s = Jt(t.commands[0]) ? 0 : 1; return function (t, e, n) { let s = t, r = e, i = n; for (; i > r;) { if (i -= r, s = s.parent, !s) throw new Error("Invalid number of '../'"); r = s.segments.length } return new re(s, !1, r - i) }(n.snapshot._urlSegment, n.snapshot._lastPathIndex + s, t.numberOfDoubleDots) }(i, e, t), a = o.processChildren ? oe(o.segmentGroup, o.index, i.commands) : ie(o.segmentGroup, o.index, i.commands); return ee(o.segmentGroup, a, e, s, r) }(a, this.currentUrlTree, t, l, c) } navigateByUrl(t, e = { skipLocationChange: !1 }) { const n = ge(t) ? t : this.parseUrl(t), s = this.urlHandlingStrategy.merge(n, this.rawUrlTree); return this.scheduleNavigation(s, "imperative", null, e) } navigate(t, e = { skipLocationChange: !1 }) { return function (t) { for (let e = 0; e < t.length; e++) { const n = t[e]; if (null == n) throw new Error(`The requested path contains ${n} segment at index ${e}`) } }(t), this.navigateByUrl(this.createUrlTree(t, e), e) } serializeUrl(t) { return this.urlSerializer.serialize(t) } parseUrl(t) { let e; try { e = this.urlSerializer.parse(t) } catch (n) { e = this.malformedUriErrorHandler(n, this.urlSerializer, t) } return e } isActive(t, e) { if (ge(t)) return dt(this.currentUrlTree, t, e); const n = this.parseUrl(t); return dt(this.currentUrlTree, n, e) } removeEmptyProps(t) { return Object.keys(t).reduce((e, n) => { const s = t[n]; return null != s && (e[n] = s), e }, {}) } processNavigations() { this.navigations.subscribe(t => { this.navigated = !0, this.lastSuccessfulId = t.id, this.events.next(new B(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, t.resolve(!0) }, t => { this.console.warn("Unhandled Navigation Error: ") }) } scheduleNavigation(t, e, n, s, r) { if (this.disposed) return Promise.resolve(!1); const i = this.getTransition(), o = "imperative" !== e && "imperative" === (null == i ? void 0 : i.source), a = (this.lastSuccessfulId === i.id || this.currentNavigation ? i.rawUrl : i.urlAfterRedirects).toString() === t.toString(); if (o && a) return Promise.resolve(!0); let c, l, u; r ? (c = r.resolve, l = r.reject, u = r.promise) : u = new Promise((t, e) => { c = t, l = e }); const h = ++this.navigationId; return this.setTransition({ id: h, source: e, restoredState: n, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: t, extras: s, resolve: c, reject: l, promise: u, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), u.catch(t => Promise.reject(t)) } setBrowserUrl(t, e, n, s) { const r = this.urlSerializer.serialize(t); s = s || {}, this.location.isCurrentPathEqualTo(r) || e ? this.location.replaceState(r, "", Object.assign(Object.assign({}, s), { navigationId: n })) : this.location.go(r, "", Object.assign(Object.assign({}, s), { navigationId: n })) } resetStateAndUrl(t, e, n) { this.routerState = t, this.currentUrlTree = e, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n), this.resetUrlToCurrentUrlTree() } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", { navigationId: this.lastSuccessfulId }) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(r.P), r.bc(yt), r.bc(rn), r.bc(s.j), r.bc(r.s), r.bc(r.x), r.bc(r.i), r.bc(void 0)) }, t.\u0275prov = r.Nb({ token: t, factory: t.\u0275fac }), t })(), hn = (() => { class t { constructor(t, e, n, s, r) { this.router = t, this.route = e, this.commands = [], this.onChanges = new g.a, null == n && s.setAttribute(r.nativeElement, "tabindex", "0") } ngOnChanges(t) { this.onChanges.next(this) } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } onClick() { const t = { skipLocationChange: pn(this.skipLocationChange), replaceUrl: pn(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, t), !0 } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: pn(this.preserveFragment) }) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(un), r.Rb(zt), r.cc("tabindex"), r.Rb(r.F), r.Rb(r.l)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["", "routerLink", "", 5, "a", 5, "area"]], hostBindings: function (t, e) { 1 & t && r.ec("click", function () { return e.onClick() }) }, inputs: { routerLink: "routerLink", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo" }, features: [r.Ab] }), t })(), dn = (() => { class t { constructor(t, e, n) { this.router = t, this.route = e, this.locationStrategy = n, this.commands = [], this.onChanges = new g.a, this.subscription = t.events.subscribe(t => { t instanceof B && this.updateTargetUrlAndHref() }) } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } ngOnChanges(t) { this.updateTargetUrlAndHref(), this.onChanges.next(this) } ngOnDestroy() { this.subscription.unsubscribe() } onClick(t, e, n, s, r) { if (0 !== t || e || n || s || r) return !0; if ("string" == typeof this.target && "_self" != this.target) return !0; const i = { skipLocationChange: pn(this.skipLocationChange), replaceUrl: pn(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, i), !1 } updateTargetUrlAndHref() { this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: pn(this.preserveFragment) }) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(un), r.Rb(zt), r.Rb(s.k)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["a", "routerLink", ""], ["area", "routerLink", ""]], hostVars: 2, hostBindings: function (t, e) { 1 & t && r.ec("click", function (t) { return e.onClick(t.button, t.ctrlKey, t.shiftKey, t.altKey, t.metaKey) }), 2 & t && (r.ac("href", e.href, r.Dc), r.Db("target", e.target)) }, inputs: { routerLink: "routerLink", target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo" }, features: [r.Ab] }), t })(); function pn(t) { return "" === t || !!t } let fn = (() => { class t { constructor(t, e, n, s, r, i) { this.router = t, this.element = e, this.renderer = n, this.cdr = s, this.link = r, this.linkWithHref = i, this.classes = [], this.isActive = !1, this.routerLinkActiveOptions = { exact: !1 }, this.routerEventsSubscription = t.events.subscribe(t => { t instanceof B && this.update() }) } ngAfterContentInit() { Object(o.a)(this.links.changes, this.linksWithHrefs.changes, Object(o.a)(null)).pipe(Object(N.a)()).subscribe(t => { this.update(), this.subscribeToEachLinkOnChanges() }) } subscribeToEachLinkOnChanges() { var t; null === (t = this.linkInputChangesSubscription) || void 0 === t || t.unsubscribe(); const e = [...this.links.toArray(), ...this.linksWithHrefs.toArray(), this.link, this.linkWithHref].filter(t => !!t).map(t => t.onChanges); this.linkInputChangesSubscription = Object(i.a)(e).pipe(Object(N.a)()).subscribe(t => { this.isActive !== this.isLinkActive(this.router)(t) && this.update() }) } set routerLinkActive(t) { const e = Array.isArray(t) ? t : t.split(" "); this.classes = e.filter(t => !!t) } ngOnChanges(t) { this.update() } ngOnDestroy() { var t; this.routerEventsSubscription.unsubscribe(), null === (t = this.linkInputChangesSubscription) || void 0 === t || t.unsubscribe() } update() { this.links && this.linksWithHrefs && this.router.navigated && Promise.resolve().then(() => { const t = this.hasActiveLinks(); this.isActive !== t && (this.isActive = t, this.cdr.markForCheck(), this.classes.forEach(e => { t ? this.renderer.addClass(this.element.nativeElement, e) : this.renderer.removeClass(this.element.nativeElement, e) })) }) } isLinkActive(t) { return e => t.isActive(e.urlTree, this.routerLinkActiveOptions.exact) } hasActiveLinks() { const t = this.isLinkActive(this.router); return this.link && t(this.link) || this.linkWithHref && t(this.linkWithHref) || this.links.some(t) || this.linksWithHrefs.some(t) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(un), r.Rb(r.l), r.Rb(r.F), r.Rb(r.h), r.Rb(hn, 8), r.Rb(dn, 8)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["", "routerLinkActive", ""]], contentQueries: function (t, e, n) { if (1 & t && (r.Kb(n, hn, 1), r.Kb(n, dn, 1)), 2 & t) { let t; r.xc(t = r.fc()) && (e.links = t), r.xc(t = r.fc()) && (e.linksWithHrefs = t) } }, inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", routerLinkActive: "routerLinkActive" }, exportAs: ["routerLinkActive"], features: [r.Ab] }), t })(), gn = (() => { class t { constructor(t, e, n, s, i) { this.parentContexts = t, this.location = e, this.resolver = n, this.changeDetector = i, this.activated = null, this._activatedRoute = null, this.activateEvents = new r.n, this.deactivateEvents = new r.n, this.name = s || et, t.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const t = this.parentContexts.getContext(this.name); t && t.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const t = this.activated; return this.activated = null, this._activatedRoute = null, t } attach(t, e) { this.activated = t, this._activatedRoute = e, this.location.insert(t.hostView) } deactivate() { if (this.activated) { const t = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t) } } activateWith(t, e) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = t; const n = (e = e || this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component), s = this.parentContexts.getOrCreateContext(this.name).children, r = new mn(t, s, this.location.injector); this.activated = this.location.createComponent(n, this.location.length, r), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return t.\u0275fac = function (e) { return new (e || t)(r.Rb(rn), r.Rb(r.R), r.Rb(r.j), r.cc("name"), r.Rb(r.h)) }, t.\u0275dir = r.Mb({ type: t, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"] }), t })(); class mn { constructor(t, e, n) { this.route = t, this.childContexts = e, this.parent = n } get(t, e) { return t === zt ? this.route : t === rn ? this.childContexts : this.parent.get(t, e) } } class bn { } class _n { preload(t, e) { return Object(o.a)(null) } } let vn = (() => { class t { constructor(t, e, n, s, r) { this.router = t, this.injector = s, this.preloadingStrategy = r, this.loader = new nn(e, n, e => t.triggerEvent(new X(e)), e => t.triggerEvent(new K(e))) } setUpPreloading() { this.subscription = this.router.events.pipe(Object(w.a)(t => t instanceof B), Object(O.a)(() => this.preload())).subscribe(() => { }) } preload() { const t = this.injector.get(r.y); return this.processRoutes(t, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(t, e) { const n = []; for (const s of e) if (s.loadChildren && !s.canLoad && s._loadedConfig) { const t = s._loadedConfig; n.push(this.processRoutes(t.module, t.routes)) } else s.loadChildren && !s.canLoad ? n.push(this.preloadConfig(t, s)) : s.children && n.push(this.processRoutes(t, s.children)); return Object(i.a)(n).pipe(Object(N.a)(), Object(m.a)(t => { })) } preloadConfig(t, e) { return this.preloadingStrategy.preload(e, () => (e._loadedConfig ? Object(o.a)(e._loadedConfig) : this.loader.load(t.injector, e)).pipe(Object(I.a)(t => (e._loadedConfig = t, this.processRoutes(t.module, t.routes))))) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(un), r.bc(r.x), r.bc(r.i), r.bc(r.s), r.bc(bn)) }, t.\u0275prov = r.Nb({ token: t, factory: t.\u0275fac }), t })(), yn = (() => { class t { constructor(t, e, n = {}) { this.router = t, this.viewportScroller = e, this.options = n, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, n.scrollPositionRestoration = n.scrollPositionRestoration || "disabled", n.anchorScrolling = n.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(t => { t instanceof V ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof B && (this.lastId = t.id, this.scheduleScrollEvent(t, this.router.parseUrl(t.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(t => { t instanceof tt && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(t, e) { this.router.triggerEvent(new tt(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, e)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(un), r.bc(s.w), r.bc(void 0)) }, t.\u0275prov = r.Nb({ token: t, factory: t.\u0275fac }), t })(); const wn = new r.r("ROUTER_CONFIGURATION"), Cn = new r.r("ROUTER_FORROOT_GUARD"), On = [s.j, { provide: yt, useClass: wt }, { provide: un, useFactory: function (t, e, n, r, i, o, a, c = {}, l, u) { const h = new un(null, t, e, n, r, i, o, ct(a)); if (l && (h.urlHandlingStrategy = l), u && (h.routeReuseStrategy = u), function (t, e) { t.errorHandler && (e.errorHandler = t.errorHandler), t.malformedUriErrorHandler && (e.malformedUriErrorHandler = t.malformedUriErrorHandler), t.onSameUrlNavigation && (e.onSameUrlNavigation = t.onSameUrlNavigation), t.paramsInheritanceStrategy && (e.paramsInheritanceStrategy = t.paramsInheritanceStrategy), t.relativeLinkResolution && (e.relativeLinkResolution = t.relativeLinkResolution), t.urlUpdateStrategy && (e.urlUpdateStrategy = t.urlUpdateStrategy) }(c, h), c.enableTracing) { const t = Object(s.C)(); h.events.subscribe(e => { t.logGroup(`Router Event: ${e.constructor.name}`), t.log(e.toString()), t.log(e), t.logGroupEnd() }) } return h }, deps: [yt, rn, s.j, r.s, r.x, r.i, en, wn, [class { }, new r.B], [class { }, new r.B]] }, rn, { provide: zt, useFactory: function (t) { return t.routerState.root }, deps: [un] }, { provide: r.x, useClass: r.M }, vn, _n, class { preload(t, e) { return e().pipe(Object(C.a)(() => Object(o.a)(null))) } }, { provide: wn, useValue: { enableTracing: !1 } }]; function Sn() { return new r.z("Router", un) } let xn = (() => { class t { constructor(t, e) { } static forRoot(e, n) { return { ngModule: t, providers: [On, jn(e), { provide: Cn, useFactory: kn, deps: [[un, new r.B, new r.L]] }, { provide: wn, useValue: n || {} }, { provide: s.k, useFactory: Tn, deps: [s.u, [new r.p(s.a), new r.B], wn] }, { provide: yn, useFactory: En, deps: [un, s.w, wn] }, { provide: bn, useExisting: n && n.preloadingStrategy ? n.preloadingStrategy : _n }, { provide: r.z, multi: !0, useFactory: Sn }, [An, { provide: r.d, multi: !0, useFactory: Rn, deps: [An] }, { provide: In, useFactory: Ln, deps: [An] }, { provide: r.b, multi: !0, useExisting: In }]] } } static forChild(e) { return { ngModule: t, providers: [jn(e)] } } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(Cn, 8), r.bc(un, 8)) }, t.\u0275mod = r.Pb({ type: t }), t.\u0275inj = r.Ob({}), t })(); function En(t, e, n) { return n.scrollOffset && e.setOffset(n.scrollOffset), new yn(t, e, n) } function Tn(t, e, n = {}) { return n.useHash ? new s.h(t, e) : new s.t(t, e) } function kn(t) { return "guarded" } function jn(t) { return [{ provide: r.a, multi: !0, useValue: t }, { provide: en, multi: !0, useValue: t }] } let An = (() => { class t { constructor(t) { this.injector = t, this.initNavigation = !1, this.resultOfPreactivationDone = new g.a } appInitializer() { return this.injector.get(s.i, Promise.resolve(null)).then(() => { let t = null; const e = new Promise(e => t = e), n = this.injector.get(un), s = this.injector.get(wn); return "disabled" === s.initialNavigation ? (n.setUpLocationChangeListener(), t(!0)) : "enabled" === s.initialNavigation || "enabledBlocking" === s.initialNavigation ? (n.hooks.afterPreactivation = () => this.initNavigation ? Object(o.a)(null) : (this.initNavigation = !0, t(!0), this.resultOfPreactivationDone), n.initialNavigation()) : t(!0), e }) } bootstrapListener(t) { const e = this.injector.get(wn), n = this.injector.get(vn), s = this.injector.get(yn), i = this.injector.get(un), o = this.injector.get(r.g); t === o.components[0] && ("enabledNonBlocking" !== e.initialNavigation && void 0 !== e.initialNavigation || i.initialNavigation(), n.setUpPreloading(), s.init(), i.resetRootComponentType(o.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } } return t.\u0275fac = function (e) { return new (e || t)(r.bc(r.s)) }, t.\u0275prov = r.Nb({ token: t, factory: t.\u0275fac }), t })(); function Rn(t) { return t.appInitializer.bind(t) } function Ln(t) { return t.bootstrapListener.bind(t) } const In = new r.r("Router Initializer") }, vkgz: function (t, e, n) { "use strict"; n.d(e, "a", function () { return o }); var s = n("7o/Q"), r = n("KqfI"), i = n("n6bG"); function o(t, e, n) { return function (s) { return s.lift(new a(t, e, n)) } } class a { constructor(t, e, n) { this.nextOrObserver = t, this.error = e, this.complete = n } call(t, e) { return e.subscribe(new c(t, this.nextOrObserver, this.error, this.complete)) } } class c extends s.a { constructor(t, e, n, s) { super(t), this._tapNext = r.a, this._tapError = r.a, this._tapComplete = r.a, this._tapError = n || r.a, this._tapComplete = s || r.a, Object(i.a)(e) ? (this._context = this, this._tapNext = e) : e && (this._context = e, this._tapNext = e.next || r.a, this._tapError = e.error || r.a, this._tapComplete = e.complete || r.a) } _next(t) { try { this._tapNext.call(this._context, t) } catch (e) { return void this.destination.error(e) } this.destination.next(t) } _error(t) { try { this._tapError.call(this._context, t) } catch (t) { return void this.destination.error(t) } this.destination.error(t) } _complete() { try { this._tapComplete.call(this._context) } catch (t) { return void this.destination.error(t) } return this.destination.complete() } } }, w1tV: function (t, e, n) { "use strict"; n.d(e, "a", function () { return a }); var s = n("EQ5u"), r = n("x+ZX"), i = n("XNiG"); function o() { return new i.a } function a() { return t => { return Object(r.a)()((e = o, function (t) { let n; n = "function" == typeof e ? e : function () { return e }; const r = Object.create(t, s.b); return r.source = t, r.subjectFactory = n, r })(t)); var e } } }, "x+ZX": function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("7o/Q"); function r() { return function (t) { return t.lift(new i(t)) } } class i { constructor(t) { this.connectable = t } call(t, e) { const { connectable: n } = this; n._refCount++; const s = new o(t, n), r = e.subscribe(s); return s.closed || (s.connection = n.connect()), r } } class o extends s.a { constructor(t, e) { super(t), this.connectable = e } _unsubscribe() { const { connectable: t } = this; if (!t) return void (this.connection = null); this.connectable = null; const e = t._refCount; if (e <= 0) return void (this.connection = null); if (t._refCount = e - 1, e > 1) return void (this.connection = null); const { connection: n } = this, s = t._connection; this.connection = null, !s || n && s !== n || s.unsubscribe() } } }, xbPD: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("7o/Q"); function r(t = null) { return e => e.lift(new i(t)) } class i { constructor(t) { this.defaultValue = t } call(t, e) { return e.subscribe(new o(t, this.defaultValue)) } } class o extends s.a { constructor(t, e) { super(t), this.defaultValue = e, this.isEmpty = !0 } _next(t) { this.isEmpty = !1, this.destination.next(t) } _complete() { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete() } } }, yCtX: function (t, e, n) { "use strict"; n.d(e, "a", function () { return o }); var s = n("HDdC"), r = n("ngJS"), i = n("jZKg"); function o(t, e) { return e ? Object(i.a)(t, e) : new s.a(Object(r.a)(t)) } }, "z+Ro": function (t, e, n) { "use strict"; function s(t) { return t && "function" == typeof t.schedule } n.d(e, "a", function () { return s }) }, z6cu: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("HDdC"); function r(t, e) { return new s.a(e ? n => e.schedule(i, 0, { error: t, subscriber: n }) : e => e.error(t)) } function i({ error: t, subscriber: e }) { e.error(t) } }, zP0r: function (t, e, n) { "use strict"; n.d(e, "a", function () { return r }); var s = n("7o/Q"); function r(t) { return e => e.lift(new i(t)) } class i { constructor(t) { this.total = t } call(t, e) { return e.subscribe(new o(t, this.total)) } } class o extends s.a { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { ++this.count > this.total && this.destination.next(t) } } }, zp1y: function (t, e, n) { "use strict"; n.d(e, "a", function () { return i }); var s = n("l7GE"), r = n("ZUHj"); function i(...t) { return e => { let n; return "function" == typeof t[t.length - 1] && (n = t.pop()), e.lift(new o(t, n)) } } class o { constructor(t, e) { this.observables = t, this.project = e } call(t, e) { return e.subscribe(new a(t, this.observables, this.project)) } } class a extends s.a { constructor(t, e, n) { super(t), this.observables = e, this.project = n, this.toRespond = []; const s = e.length; this.values = new Array(s); for (let r = 0; r < s; r++)this.toRespond.push(r); for (let i = 0; i < s; i++) { let t = e[i]; this.add(Object(r.a)(this, t, void 0, i)) } } notifyNext(t, e, n) { this.values[n] = e; const s = this.toRespond; if (s.length > 0) { const t = s.indexOf(n); -1 !== t && s.splice(t, 1) } } notifyComplete() { } _next(t) { if (0 === this.toRespond.length) { const e = [t, ...this.values]; this.project ? this._tryProject(e) : this.destination.next(e) } } _tryProject(t) { let e; try { e = this.project.apply(this, t) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } }, zx2A: function (t, e, n) { "use strict"; n.d(e, "a", function () { return o }), n.d(e, "b", function () { return a }), n.d(e, "c", function () { return c }); var s = n("7o/Q"), r = n("HDdC"), i = n("SeVD"); class o extends s.a { constructor(t) { super(), this.parent = t } _next(t) { this.parent.notifyNext(t) } _error(t) { this.parent.notifyError(t), this.unsubscribe() } _complete() { this.parent.notifyComplete(), this.unsubscribe() } } class a extends s.a { notifyNext(t) { this.destination.next(t) } notifyError(t) { this.destination.error(t) } notifyComplete() { this.destination.complete() } } function c(t, e) { if (!e.closed) return t instanceof r.a ? t.subscribe(e) : Object(i.a)(t)(e) } } }]);